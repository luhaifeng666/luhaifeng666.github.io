<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luhaifeng666.github.io</id>
    <title>酱豆腐精的小站</title>
    <updated>2022-01-28T04:21:23.323Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luhaifeng666.github.io"/>
    <link rel="self" href="https://luhaifeng666.github.io/atom.xml"/>
    <subtitle>我吹，你听</subtitle>
    <logo>https://luhaifeng666.github.io/images/avatar.png</logo>
    <icon>https://luhaifeng666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 酱豆腐精的小站</rights>
    <entry>
        <title type="html"><![CDATA[Pinia初体验]]></title>
        <id>https://luhaifeng666.github.io/post/pinia-chu-ti-yan/</id>
        <link href="https://luhaifeng666.github.io/post/pinia-chu-ti-yan/">
        </link>
        <updated>2022-01-27T18:58:57.000Z</updated>
        <summary type="html"><![CDATA[<p>1月20日，尤大在知乎平台发布 <a href="https://zhuanlan.zhihu.com/p/460055155"><code>Vue3</code> 将自2月7日起成为默认版本</a>的消息</p>
]]></summary>
        <content type="html"><![CDATA[<p>1月20日，尤大在知乎平台发布 <a href="https://zhuanlan.zhihu.com/p/460055155"><code>Vue3</code> 将自2月7日起成为默认版本</a>的消息</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/690b04d56e8d4672bc59056611c95967~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p><code>Vue3</code> 相关的技术栈也可以学习起来啦~本文就同大家一起初步体验下 “下一代的Vuex” -- <a href="https://pinia.vuejs.org/">Pinia</a>。</p>
<h1 id="什么是pinia">什么是Pinia</h1>
<h2 id="pinia-介绍">Pinia 介绍</h2>
<p>大概在2019年11月份左右，Pinia 的作者开始尝试重新设计 Store 状态管理以适用于 Composition API，其设计原则跟思想与 Vuex 保持一致。</p>
<p>在不同版本的 Vue 中，所使用的 Vuex 版本是不一样的。Vue2 中需要使用 Vuex 3.x的版本，而在 Vue3 中需要使用 Vuex 4.x。但是 Pinia 没有这个限制，无论是在 Vue2 中，还是在 Vue3 中均可以使用 Pinia，<strong>且不一定要与 Composition API 一起使用</strong>，API 的使用方式在两者中也是保持一致的。</p>
<p>现在，Pinia 也已经正式被纳入 Vue 官方体系中。笔者写这篇文章时，其版本已更新至 <strong>v2.0.9</strong> 。</p>
<h2 id="为啥要用-pinia">为啥要用 Pinia</h2>
<p>Pinia 是用于 Vue 中的状态管理器，允许你跨组件/页面共享状态。</p>
<p>如果小伙伴们已经对 Composition API 比较熟悉了的话，可能会考虑使用类似下面这种写法去共享全局状态：</p>
<pre><code class="language-vue">export const state = reactive({})
</code></pre>
<p>在 SPA 应用中，这样去做是可以的，但是如果是在 SSR 中去使用的话会存在安全隐患。所以还是建议使用 Pinia。</p>
<p>使用 Pinia 有以下好处：</p>
<ol>
<li>
<p><strong>调试工具支持</strong></p>
<p>笔者目前安装的是 beta 版本的 Vue devtool，小伙伴们可以去 <a href="chrome://extensions">谷歌应用商店</a> 中搜索 <code>Vue devtool</code> 下载对应的 beta 版本。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acca1566bfe4502bc35cee45a4f0589~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<ol>
<li>调试工具中支持追踪 actions，mutations 的timeline(时间线)；</li>
<li>可以显示当前组件中使用的 store 信息，也可以显示所有 store 容器的信息，支持直接修改数据进行调试；</li>
<li>支持 Time travel(时间旅行) 以方便调试。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>热模块替换</strong>：改变状态时无需手动刷新页面。</li>
<li><strong>插件支持</strong>：可以通过插件扩展 Pinia 的能力。</li>
<li><strong>良好的 Typescript 支持</strong>：可以提供较为完善的代码提示以及代码自动补充。</li>
<li><strong>支持 SSR</strong>。</li>
</ol>
<h2 id="pinia-与-vuex-的对比">Pinia 与 Vuex 的对比</h2>
<p>Pinia 与 Vuex4.x 以下版本相比，有如下区别：</p>
<blockquote>
<ol>
<li><strong>移除了 mutations</strong>： 在 Vuex 中，想要改变状态，需要通过提交 mutations 来实现，而 mutations 不能执行异步操作，因此诞生了 actions ，在异步获取数据后，通过 actions 调用 mutations 修改数据。现在在 Pinia 中，actions 同时支持同步与异步操作，所以 mutations 显得有些冗余了，因此不再需要；</li>
<li><strong>对于 Typescript 的支持更加友好</strong>：使用 Pinia 时,不再需要定义复杂的 wrappers（包装器）去支持Typescript;</li>
<li><strong>不会注入魔法字符串</strong>：在组件中使用 Vuex 时，经常会出现类似 <code>this.$store.commit(&quot;xxxxx&quot;)</code> 这样的魔法字符串，虽然会将这些字符串抽为常量暴露出来，但是维护起来还是不太方便。在 Pinia 中不再需要使用这种方式，而是直接调用 <code>defineStore</code> 后暴露出来的方法，而后通过 <code>$patch</code>, <code>action</code> 的方式，或者直接修改 store 中的值即可；</li>
<li><strong>不需要动态添加 stores</strong>：只要你愿意，你可以随时定义 stores，它们默认是动态的；</li>
<li><strong>不再需要嵌套结构的 modules</strong>;</li>
<li><strong>没有带命名空间的模块</strong>。</li>
</ol>
</blockquote>
<h1 id="pina的使用">Pina的使用</h1>
<h2 id="安装">安装</h2>
<p>我们先在本地搭建一个Vue3的项目，用于演示 <code>Pinia</code> 的使用，这里我们使用 <a href="https://cn.vitejs.dev/">Vite</a> 来搭建：</p>
<blockquote>
<p>Vite 需要 <a href="https://nodejs.org/en/">Node.js</a> 版本 &gt;= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<p>Vite官方提供了使用模板的方式构建本地项目，这里我们通过 <a href="https://www.pnpm.cn/">pnpm</a> 来构建一个 <code>Vite + Vue</code> 的本地项目。现在 Vue3 以及 Pinia 对于 Typescript 的支持已经非常良好了,建议大家在使用模板构建项目的时候直接选择 Typescript 对应的模板：</p>
<pre><code>pnpm create vite pinia-useage-examples -- --template vue-ts
</code></pre>
<p>之后，我们在项目中安装 <code>Pinia</code>:</p>
<pre><code> pnpm add pinia
</code></pre>
<p>准备工作完成，接下来就来一起体验一下 <code>Pinia</code> 吧~</p>
<h2 id="使用">使用</h2>
<p>首先，我们需要通过 <code>createPinia</code> 初始化 Pinia，并将其挂载到 Vue 的实例上：</p>
<pre><code class="language-ts">// src/main.ts

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

// 创建 pinia
const pinia = createPinia()

const app = createApp(App)
// 挂载到 Vue 实例上
app.use(pinia)
app.mount('#app')
</code></pre>
<p>之后按照惯例，我们先创建 <code>src/store/index.ts</code> 文件，用于存放 store:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  
})
</code></pre>
<p><strong>这里需要注意的是，<code>defineStore</code> 的第一个参数用于设置 store 的容器名称，该名称必须唯一，不可重复！</strong></p>
<p>上文中提到，相比于 Vuex，Pinia 中移除了 mutations，剩余需要了解的内容主要包含四个部分：</p>
<blockquote>
<ol>
<li><strong>State</strong>: 用于存放数据，有点儿类似 <code>data</code> 的概念；</li>
<li><strong>Getters</strong>: 用于获取数据，有点儿类似 <code>computed</code> 的概念；</li>
<li><strong>Actions</strong>: 用于修改数据，有点儿类似 <code>methods</code> 的概念；</li>
<li><strong>Plugins</strong>: Pinia 插件。</li>
</ol>
</blockquote>
<p>现在我们依次来看一看它们的用法。</p>
<h2 id="state">State</h2>
<h3 id="定义-state">定义 State</h3>
<p>在 Vuex 中，通过对象的形式来定义 state ，而在 Pinia 中则需要通过函数的方式定义 state，这种方式有点儿类似组件中 <code>data</code> 的概念:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  state: () =&gt; {
    return {
      count: 0,
      name: 'foo',
      list: [1, 2, 3]
    }
  }
})
</code></pre>
<h3 id="读取-state">读取 State</h3>
<p>state 定义完成后，我们在页面中可以通过引入暴露出去的 <code>useStore</code> 来读取 state 中的数据：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;p&gt;count: {{ myStore.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ myStore.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ myStore.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const myStore = useStore()
&lt;/script&gt;
</code></pre>
<p>看到这里，有的小伙伴不禁会问，在使用过程中，一直要写 <code>myStore.xxx</code> 不是很麻烦么？能否通过解构的方式来使用呢？</p>
<p>那我们就一起来试一试，看看是否可以通过解构的方式来获取 store 中的值:</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const { count, name, list } = useStore()
&lt;/script&gt;
</code></pre>
<p>通过这次尝试我们发现，确实可以通过解构的方式来获取到 store 的值。但是这种方式存在一个问题：<strong>直接通过解构的方式获取state中的值是非响应式的！</strong> 这就意味着后面在对 store 中的值进行修改之后，页面不会发生变化。</p>
<p>那我们改如何解决这个问题呢？答案是通过 Pinia 中提供的 <code>storeToRefs</code> 方法，将结构出来的值转换为响应式的值即可：</p>
<pre><code class="language-ts">// src/App.vue

&lt;script setup lang=&quot;ts&quot;&gt;
import { storeToRefs } from 'pinia'
import { useStore } from './store'

const { count, name, list } = storeToRefs(useStore())
&lt;/script&gt;
</code></pre>
<p>除了使用这两种方式以外，Pinia 也提供了 <code>mapState</code> 与 <code>computed</code> 相结合的方式去获取 store 中的值，这种方式与 Vuex 中的 <code>mapState</code> 类似：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ res.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ res.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ res.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, ['count', 'name', 'list'])
  }
  return {
    count: data.count(),
    name: data.name(),
    list: data.list()
  }
})
&lt;/script&gt;
</code></pre>
<p>由于是通过 <code>computed</code> 获取到的值，所以结构之后的值就是响应式的，不需要使用 <code>stateToRefs</code> 方法进行转换。</p>
<p>在 <code>computed</code> 内部也可以对属性进行重命名，或者重新定义新的返回值返回值：</p>
<pre><code class="language-js">&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, {
      // 重命名count为myCount, 并返回count + 1的结果
      myCount: state =&gt; state.count += 1,
      // 重命名name为没有Name，并返回name的值
      myName: 'name',
      // 重命名list为myList，并返回插入4之后的list
      myList: state =&gt; {
        state.list.push(4)
        return state.list
      }
    })
  }
  return {
    count: data.myCount(),
    name: data.myName(),
    list: data.myList()
  }
})
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>本文的示例中使用的是 <code>setup</code> 语法糖，如果不使用 <code>setup</code> 语法糖的话，<code>mapState</code> 的使用方式与本文中所举的🌰有些差别(关于这个问题，网上有使用 <code>bind</code> 的方式的栗子，具体可以参考<a href="https://blog.csdn.net/WaiTinglw/article/details/122091494">这篇文章</a>)。详情可以查阅<a href="https://pinia.vuejs.org/core-concepts/state.html#usage-with-the-options-api">官方文档</a>。如果本文中有使用不当之处，还请诸位大佬指正~ Orz；</li>
<li>通过 <code>computed</code> 返回的 state 无法使用结构的方式获取其中的值，因为返回的不是单纯的对象，而是一个 <code>ComputedRefImpl</code> 类型的值。</li>
<li>通过 <code>mapState</code> 获取到的值是<strong>只读</strong>的，如果想要其可写，可以使用 <code>mapWritableState</code> 的方式。</li>
</ol>
</blockquote>
<h3 id="修改-state">修改 State</h3>
<p>现在我们已经可以获取到 State 中存储的值了，那么我们该如何去修改 State 中的值呢？其实很简单，主要分为以下几种方式：</p>
<h4 id="第一种直接修改">第一种：直接修改</h4>
<p>直接修改 State 中的值即可：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()
// 修改store中的值
const handleChangeStore = () =&gt; {
  // 直接修改
  store.count += 1
}
&lt;/script&gt;
</code></pre>
<p>甚至可以通过暴力覆盖 <code>$state</code> 的方式将所有值进行替换修改：</p>
<pre><code class="language-ts">// src/App.vue

// 省略好多好多代码。。。

// 直接清空store
store.$state = {}
</code></pre>
<h4 id="第二种-通过-patch-的方式修改">第二种: 通过 <code>$patch</code> 的方式修改</h4>
<p>当我们需要一次性修改多个值的时候，我们可以使用 <code>$patch</code> 方法来批量修改多个值：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过 $patch 的方式修改
  store.$patch({
    name: 'test',
    list: [...store.list, 4]
  })
}
&lt;/script&gt;
</code></pre>
<p><code>$patch</code> 会将传入的对象与 Store 中的 state 进行 merge 覆盖。</p>
<p>除了直接传入对象外，如果存在较为复杂的操作，<code>$patch</code> 方法也接受传入一个回调函数，在回调函数中对需要修改的数据进行操作：</p>
<pre><code>// src/App.vue

// 省略好多好多代码。。。
store.$patch(state =&gt; {
  state.name = `我的名字是：${state.name}`
})

</code></pre>
<h4 id="第三种通过-reset-方法恢复原值">第三种：通过 <code>$reset</code> 方法恢复原值</h4>
<p>当我们修改了 state 中的值以后，倘若我们想让它们恢复到初始值，可以使用 <code>$reset</code> 方法。</p>
<h4 id="第四种通过调用-actions-中的方法去修改值">第四种：通过调用 <code>actions</code> 中的方法去修改值</h4>
<p>首先，我们需要在 Store 容器中定义 <code>actions</code>:</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  actions: {
    changeCount () {
      this.count ++
    }
  }
})
</code></pre>
<p>在 <code>actions</code> 中定义的方法，可以直接通过 <code>this</code> 来访问 state 中的属性，而无需像 Vuex 那样传入上下文才可以，使用方式有点儿类似 <code>methods</code>。</p>
<p>定义完成后，我们就可以在引用处直接使用它了：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过actions的方式修改
  store.changeCount()
}
&lt;/script&gt;
</code></pre>
<p>当然，<code>actions</code> 中的方法也可以接收入参，使用方式与 <code>methods</code> 并无区别，这里不做过多赘述。</p>
<h3 id="调试-state">调试 State</h3>
<p>打开控制台，切换到 Vue devtool 中，选择 <code>Pinia</code> 选项，就可以看到 store 容器的信息：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e6e06b6634e4ec8bfdcac7aeaf3c55d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>并且点击数据后面的编辑按钮，也可以修改 store 中的值进行调试，非常方便：</p>
<figure data-type="image" tabindex="4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99a0e1af8e74eefa41784219996ad81~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="getters">Getters</h2>
<p><code>getters</code> 的使用方式有点儿类似于 <code>computed</code>, 返回一个值(<strong>没有返回值也可以</strong>)且在页面中可以直接使用。如果 <code>getters</code> 中使用了 <code>state</code> 里的数据，当对应的数据发生变化时，<code>getters</code> 的值也会相应发生变化：</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  getters: {
    countPlusOne (state) {
      console.log('------countPlusOne------')
      return state.count + 1
    }
  }
})
</code></pre>
<p>直接在页面中使用，并且 <code>getters</code> 也有缓存，在页面中多次使用时，只会计算一次：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;p&gt;countPlusOne: {{ store.countPlusOne }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()
&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf3831592af4344a1cfe7483c520ec6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>我们可以看到日志只打印了一次，说明后面两次是取的缓存中的数据。</p>
<blockquote>
<p>注意：</p>
<ol>
<li><code>getters</code> 中定义的方法，入参 <code>state</code> 是可选参数，如果不传入 <code>state</code>, 可以直接使用 <code>this</code> 访问 <code>state</code> 中的数据；</li>
<li>如果不传入 <code>state</code> 的话，Typescript 会有报错提示，因为无法推导出 <code>getters</code> 中方法的返回值类型，需要手动声明返回值类型。</li>
</ol>
</blockquote>
<h2 id="actions">Actions</h2>
<p>上文中提到可以通过 <code>Actions</code> 的方式修改 <code>State</code> 中的值，只不过所使用的是同步的方式。在一开始对 Pinia 的介绍中也提到，<code>Actions</code> 同时支持同步与异步两种修改数据的方式。接下来我们看看如何通过 <code>Actions</code> 异步修改数据。</p>
<pre><code class="language-ts">// src/store/index.ts

// 省略好多好多代码。。。
actions: {
  async changeName () {
    const newName: string = await new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('newName')
      }, 1000)
    }).catch(err =&gt; {
    })
    this.name = newName
  }
}
</code></pre>
<p>通过上述代码我们不难发现，其实 <code>Actions</code> 通过异步修改数据的方式与寻常使用 <code>methods</code> 异步修改 <code>data</code> 中的数据类似，相较于 Vuex 简便许多。</p>
<h2 id="plugins">Plugins</h2>
<h3 id="插件介绍">插件介绍</h3>
<p>通过自定义 <code>Plugins</code> 可以扩展 <code>Stores</code>，它可以完成以下这些事情：</p>
<blockquote>
<ol>
<li>新增 <code>store</code> 中的属性;</li>
<li>定义 <code>store</code> 时传入新的配置项;</li>
<li>新增 <code>store</code> 中的方法;</li>
<li>包装 <code>store</code> 中的既有方法;</li>
<li>修改甚至取消 <code>actions</code>;</li>
<li>实现一些副作用操作，例如设置 local storage 缓存等等;</li>
<li>只会应用于特定的 <code>store</code>: 在 Pinia 挂载到 app 上后，插件会挂载到之后创建的 Stores 上，在此之前 Plugins 不会被挂载。</li>
</ol>
</blockquote>
<h3 id="插件定义-使用">插件定义 &amp; 使用</h3>
<p>插件本质上是一个函数，插件接受一个可选入参： <code>context</code>, 改入参是个对象，其中包含四项内容：</p>
<ol>
<li><strong>context.pinia:</strong> 通过 <code>createPinia()</code> 方式创建的 Pinia 实例</li>
<li><strong>context.app:</strong> 通过 <code>createApp()</code> 方式创建的 app 实例(仅支持Vue 3)</li>
<li><strong>context.store:</strong> store 对象</li>
<li><strong>context.options:</strong> 获取定义 store 时传入的配置项</li>
</ol>
<p>函数可以通过返回对象的方式，将对象中的值绑定到<strong>所有的</strong> store 上去：</p>
<pre><code class="language-ts">// src/main.ts

function SecretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}
</code></pre>
<p>定义完成后，通过 <code>pinia.use()</code> 的方式使用这个插件：</p>
<pre><code class="language-ts">// src/main.ts
import { createPinia } from 'pinia'

const pinia = createPinia()

pinia.use(SecretPiniaPlugin)
</code></pre>
<p>之后，在页面中打印 Store 中的 <code>secret</code> 属性时，即可看到我们设定的值。并且通过这种方式新增到 store 中的属性可以被 Vue devtool 捕获到：</p>
<figure data-type="image" tabindex="6"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5de1b7353e4de3b4a5deca838997c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>当然你也可以选择直接将值绑定到 store 对象上，但是这样<strong>无法被 Vue devtool捕获</strong>：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7178d567ae64a8d9a61e9c40bb0a93a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>此时我们不难发现，上述步骤中的 <code>customProperties</code> 属性不见了。如果在调试过程中需要在 Vue devtool 中看到插件中定义的 store 内容，需要手动添加：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}
</code></pre>
<p>添加完属性后，当我们直接在页面中使用时，发现页面上并不能显示出插件插入到 store 中的属性，这是因为插入的属性是<strong>非响应式的</strong>，此时，我们只需将插入的属性值变为<strong>响应式数据</strong>即可：</p>
<pre><code class="language-ts">import { createApp, ref } from 'vue'
import { createPinia } from 'pinia'

// 创建 pinia
const pinia = createPinia()

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = ref('the cake is a lie')
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}

// 使用插件
pinia.use(SecretPiniaPlugin)
</code></pre>
<p>设置完成后，再在页面中使用时，就可以在页面上看到数据啦~</p>
<p>此外，在插件中可以通过 <code>store.$subscribe</code> 以及 <code>store.$onActions</code> 方法监听 actions 的触发。</p>
<p>关于插件的更多玩法可以参考<a href="https://pinia.vuejs.org/core-concepts/plugins.html">官方文档</a>。</p>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，相信大家对于 <code>Pinia</code> 已经有了一个初步的印象。文章中若有描述不当之处还请诸位大佬指正。</p>
<p>好记性不如烂笔头，关于 Pinia 的其他更多玩法等待着小伙伴们去挖掘。赶快动手 <s>卷起来</s> 尝个鲜吧~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写练习：防抖节流]]></title>
        <id>https://luhaifeng666.github.io/post/shou-xie-lian-xi-fang-dou-jie-liu/</id>
        <link href="https://luhaifeng666.github.io/post/shou-xie-lian-xi-fang-dou-jie-liu/">
        </link>
        <updated>2022-01-18T16:45:06.000Z</updated>
        <summary type="html"><![CDATA[<p>不论在日常工作中，还是在面试过程中，<code>防抖节流</code> 总是会时不时的出现在我们的视野里。在日常使用的时候，可能会直接使用第三方库封装好的方法，比如 <code>lodash</code> 中的防抖方法 <a href="https://lodash.com/docs/4.17.15#debounce"><em>.debounce</a> 和节流方法 <a href="https://lodash.com/docs/4.17.15#throttle"></em>.throttle</a>。抑或是使用开发团队的小伙伴们封装好的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不论在日常工作中，还是在面试过程中，<code>防抖节流</code> 总是会时不时的出现在我们的视野里。在日常使用的时候，可能会直接使用第三方库封装好的方法，比如 <code>lodash</code> 中的防抖方法 <a href="https://lodash.com/docs/4.17.15#debounce"><em>.debounce</a> 和节流方法 <a href="https://lodash.com/docs/4.17.15#throttle"></em>.throttle</a>。抑或是使用开发团队的小伙伴们封装好的方法。</p>
<!-- more -->
<p>在忙碌的工作中，也许小伙伴们知道它们的作用，但是对其中的原理逐渐陌生。今天我们就把这两个 <code>老朋友</code> 请出来，再来一起看看是如何实现的吧~</p>
<h1 id="节流方法throttle">节流方法：throttle</h1>
<h2 id="什么是节流">什么是节流</h2>
<p>用一句话概括节流：</p>
<blockquote>
<p>在规定的延时时间内，不管你执行多少次，我都只认第一次。</p>
</blockquote>
<h2 id="节流的实现">节流的实现</h2>
<pre><code class="language-js">/**
 * 节流函数
 * @param fn
 * @param delay
 */
function throttle (fn, delay) {
 // 上一次的调用时间
 let lastTime = 0

 // 将throttle结果以函数形式返回
 return function () {
  // 保存执行时上下文
  const context = this
  // 保存调用throttle结果函数时传入的参数
  const args = arguments
  // 本地调用的时间
  const time  = new Date()
  // 如果本次调用时间减去上一次的调用时间大于延迟时间，则触发传入的fn
  if (time - lastTime &gt; delay) {
   lastTime = time
   fn.apply(context, args)
  }
 }
}
</code></pre>
<h1 id="防抖方法debounce">防抖方法：debounce</h1>
<h2 id="什么是防抖">什么是防抖</h2>
<p>用一句话概括防抖：</p>
<blockquote>
<p>在规定的延时时间内，不管你触发多少次回调，都只认最后一次。</p>
</blockquote>
<h2 id="防抖的实现">防抖的实现</h2>
<pre><code class="language-js">/**
 * 防抖
 * @param fn
 * @param delay
 */
function debounce (fn, delay) {
 // 保存延时
 let timer = null
 // 将debounce的处理结果以函数形式返回
 return function () {
  // 保存执行时上下文
  const context = this
  // 保存执行时传入的参数
  const args = arguments
  // 如果存在定时器，则将其清除
  timer &amp;&amp; clearTimeout(timer)
  // 设置新的定时器，在计时结束后触发回调
  timer = setTimeout(() =&gt; {
   fn.apply(context, args)
  }, delay)
 }
}
</code></pre>
<h1 id="防抖的弊端">防抖的弊端</h1>
<p>防抖与节流的目的，都是在一定时间内限制回调函数被调用的次数，从而在一定程度上提升性能。</p>
<p>但是防抖存在一个弊端，那就是如果在 <code>delay</code> 指定的时间内不断触发防抖，就会导致回调函数迟迟不会有响应。只有在你 <code>停手</code> 之后，经过 <code>dealy</code> 这段时间后，回调函数才会有响应。</p>
<p>既然如此，如果我们能在一开始就触发回调，然后在后续频繁的操作里保持防抖的特性，岂不是美滋滋~</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f590f56f027483396cbd269655ac3e6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="加强版的节流方法strongerthrottle">加强版的节流方法：strongerThrottle</h1>
<p>回顾我们之前所实现的 <code>节流</code> 方法，它不正是在一开始就可以立即调用回调函数的么？既然如此，我们可以使用 <code>throttle</code> 方法来对 <code>debounce</code> 方法进行优化，实现一个加强版的节流方法。</p>
<pre><code class="language-js">/**
 * 更健壮的节流，结合了防抖
 * @param fn
 * @param delay
 */
function strongerThrottle (fn, delay) {
 // 保存计时器与最后一次调用时间
 let timer = null
 let lastTime = 0
 // 将调用strongerThrottle的结果以函数形式返回
 return function () {
  // 保存执行上下文
  const context = this
  // 保存传入的参数
  const args = arguments
  // 保存当前调用时间
  const time = new Date()
  // 如果当前调用的时间减去最后一次调用的时间小于延迟时间，则设置定时器
  if (time - lastTime &lt; delay) {
   // 如果存在定时器，则先清空
   timer &amp;&amp; clearTimeout(timer)
   // 设置新的定时器，在计时结束后触发回调
   timer = setTimeout(function () {
    lastTime = time
    fn.apply(context, args)
   }, delay)
  } else {
   // 如果超出时间，则给出响应
   lastTime = time
   fn.apply(context, args)
  }
 }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS学习：边框内圆角]]></title>
        <id>https://luhaifeng666.github.io/post/css-xue-xi-bian-kuang-nei-yuan-jiao/</id>
        <link href="https://luhaifeng666.github.io/post/css-xue-xi-bian-kuang-nei-yuan-jiao/">
        </link>
        <updated>2022-01-17T13:35:26.000Z</updated>
        <summary type="html"><![CDATA[<p>需求：<strong>元素边框内侧的四个角为圆角，形成内圆角的效果</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>需求：<strong>元素边框内侧的四个角为圆角，形成内圆角的效果</strong>。</p>
<!-- more -->
<h3 id="想法一">想法一</h3>
<p>这个需求主要分为两部分，边框和圆角。实现边框跟圆角并不困难，只要使用border以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">border-radius</a>属性即可：</p>
<h4 id="代码1">代码1</h4>
<pre><code class="language-css">border: 10px solid #67C23A;  
border-radius: 10px;  
</code></pre>
<p>实现效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3508271000114aada421533011a1808c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>我们可以看到，最终实现的是外圆角内直角的效果，因为在设置 <code>border-radius</code> 的时候，是算上边框的。</p>
<h3 id="想法二">想法二</h3>
<p>在<a href="https://juejin.cn/post/7052624943795666974">多重边框</a>这篇文章中提到过 <code>outline</code>，那我们是否可以通过 <code>outline</code> 以及 <code>border-radius</code> 的方式来实现这个效果呢：</p>
<h4 id="代码2">代码2</h4>
<pre><code class="language-css">outline: 10px solid #67C23A;  
border-radius: 10px;  
</code></pre>
<p>具体效果如下所示：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ebe260ff7d4596841484ddd16b8fe0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>实际效果距离我们的预期已经非常接近了，可是在元素的四个角还存在白色的空隙，那该怎么填上呢？答案是<strong>box-shadow!</strong> 我们可以利用它来实现这个效果：</p>
<h4 id="代码3">代码3</h4>
<pre><code class="language-css">outline: 10px solid #67C23A;  
border-radius: 10px;  
box-shadow 0 0 0 4px #67C23A  
</code></pre>
<p>最后的效果如下所示：</p>
<demo-1-4 :type="'type3'" />  
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb97b6321e5e4948b5ddf7d757f7bd85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>那这个偏移量我们要设置多少合适呢？其实计算也非常简单。四个内圆角其实就是4个1/4圆:<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa239afce1e942338be271fa28241430~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></p>
<p>通过勾股定理可以求得 <code>L = √2R</code> ，<code>box-shadow</code> 需要设置的偏移量为 <code>L - R = (√2 - 1) * R</code>，其中，<code>R</code> 是 <code>border-radius</code> 的值。所以在上述例子中，偏移量的距离大概为：<code>0.414 * 10 = 4px</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[背景定位]]></title>
        <id>https://luhaifeng666.github.io/post/bei-jing-ding-wei/</id>
        <link href="https://luhaifeng666.github.io/post/bei-jing-ding-wei/">
        </link>
        <updated>2022-01-14T02:19:40.000Z</updated>
        <summary type="html"><![CDATA[<p>CSS2.1中，使用 <code>background-position</code> 属性进行背景定位，可以通过设置 <code>top,left,right,bottom</code> 来实现，也可以设置具体的数值或者百分比来实现，但是在不固定宽高的容器中，想要跟容器的边框保留固定的边距，就只能通过百分比实现大概的间距，不能精确到具体位置。而在CSS3中，则存在两种方案，可以实现背景定位的位置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>CSS2.1中，使用 <code>background-position</code> 属性进行背景定位，可以通过设置 <code>top,left,right,bottom</code> 来实现，也可以设置具体的数值或者百分比来实现，但是在不固定宽高的容器中，想要跟容器的边框保留固定的边距，就只能通过百分比实现大概的间距，不能精确到具体位置。而在CSS3中，则存在两种方案，可以实现背景定位的位置。</p>
<!-- more -->
<h3 id="1-background-position的扩展语法">1、background-position的扩展语法</h3>
<p>在CSS3中，可以指定背景图片<strong>距离任意角的偏移量</strong>，只要我们在<strong>偏移量前指定关键字即可。</strong></p>
<pre><code class="language-css">background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-color: #409EFF;  
</code></pre>
<p>效果如下图所示:</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42078d94ae5f4eb2b901920556799c96~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>此时，图中的喵酱距离上边10px，距离左边10px。这样就可以实现精确定位。</p>
<h3 id="2-background-origin">2、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin">background-origin</a></h3>
<p>在日常开发过程中，有这样一个场景，我需要图片的偏移量与内边距一致。如果继续使用上述方法的话，可能会出现如下代码：</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-color: #409EFF;  
</code></pre>
<p>这样写确实实现了我们想要的效果，可是如果此时我的需求发生变化，内边距需要改为20px，这样一来，就导致我们需要改三个地方的数值。如果只是少数几个地方还好，如果改动的地方比较多，那么久增加了日常维护的成本。</p>
<p>我们知道，除去margin以外，元素的内容主要分成以下三个部分：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fdd248584a482a8012d40c85b0766d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>背景定位中的 <code>top,left,right,bottom</code> ，它们的定位都是依据 <code>padding-box</code> 来的，此时，我们可以通过 <code>background-origin</code> 来修改默认的参照：</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-origin: content-box;  
</code></pre>
<p>我们只需要修改 <code>padding</code> 一个值，就可以灵活应对上述变化了。<br><br>
与之相仿，我们也可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc">calc</a>来实现定位。</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat calc(100% - 20px) calc(100% - 10px) / 30%;  
background-origin: content-box;  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多重边框]]></title>
        <id>https://luhaifeng666.github.io/post/css-xue-xi-duo-chong-bian-kuang/</id>
        <link href="https://luhaifeng666.github.io/post/css-xue-xi-duo-chong-bian-kuang/">
        </link>
        <updated>2022-01-13T09:42:24.000Z</updated>
        <summary type="html"><![CDATA[<p>多重边框主要分为两种情况，一种是两层边框，还有一种是2层以上的边框。针对这两种情况，分别对应有不同的处理方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>多重边框主要分为两种情况，一种是两层边框，还有一种是2层以上的边框。针对这两种情况，分别对应有不同的处理方案。</p>
<!-- more -->
<h3 id="1-outline">1、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/outline">outline</a></h3>
<p>某些情况下，如果你只需要两层边框，那么可以使用 <code>outline</code> 来实现。</p>
<pre><code class="language-css">background: #409EFF;  
border: 10px solid #67C23A;  
outline: 5px solid #E6A23C;  
</code></pre>
<p>如<a href="https://codepen.io/luhaifeng666/pen/QWqzwKO">demo1</a>。其中，绿色的是 <code>border</code>，黄色的是 <code>outline</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1c4a60f8ff486893e11bd1cc5985cc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p><strong>优点</strong></p>
<ol>
<li>比较灵活，可以自由设置边框的样式；</li>
<li>也可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset">outline-offset</a>来设置跟元素边缘之间的距离，这个属性可以接受负值。设置负值时则是显示的内边框，类似于 <code>box-shadow</code> 的 <code>inset</code> 。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>只适用于双边框的样式，多边框的样式不能用；</li>
<li>产生的边框不能贴合设置了圆角的元素，需要配合 <code>box-shadow</code> 来优化这个问题（后面会提到）;</li>
<li>根据CSS基本UI特性(第三版)规范，<strong>描边可以不是矩形</strong>，使用时要测试各个浏览器的表现情况。</li>
</ol>
</blockquote>
<h3 id="2-box-shadow">2、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow">box-shadow</a></h3>
<p>常规的 <code>box-shadow</code> 是用来设置阴影的，但是这个属性可以设置多值，通过它的偏移特性，我们可以生成多重边框。</p>
<pre><code class="language-css">margin: 50px auto;  
box-shadow: 0 0 0 10px #67C23A, 0 0 0 20px #F56C6C, 0 0 0 30px #E6A23C;  
</code></pre>
<p>参考<a href="https://codepen.io/luhaifeng666/pen/QWqzwKO">demo2</a>。</p>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185eaf1c75844b09962a19f6694305df~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p><strong>优点</strong></p>
<ol>
<li>相比较于 <code>outline</code> ，这种方式可以设置多重边框；</li>
<li>除了边框，<code>box-shadow</code> 的偏移还能实现其他更多神奇的效果</li>
</ol>
</blockquote>
<blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>相比较outline边框的自由设置，<code>box-shadow</code> 不能实现类似边框虚线的效果；</li>
<li>不会影响布局，也不会受到<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing">box-sizing</a>属性的影响；</li>
<li>不会影响鼠标的事件，比如hover还有click，使用的时候要注意。</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[半透明边框]]></title>
        <id>https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/</id>
        <link href="https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/">
        </link>
        <updated>2022-01-12T02:34:10.000Z</updated>
        <summary type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
]]></summary>
        <content type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
<!-- more -->
<p>我们在想实现一个透明边框的时候，通常想到的可能是以下代码：</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
</code></pre>
<p>可是如果这时候给元素添加一个背景色或者背景图片，背景图片与背景色会透过透明边框显示出来。这是因为<strong>在默认情况下,背景会延伸到边框所在区域的下层。</strong></p>
<p>先来看一个<a href="https://codepen.io/luhaifeng666/pen/MWEzyag?editors=1111">栗子</a>~</p>
<p>通过这个例子我们可以看到，元素的背景色被设置为蓝色，背景色设置为<code>rgba(255,255,255,.6)</code> ,此时，透过透明边框可以看到元素的背景色。</p>
<h3 id="解决办法">解决办法</h3>
<p>通过添加 <code>background-clip</code> 来解决此类问题。</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
background-clip: padding-box;
</code></pre>
<blockquote>
<p>background-clip属性是用来设置背景裁剪区域的，该属性接受三个参数：content-box | padding-box | border-box | text，裁剪区域如下：</p>
<ol>
<li>content-box: content部分，背景被裁剪至内容区（content box）外沿。</li>
<li>padding-box: content + padding部分，背景延伸至内边距（padding）外沿。不会绘制到边框处。</li>
<li>border-box: content + padding + border部分，背景延伸至边框外沿（但是在边框下层）。</li>
<li>text: 裁剪为text前景色</li>
</ol>
</blockquote>
<p>具体用法可以参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip">background-clip</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mini-vue学习：reactivity 的核心流程]]></title>
        <id>https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/</id>
        <link href="https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/">
        </link>
        <updated>2021-12-29T12:38:48.000Z</updated>
        <summary type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
<!-- more -->
<h2 id="写在开始">写在开始</h2>
<p>在正式开始学习之前，我们先一起来了解一个思想：<code>TDD</code>。什么是 <code>TDD</code> 呢？我们先来看下它的概念：</p>
<pre><code>TDD是测试驱动开发（Test-Driven Development）的英文简称。
它是敏捷开发中的一项核心实践和技术，也是一种设计方法论。
TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。
TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于其他开发方法和过程。
</code></pre>
<p>简而言之，就是 <code>测试驱动开发</code>，在动手开发之前先写好测试用例，然后再进行开发。<br><br>
在接下来的学习过程中，<code>TDD</code> 的思想将贯穿始终。话不多说，让我们一起进入vue3的源码学习吧~</p>
<blockquote>
<p><strong>声明：</strong><br><br>
笔记中的内容来源于 <strong>崔大(wx: cuixr1314)</strong> 的 <a href="https://github.com/cuixiaorui/mini-vue">mini-vue</a> 教学，目前已经 <code>4k+</code>的⭐️了，欢迎大家踊跃star~<br><br>
热爱学习的小伙伴们，可以搜索 <code>催学社</code> 微信群，里面都是一群热爱学习的小伙伴，学习氛围一级棒！期待你的加入~<br><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab46bb312db444c8352d44cbe9f4c70~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></p>
</blockquote>
<h2 id="正文开始">正文开始</h2>
<p>我们知道，不论是在 <code>vue2</code> 中，还是在 <code>vue3</code> 中， <code>响应式数据</code> 一直都是vue的核心概念。这一节，我们也先从 <code>响应式数据</code> 开始说起。</p>
<h3 id="vue2-与-vue3-中对响应式数据处理的区别">vue2 与 vue3 中对响应式数据处理的区别</h3>
<p>熟悉 <code>vue2</code> 的小伙伴儿们都知道，在 <code>vue2</code> 中，数据的响应式是通过 <code>Object.defineProperty</code> 来实现的。针对对象，通过遍历对象的属性，来设置属性对应的 <code>getter</code> 以及 <code>setter</code> 方法，以达到 <code>依赖收集</code> 与 <code>触发依赖</code> 的目的；<br>
而针对数组，则是通过重写数组一系列更新元素的方法来实现对数组元素修改的劫持。<br><br>
但是通过这种方式来实现数据响应式，存在以下几个问题：</p>
<pre><code>1. 对象直接新添加新的属性，或者删除已有的属性, 界面不会自动更新；
2. 直接通过替换数组对应下标的元素，或者更新数组的length, 界面也不会自动更新；
3. 如果对象的属性较多，且嵌套层次较深时，需要深度遍历，循环量大，性能损耗较大。
</code></pre>
<p>针对以上几个问题，<code>vue3</code> 中使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 来代替 <code>Object.defineProperty</code>。<br><br>
针对 <code>问题1</code> 和 <code>问题3</code>，<code>Proxy</code> 代理了整个对象，并且提供了多达13种对对象属性的操作（如属性查找、赋值、枚举、函数调用等），在对象发生变化时，<code>Proxy</code> 都可以进行捕获，与 <code>Object.defineProperty</code> 不同，无需遍历所有属性；<br><br>
针对 <code>问题2</code>，<code>Proxy</code> 对数组的监听相较于 <code>Object.defineProperty</code> 性能更优。具体大家可以参考 <a href="https://cloud.tencent.com/developer/news/485729">这篇文章</a> 。<br></p>
<p>那在 <code>vue3</code> 中具体是如何通过 <code>Proxy</code> 的方式实现响应式的呢？</p>
<h3 id="reactivity-第一步reactive"><code>reactivity</code> 第一步：reactive</h3>
<blockquote>
<p><strong>注：</strong> <br><br>
本文以 vue3 中的 <code>reactive</code> 为例，如果对 <code>reactive</code> 操作尚不熟悉的同学可以看下 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html">这篇文档</a>。至于 <code>ref</code>，其底层也是 <code>reactive</code>, 关于 <code>ref</code> 的内容，在完成 <code>reactive</code> 所有相关功能的梳理后，后续的文章中会做补充，这里先埋个伏笔~（手动🌺🐔）</p>
</blockquote>
<p>还记得开篇时提到的 <code>TDD</code> 么？开始之前，我们先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/reactive.spec.ts

import { reactive } from '../reactive'

describe('reactive', () =&gt; {
  it ('happy path', () =&gt; {
    const original = { foo: 1 }
    // 创建Proxy代理对象
    const observeOriginal = reactive(original)
    // 响应式对象与原对象应该不相等，因为observeOriginal被Proxy包裹
    expect(observeOriginal).not.toBe(original)
    // 取值
    expect(observeOriginal.foo).toBe(1)
  })
})
</code></pre>
<p>测试用例中， <code>reactive</code> 将传入的对象转换成 <code>Proxy</code> 代理对象，之后通过代理对象来获取其中的值。既然如此，那我们就从 <code>reactive</code> 入手。先来看下 <code>reactive</code> 的定义：</p>
<pre><code class="language-ts">// src/reactivity/reactive.ts

import { mutableHandlers } from './baseHandlers'

export const reactiveMap = new WeakMap()

/**
 * 创建reactive对象
 * @param target
 */
export function reactive (target) {
  return createReactiveObject(target, reactiveMap, mutableHandlers)
}

/**
 * 创建响应式对象
 * @param target
 * @param proxyMap
 * @param baseHandlers
 */
export function createReactiveObject (target, proxyMap, baseHandlers) {
  // 判断proxy是否已经保存过
  if (proxyMap.has(target)) {
    // 如果存在，则返回
    return proxyMap.get(target)
  }

  const proxy = new Proxy(target, baseHandlers)

  // 存储创建好的proxy
  proxyMap.set(target, proxy)
  return proxy
}
</code></pre>
<p>从上述代码可以看出，<code>reactive</code> 中调用了 <code>createReactiveObject</code> 方法，既然 <code>reactive</code> 方法是用来返回 <code>Proxy</code> 对象的，那在 <code>createReactiveObject</code> 中又发生了什么呢？我们一起来分析一下：</p>
<ol>
<li><code>createReactiveObject</code> 接收三个参数：需要被代理的对象 <code>target</code>, 也就是在 <code>reactive</code> 接收的 <code>target</code> 参数、用于存储 <code>Proxy</code> 对象的 <code>proxyMap</code> 以及 <code>Proxy</code> 对象的处理器 <code>baseHandlers</code>;</li>
<li>先判断在 <code>proxyMap</code> 是否已经存在当前对象所对应的 <code>Proxy</code> 对象，如果存在，则直接返回, 否则新建一个 <code>Proxy</code> 对象，并以当前的 <code>target</code> 为key，存储到 <code>proxyMap</code>，以便下次取用，并将新建的 <code>Proxy</code> 返回。</li>
</ol>
<p>诶，写到这里，细心的小伙伴儿们就会问了，那 <code>baseHandlers</code> 这个处理器具体又干了啥嘞？别急别急，我们现在就一起来看一看。</p>
<p>这里的 <code>baseHandlers</code> 实际上是从 <code>reactive</code> 中传过来的 <code>mutableHandlers</code>, 我们来一起看下它的定义：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

const get = createGetter()
const set = createSetter()

export const mutableHandlers = {
  get,
  set
}

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)
    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    return res
  }
}
</code></pre>
<p>从上述代码中不难看出，实际上 <code>mutableHandlers</code> 就是定义了 <code>Proxy</code> 对象的 <code>get</code> 和 <code>set</code> 方法。</p>
<p>回到测试用例中的 <code>expect(observeOriginal.foo).toBe(1)</code> 这个步骤，在获取代理对象的foo属性时，便会触发 <code>get</code> 方法，从而返回属性对应的值。同样，当设置代理对象的foo属性时，便会触发 <code>set</code> 方法，对属性的值做出改变。</p>
<p>写到这里，我们通过一张流程图，来捋一捋 <code>reactive</code> 的流程：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b014fadb17d641048dcd12f01695afaf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>扩展阅读：关于 <code>Proxy</code> 中为啥要用到 <code>Reflect</code>，有兴趣的小伙伴可以参考下 <code>张鑫旭</code> 大佬的这篇文章：<a href="https://www.zhangxinxu.com/wordpress/2021/07/js-proxy-reflect/">Proxy是代理，Reflect是干嘛用的？</a></p>
</blockquote>
<p><strong>综上：<code>reactive</code> 通过 <code>createReactiveObject</code> 方法，返回 <code>target</code> 所对应的 <code>proxy</code> 对象，并对 <code>target</code> 中属性的读取与写入操作做了拦截处理。</strong></p>
<h3 id="reactivity-第二步依赖收集-触发依赖"><code>reactivity</code> 第二步：依赖收集 &amp;&amp; 触发依赖</h3>
<p>现在我们已经知道了如何通过 <code>Proxy</code> 拦截对象的属性操作, 接下来我们一起看下如何实现 <code>依赖收集</code> 与 <code>依赖触发</code>。</p>
<p>老规矩，我们还是先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/effect.spec.ts

import { reactive } from '../reactive'
import { effect } from  '../effect'

describe('effect', () =&gt; {
  it ('should observe basic properties', () =&gt; {
    let dummy = 0
    // 获取proxy对象
    const data = reactive({ num: 0 })
    // ？
    effect(() =&gt; { dummy = data.num })
    expect(dummy).toBe(0)
    // 改变值
    data.num = 1
    expect(dummy).toBe(1)
  })
})
</code></pre>
<p>测试用例中，在调用了 <code>reactive</code> 方法获取到 <code>Proxy</code> 对象后，又调用了 <code>effect</code> 方法。那这个 <code>effect</code> 方法又是干啥的呢？我们先来看下 <code>effect</code> 方法的定义：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * @param fn
 */
export function effect(fn) {
  const reactiveEffect = new ReactiveEffect(fn)
  reactiveEffect.run()
}
</code></pre>
<p>可以看到，<code>effect</code> 接受一个函数作为参数，并且在其内部实例化了一个名为 <code>ReactiveEffect</code> 的类，并将接收到的函数传入这个类中，然后执行 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法。那这个 <code>ReactiveEffect</code> 类又是何方神圣呢？执行 <code>run</code> 又做了什么事情呢？让我们来一探究竟:</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

let activeEffect = void 0

export class ReactiveEffect {
  // 存放所有依赖
  public deps: any = new Set()

  // 初始化依赖列表
  constructor(fn) {
    if (fn) this.deps.add(fn)
  }

  // 执行收集到的所有依赖
  run () {
    activeEffect = this as any
    this.deps.forEach(dep =&gt; dep())
  }
}
</code></pre>
<p>通过上面的代码我们可以得知，<code>ReactiveEffect</code> 类在被实例化时，将接收到的函数存储到自己的 <code>deps</code> 属性中，并且在执行它的 <code>run</code> 方法时，则是遍历自身的 <code>deps</code> 属性，执行其中存储的函数。</p>
<p>由此可知，<strong>借助 <code>ReactiveEffect</code> 类所提供的能力，我们可以将方法保存起来，也可以触发已经被保存起来的方法。</strong></p>
<blockquote>
<p><strong>提问：</strong> 在调用 <code>run</code> 方法时，为什么还要将 <code>this</code> 赋值给全局变量 <code>activeEffect</code> 呢？</p>
</blockquote>
<p>带着这个问题，我们接着往下看。现在，我们已经拥有了 <code>收集方法</code> 以及 <code>触发被保存方法</code> 的能力。那我们又该如何将收集到的方法绑定到对应的对象及其属性上去呢？</p>
<p>我们一起来看下具体的实现：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

const targetMap = new WeakMap()

/**
 * 依赖收集
 * @param target
 * @param type
 * @param key
 */
export function track(target, type, key) {
  // 判断targetMap中是否保存有target对象对应的map
  let depsMap = targetMap.get(target)
  
  // 如果没有，则给该对象新建一个空的map，并绑定到targetMap中
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  
  // 取出target对应的map中，target属性key所对应的依赖
  let dep = depsMap.get(key)
  
  // 如果依赖不存在，则给当前的key创建一个空的依赖集合，并保存到target对象对应的map中
  if (!dep) {
    dep = new Set()
    depsMap.set(key, dep)
  }
  
  // 添加依赖
  dep.add(activeEffect)
}
</code></pre>
<p><code>track</code> 接收三个参数，需要进行 <code>依赖收集</code> 的对象 <code>target</code> 、收集类型 <code>type</code> 以及绑定依赖的 <code>key</code>。具体流程如注释。</p>
<p><strong>注意最后一步中的 <code>添加依赖</code> 操作。</strong> 在这一步骤中，将先前保存有 <code>ReactiveEffect</code> 类的 <code>this</code> 的全局变量添加到了 <code>target</code> 对应属性的依赖中。</p>
<blockquote>
<p><strong>解答：</strong> 回到刚才的提问，之所以要将 <code>ReactiveEffect</code> 的 <code>this</code> 赋值给全局变量，就是在进行 <code>依赖收集</code> 的时候可以将其添加到对应属性的依赖中去。所以 <code>收集依赖</code> 其实就是收集的 <code>ReactiveEffect</code> 的实例。</p>
</blockquote>
<p>现在，我们已经可以成功收集到依赖了，那我们又该如何 <code>触发依赖</code> 呢？</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * 触发依赖
 * @param target
 * @param key
 */
export function trigger(target, key) {
  const depsMap = targetMap.get(target)
  const dep = depsMap.get(key)

  // 遍历执行依赖
  for(const effect of dep) {
    effect.run()
  }
}
</code></pre>
<p>其实依赖的触发很简单，只需要将 <code>key</code> 中保存的 <code>ReactiveEffect</code> 实例都取出来，然后执行它们的 <code>run</code> 方法即可。</p>
<p>现在，我们已经完成了依赖的收集与触发功能，那我们又该在何时 <code>收集</code>，又在何时 <code>触发</code> 呢？</p>
<p>答案是：<strong>在使用时 <code>收集</code>，在改变时 <code>触发</code>。</strong></p>
<p>回到刚才的测试用例中的 <code>effect(() =&gt; { dummy = data.num })</code> 这一步，在调用了 <code>effect</code> 方法后，会通过 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法执行传入的函数，函数中读取了代理对象上的 <code>num</code> 属性，因此会触发 <code>get</code> 方法，在 <code>get</code> 方法中，我们需要进行 <code>依赖收集</code> 的操作；之后通过 <code>data.num = 1</code> 这一步骤，设置 <code>num</code> 属性的值，继而会触发 <code>set</code> 方法，在 <code>set</code> 方法中，我们需要进行 <code>依赖触发</code> 的操作。</p>
<p>综上所述，我们只需要在 <code>get</code> 中加入 <code>track</code> 方法，在 <code>set</code> 中加入 <code>trigger</code> 方法即可：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

// ...省略部分代码

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)

    // 触发依赖收集
    track(target, 'get', key)

    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return res
  }
}
</code></pre>
<p>最后，我们将 <code>依赖收集</code> 与 <code>依赖触发</code> 的流程补充到先前的流程图中去，来完成的看下响应式的流程吧：</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23ce7a3145b4e3f8580958b8a82297a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，我们已经完成了基本的响应式操作，也捋清了其中的基本原理。如果有描述不当之处，还请各位大佬帮忙指正~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Gridea + Valine搭建属于自己的博客]]></title>
        <id>https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/</id>
        <link href="https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/">
        </link>
        <updated>2021-12-24T17:15:10.000Z</updated>
        <summary type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
<!-- more -->
<h1 id="通过gridea快速搭建博客">通过Gridea快速搭建博客</h1>
<pre><code>Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。
</code></pre>
<p>以上是 <a href="https://gridea.dev/">Gridea</a> 官方对这款博客客户端的描述。它到底有多容易呢？那我们就自己动手来试下吧~</p>
<h2 id="简单两步完成博客搭建">简单两步，完成博客搭建</h2>
<h3 id="第一步下载gridea客户端">第一步：下载Gridea客户端</h3>
<p><code>Gridea</code> 客户端是使用 <code>Electron</code> 开发的，使用它之前，需要先去 <a href="https://gridea.dev/#started">官网下载</a>。官方提供了 <code>MacOS</code>, <code>Windows</code> 以及 <code>Linux</code> 三端的安装包，小伙伴们可以根据自己的需求自行下载~<br>
<img src="https://luhaifeng666.github.io/post-images/1640367698849.jpg" alt="" loading="lazy"></p>
<h3 id="第二步发布">第二步：发布</h3>
<p>是的！你没有听错！下载完成后直接就可以进入发布流程了，是不是很快！<br>
<code>Gridea</code> 提供了将博客部署到 <code>GitHub Pages</code>、<code>Coding Pages</code> 和通过 <code>SFTP</code> 的方式上传到自己的服务器的功能。官方提供了非常详细的Github Pages发布流程，这里不做赘述，<a href="https://gridea.dev/gridea-start/">请戳进来看吧~</a></p>
<h2 id="一些可能需要注意的点">一些可能需要注意的点</h2>
<p>经过上面两步的操作，相信各个小伙伴已经拥有了属于自己的博客~可喜可贺！在这里，我列举几个我遇到的问题，希望可以提供给遇到相同问题的小伙伴一些帮助：</p>
<h4 id="问题1关于同步">问题1：关于同步</h4>
<ul>
<li>由于同步是将你的改动同步到 <code>GitHub Pages</code> 上的，由于现阶段国内访问Github会有长时间打不开页面，需要翻墙的情况，建议小伙伴们在长时间无法同步的情况下，尝试下翻墙同步，可能会稍好一些；</li>
<li>我当前使用的 <code>Gridea</code> 的版本是 <code>0.9.2</code>，存在这样一个问题，在检测远程连接时，提示我连接成功，但是同步却一直都失败，无论是否开启翻墙，均是如此。官方在 <a href="https://github.com/getgridea/gridea/issues/890">#890</a> 这个issue中提供了一个解决方案，并给出了修复后的包的下载地址，我下载后使用并不理想（不排除是我本地网络环境的原因），但依旧可以作为一个解决方案提供给小伙伴们尝试下~</li>
</ul>
<h4 id="问题2关于主题">问题2：关于主题</h4>
<p>目前我使用的是 <code>Simple</code> 主题，各方面使用情况都还不错，推荐大家使用这款。<br>
当然，官方也提供了其他的 <a href="https://gridea.dev/themes">多款主题</a> 供小伙伴们食用，大家可以根据自己的喜好自行选择。<br>
如果有精力有兴趣的小伙伴儿们也可以尝试自己 <a href="https://gridea.dev/theme/">开发一个主题</a> ，毕竟自己动手，丰衣足食嘛~<br>
至于我遇到的问题，是在我使用 <code>Notes</code> 这个主题的时候，发现在编辑完文章后，markdown中的代码区块内容在预览时表现正常，但是在同步到 <code>GitHub Pages</code> 之后，打开页面发现markdown中的代码区块没有正常渲染出来，大家在食用的时候需要留意下~</p>
<h1 id="添加vline评论">添加Vline评论</h1>
<p>现在已经有了自己的博客了，也有个地方可以记录自己的工作，学习，生活了，自然也不能少了让 <code>看官们</code> 留下自己足迹的地方~<br>
我使用的 <code>Simple</code> 主题默认提供了两种发布评论的平台：<br>
<img src="https://luhaifeng666.github.io/post-images/1640368636573.jpg" alt="" loading="lazy"><br>
这里我推荐使用 <a href="https://valine.js.org/">Valine</a>，想对于上述的两个而言，它更加友好。至于接入方式，官方也给出了相应的 <a href="https://kveln.cn/post/qE678A4ce/">参考文档</a>。这里我针对官方的文档做一些补充说明以及踩坑的经验分享。</p>
<h2 id="关于文档中的说明">关于文档中的说明</h2>
<p>在官方提供的文档中有这么一处说明：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369031378.png" alt="" loading="lazy"><br>
其中，<code>Valine.min.js</code> 的引入需要放在对应主题的 <code>post.ejs</code> 模板下。</p>
<h2 id="关于leancloud的配置">关于LeanCloud的配置</h2>
<h3 id="创建class">创建Class</h3>
<p>评论会调用 <code>LeanCloud</code> 提供的数据接口，其中有个接口是获取评论总数的：<code>https://xxxx/1.1/classes/Comment</code>。调用这个接口的前提，是需要在 <code>数据存储 &gt; 结构化数据</code> 下手动创建一个名为 <code>Comment</code> 的class，否则接口会报404，这个需要注意下：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369813288.png" alt="" loading="lazy"></p>
<h3 id="创建应用">创建应用</h3>
<p>创建应用时，可以选择创建区域:<br>
<img src="https://luhaifeng666.github.io/post-images/1640369444506.png" alt="" loading="lazy"><br>
我这里选择的是 <code>华东</code>。之所以选择华东，是因为在华北创建完应用后，在调用接口时调不通，这可能跟我所处的区域有关。所以小伙伴们在创建完成之后，可以去 <code>设置 &gt; 应用凭证</code> 中，访问下提供的 <code>REST API 服务器地址</code> ，看看是不是可以调通，可以的话就没有问题。如果不行的话，建议切换下区域重新创建一个应用：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369984692.png" alt="" loading="lazy"></p>
<h1 id="写在最后">写在最后</h1>
<p>以上是我在使用 <code>Gridea + Vline</code> 搭建自己博客的时候所遇到的问题，希望对看到这篇文章的小伙伴有所帮助。<br>
当前博客已部署，以后会陆续分享自己的学习笔记以及心得琐碎等等。感兴趣的小伙伴欢迎<a href="https://luhaifeng666.github.io/">戳~</a>。<br>
现在快动起手来，快速搭建一个属于自己的天地吧~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记一：一些基础知识]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-yi-yi-xie-ji-chu-zhi-shi/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-yi-yi-xie-ji-chu-zhi-shi/">
        </link>
        <updated>2021-12-24T08:44:20.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常开发过程中，相信大家都会使用到脚手架，比如 <code>vue-cli</code> 等等。诚然，脚手架可以让我们的日常开发更加便利，但是久而久之，逐渐依赖脚手架进行开发的我们，可能会对一些工具的使用逐渐生疏，比如 <code>webpack</code> 。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常开发过程中，相信大家都会使用到脚手架，比如 <code>vue-cli</code> 等等。诚然，脚手架可以让我们的日常开发更加便利，但是久而久之，逐渐依赖脚手架进行开发的我们，可能会对一些工具的使用逐渐生疏，比如 <code>webpack</code> 。</p>
<!-- more -->
<p>尤其在公司的技术栈日趋稳定之后，我们手动配置 <code>webpack</code> 的机会就越来越少，我就是如此...Orz。所以借此机会，我决定再重头学习一遍这个熟悉而又有点陌生的工具，并将笔记做一个梳理，希望对同样有此感触，或者想学习 <code>webpack</code> 的小伙伴们有所帮助~</p>
<p>此处主子镇楼~</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456b7108fbd64ed8b270b7287cb4b364~tplv-k3u1fbpfcp-watermark.awebp" alt="主子" loading="lazy"></figure>
<blockquote>
<p>本章节及后面的章节使用的webpack及webpack-cli的版本如下：<br><br>
<code>&quot;webpack&quot;: &quot;4.41.6&quot;</code> <br><br>
<code>&quot;webpack-cli&quot;: &quot;3.3.11&quot;</code></p>
</blockquote>
<p>在开始学习<code>webpack</code>之前，我们先来了解一下与之相关的一些基础知识。</p>
<h1 id="构建工具的概念">构建工具的概念</h1>
<p>通俗点来说，构建工具就是包含一系列小工具的大工具。<br><br>
我们来举个🌰：比如我们需要将less、sass等css预处理器写的代码编译成正常的css代码，则需要相应的编译工具；而需要将ES6+的代码转换为兼容性更高的ES5的代码，也需要相应的编译工具。而将诸如此类的小工具包含起来的大工具，就叫 <code>构建工具</code> (比如我们接下来要学习的 <code>webpack</code> 就是构建工具)。在构建工具中,我们可以处理所有的这些操作。</p>
<h1 id="静态模块打包器的概念">静态模块打包器的概念</h1>
<p>这个概念里主要分为两个小的概念，即 <code>静态模块</code> 与 <code>打包</code>。<br><br>
我们来看下如下代码：</p>
<pre><code class="language-js">// main.js
import $ from 'Jquery'
import './less/common.less'
</code></pre>
<p>我们在入口文件中引入了两个模块，webpack在打包的时候，会先生成对应的依赖关系，即在 <code>main.js</code> 中引入了 <code>Jquery</code> 以及<code>common.less</code> 两个模块：<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463c25df4e2e4c06a694a61c0b4cb717~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
其中 <code>main.js</code> , <code>Jquery</code> , <code>common.less</code> 称为 <code>（静态）模块</code>，也叫做 <code>chunk</code> ，含义就是代码块; 之后webpack会对chunk代码块进行处理，将less以及ES6语法做转换，转换成浏览器可识别的内容，这个过程叫做<code>打包</code>。打包完成后，输出的文件称之为 <code>bundle</code>。</p>
<h1 id="webpack的五个核心概念"><a href="https://www.webpackjs.com/concepts/">Webpack的五个核心概念</a></h1>
<ol>
<li>entry：指示webpack从哪个入口开始打包，分析并构建内部依赖图。</li>
<li>output：指示webpack打包之后的bundle文件生成到哪里去。</li>
<li>loader：webpack只能处理js内容，loader的作用就是将非js的内容（比如css/image）转换成webpack可以识别的内容。</li>
<li>plugins：相较于loader只能用作代码翻译，plugins可以做更多复杂强大的事情。</li>
<li>mode：主要分为development以及production模式。相较于生产模式，开发模式的配置会比较简单，具体的区别可以参照下表：<br>
| 环境 | 描述 | 特点 |<br>
| ------ | ------ | ------ |<br>
| development | 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>。<br>启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。  | 能本地调试 |<br>
| production | 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>。<br>启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>。 | 能优化生产环境的代码 |</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记二：Webpack初体验]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-er-webpack-chu-ti-yan/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-er-webpack-chu-ti-yan/">
        </link>
        <updated>2021-12-24T08:43:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>webpack的使用依托于nodejs，本文及之后的篇幅里，使用的node版本为：<code>10.17.0</code>。</p>
</blockquote>
<h1 id="初始化node项目">初始化node项目</h1>
<p>开始之前，切换到存放项目的路径，在本地目录下初始化一个node项目，本文是在 <code>webpack-study</code> 目录下。初始化的命令如下：</p>
<pre><code class="language-js">cd webpack-study
npm init
</code></pre>
<p>根据步骤设置下项目名称等一些基础信息，其他的步骤按照默认配置一路回车到底即可。创建完成后，在 <code>webpack-study</code> 目录下会生成最基本的package.json文件。</p>
<h1 id="创建代码目录">创建代码目录</h1>
<p>在 <code>webpack-study</code> 目录下创建 <code>src</code> 目录，用于存放源代码。并在src下创建index.js作为入口文件，这里先写一段简单的代码用作示例：</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y
console.log(add(1, 2))
</code></pre>
<h1 id="安装webpack">安装Webpack</h1>
<pre><code class="language-js">npm i webpack webpack-cli
</code></pre>
<p>这里除了用到 <code>webpack</code> ，我们也会用到 <code>webpack-cli</code>, 它是webpack的脚手架。</p>
<h1 id="创建webpack配置文件">创建Webpack配置文件</h1>
<p>想要使用webpack对资源进行打包，首先我们需要配置下webpack的配置文件。我们在项目根目录下创建 <code>webpack.config.js</code> 文件。上一篇中，我们提到webpack的5个基本概念，(如果印象不是很深的小伙伴可以回看：<a href="https://juejin.cn/post/6902441939560300558#heading-3">Webpack学习笔记一：一些基础知识</a>。)现在我们根据上一节中提到的5个基础概念来创建一个简单的webpack配置文件：</p>
<pre><code class="language-js">// 引入node的path模块
const { resolve } = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 文件输出配置
    output: {
    	// 输出的文件名称
        // 配置[name]则取的是入口文件的名称
    	filename: 'js/[name].js',
        // 输出的文件路径
        // 这里是指输出到根目录下的build目录下，如果对__dirname不是很了解的小伙伴可以去nodejs官网了解一下
        path: resolve(__dirname, 'build')
    },
    // 用于配置loader
    module: {},
    // 用于配置插件信息
    plugins: [],
    // 启用开发模式
    mode: 'development'
}
</code></pre>
<h1 id="添加打包命令">添加打包命令</h1>
<p>webpack的打包命令就是 <code>webpack</code>，我们可以在指令脚本中添加一些设置参数：</p>
<pre><code class="language-js">// 开发环境
webpack ./src/index.js -o ./build/index.js --mode=development
// 生产环境
webpack ./src/index.js -o ./build/index.js --mode=production
</code></pre>
<p>稍微解释下上面的脚本，上述脚本的含义是：webpack使用 <code>开发/生产</code> 模式( <code>mode</code> )，将 <code>./src/index.js</code> 打包输出( <code>-o</code> )到 <code>./build/index.js</code> 中。<br><br>
细心的小伙伴儿应该已经发现，上述两种指令的唯一区别在于 <code>mode</code> 的参数不同，一个是 <code>development</code>,代表开发环境; 另一个是 <code>production</code> ，代表生产环境。那两者有什么区别呢？<br><br>
我们先将两种指令配置到 <code>package.json</code> 的 <code>scripts</code> 中，方便我们后期可以直接使用 <code>npm</code> 或者 <code>yarn</code> 命令来执行它们。当然也可以直接将这两种指令复制到控制台中运行，但是显然这样就不是很方便了。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;webpack_study&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=development&quot;,
    &quot;build:prd&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=production&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;webpack&quot;: &quot;4.41.6&quot;,
    &quot;webpack-cli&quot;: &quot;3.3.11&quot;
  }
}
</code></pre>
<p>然后我们分别通过执行 <code>build:dev</code> 以及 <code>build:prd</code> 来看下打包后的区别。</p>
<blockquote>
<p>Tips: <br><br>
可能有小伙伴注意到了，在 <code>webpack.config.js</code> 文件中配置了 <code>mode: 'development'</code>，而在我们 <code>package.json</code> 的指令中也指定了 <code>--mode='development'</code>，那么两者究竟以谁为准呢？<br><br>
答案是以 <code>package.json</code> 中配置的为准。有兴趣的小伙伴可以去试试看~</p>
</blockquote>
<h2 id="builddev">build:dev</h2>
<pre><code class="language-js">npm run build:dev
</code></pre>
<p>运行这个指令后，我们在根目录的 <code>build/js</code> 路径下可以看到打包后生成的 <code>index.js</code> 文件。打开这个文件:</p>
<pre><code class="language-js">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = &quot;&quot;;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = &quot;./src/js/index.js&quot;);
/******/ })
/************************************************************************/
/******/ ({

/***/ &quot;./src/js/index.js&quot;:
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(&quot;const add = (x, y) =&gt; x + y;\n\nconsole.log(add(1, 2));\n\n\n//# sourceURL=webpack:///./src/js/index.js?&quot;);

/***/ })

/******/ });
</code></pre>
<p>滑动到最底部，我们可以看到之前写的代码被转换成了字符串形式写入到了 <code>eavl</code> 方法中，并且以 <code>源码路径</code> 为key，同时将之作为value，以对象的形式作为入参，传入打包生成的方法中。</p>
<h2 id="buildprd">build:prd</h2>
<p>我们再来看下通过运行 <code>build:prd</code> 打包生成的文件是什么样的呢：</p>
<pre><code class="language-js">npm run build:prd
</code></pre>
<p>运行完成后生成如下代码：</p>
<pre><code class="language-js">!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.t=function(e,t){if(1&amp;t&amp;&amp;(e=n(e)),8&amp;t)return e;if(4&amp;t&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;t&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return n.d(t,&quot;a&quot;,t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=&quot;&quot;,n(n.s=0)}([function(e,t){console.log(1+2)}]);
</code></pre>
<p>我们发现代码精简了许多，没有了注释，没有了空格折行，显然代码被压缩过了。由此可以得出结论：</p>
<blockquote>
<p>相较于development模式，production模式会对打包后的代码进行压缩。主要是因为production模式下启用了webpack的 <code>UglifyJsPlugin</code> 插件，这个插件的作用就是对代码进行压缩。</p>
</blockquote>
<h1 id="控制台输出信息">控制台输出信息</h1>
<p>打包完成后，让我们回过头来，再来一起看下控制台中显示的信息，并对这些信息做一个简单的了解。我们先来看下刚才打包完成后的控制台输出:</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f2ba8e9346040388a50d65a6c7b9d46~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>我们依次看下这些参数的含义：</p>
<blockquote>
<p>Hash: 打包之后生成的唯一ID，后续可用作文件名中的唯一表示，防止访问缓存；<br><br>
Version: webpack的版本；<br><br>
Time:  打包所耗的时间；<br><br>
Built at: 打包开始的时间; <br><br>
Asset：打包的资源；<br><br>
Size：文件大小；<br><br>
Chunks: 所属的chunk名称；<br><br>
Chunk Names：chunk名称；<br><br>
EntryPoint main: 入口文件名称；<br><br>
[....]:  参与打包的模块，也就是上一节中提到的静态模块。</p>
</blockquote>
<p>行文至此，我们已经实现了简单的webpack打包功能，并且对webpack的一些基本配置、打包命令以及不同模式下打包的区别做了一个简单的了解。与此同时，我们对控制台中输出信息的含义也了然于胸。<br><br>
在后面的章节中，我会依次介绍webpack的其他功能，借此可以帮助大家逐步熟悉webpack的配置，让小伙伴们在之后的开发过程中不会再对webpack的配置感到晦涩陌生。篇幅也许不会太长，但是希望对小伙伴们有所助益~</p>
]]></content>
    </entry>
</feed>