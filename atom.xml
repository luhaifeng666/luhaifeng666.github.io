<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luhaifeng666.github.io</id>
    <title>酱豆腐精的小站</title>
    <updated>2022-04-13T08:24:25.519Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luhaifeng666.github.io"/>
    <link rel="self" href="https://luhaifeng666.github.io/atom.xml"/>
    <subtitle>我吹，你听</subtitle>
    <logo>https://luhaifeng666.github.io/images/avatar.png</logo>
    <icon>https://luhaifeng666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 酱豆腐精的小站</rights>
    <entry>
        <title type="html"><![CDATA[Obsidian 链接收藏插件开发]]></title>
        <id>https://luhaifeng666.github.io/post/obsidian-lian-jie-shou-cang-cha-jian-kai-fa/</id>
        <link href="https://luhaifeng666.github.io/post/obsidian-lian-jie-shou-cang-cha-jian-kai-fa/">
        </link>
        <updated>2022-04-12T04:17:14.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在使用一款 Markdown 笔记应用: <a href="https://obsidian.md/">Obsidian</a>，加之先前做了一个可以快捷收藏/跳转地址的工具: <a href="https://www.npmjs.com/package/efficient-tools">efficient-tools</a>，于是这次打算撸个 Obsidian 的插件，借用 Obsidian 给这个小功能提供可视化界面操作的能力（赋。。。。能？）。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在使用一款 Markdown 笔记应用: <a href="https://obsidian.md/">Obsidian</a>，加之先前做了一个可以快捷收藏/跳转地址的工具: <a href="https://www.npmjs.com/package/efficient-tools">efficient-tools</a>，于是这次打算撸个 Obsidian 的插件，借用 Obsidian 给这个小功能提供可视化界面操作的能力（赋。。。。能？）。</p>
<!-- more -->
<h1 id="开始">开始</h1>
<p>在 <strong>efficient-tools</strong> 中，我们可以通过命令行的方式添加、删除以及查看并跳转链接，既然如此，那在这个插件中也需要实现这三种功能。</p>
<h2 id="准备工作">准备工作</h2>
<p>在开始开发之前，先要做如下准备工作：</p>
<blockquote>
<ol>
<li>去 <a href="https://obsidian.md/">Obsidian 官网</a> 下载 Obsidian 应用；</li>
<li>参照 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/getting-started/create-your-first-plugin.html#%E5%BC%80%E5%8F%91%E5%89%8D%E5%87%86%E5%A4%87">创建你的第一个插件</a> 这篇文档准备好开发环境，并将插件名称改为 <strong>obsidian-link-keeper</strong> ；</li>
<li>由于 Obsidian 的插件在开发过程中只能通过停用/启用插件的方式让最新的代码生效，为了避开这个繁琐的过程，我们可以使用 <a href="https://github.com/pjeby/hot-reload">Hot-Relod</a> 这个工具来让我们的插件可以热重载。</li>
</ol>
</blockquote>
<p>在做完上述准备工作后，我们可以得到如下目录结构:</p>
<pre><code>├── README.md
├── esbuild.config.mjs
├── main.ts // 入口文件
├── manifest.json // 插件的基本信息
├── modals.ts // 用于创建模态框
├── node_modules
├── package.json
├── pnpm-lock.yaml
├── styles.css // 样式文件
├── tsconfig.json
├── version-bump.mjs
└── versions.json
</code></pre>
<h2 id="设置filepath">设置filepath</h2>
<p>在 <strong>efficient-tools</strong> 中，新增的地址会默认保存到 <strong><code>${process.env.HOME}/etl.json</code></strong> 文件中，在 Obsidian 中，我们可以通过给插件添加配置的方式来设置保存地址的文件路径。</p>
<p>Obsidian 中提供了 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Setting.html#setting">Setting</a> 类以创建诸如文本框，下拉框，滑动条，按钮等表单控件，以及 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/PluginSettingTab.html#pluginsettingtab">PluginSettingTab</a> 类可以创建插件的配置 tab。</p>
<p>接下来，我们先在项目的根目录下创建 <code>settings.ts</code> 文件，用于自定义插件的设置：</p>
<pre><code class="language-ts">// settings.ts

// 导入插件
import LinkKeeper from './main'

import { App, PluginSettingTab, Setting } from 'obsidian'

// 创建插件的自定义配置
export class LinkKeeperSettingTab extends PluginSettingTab {
  plugin: LinkKeeper
  
  /**
  * 构造函数中接受两个参数
  * app: Obsidian 中的App对象
  * plugin: 需要自定义设置的插件对象
  */
  constructor (app: App, plugin: LinkKeeper) {
    super (app, plugin)
    this.plugin = plugin
  }

  display(): void {
    // containerEl 是插件设置面板的容器
    const { containerEl } = this
    // 清空面板
    containerEl.empty()
    // 添加控件到面板容器中
    new Setting(containerEl)
      .setName(&quot;Link Filepath&quot;) // 设置控件名称
      .setDesc(&quot;The file where saves the links.&quot;) // 设置控件描述文案
      .addText((text) =&gt; // addText 方法用于创建 input 文本框, 回调函数中的参数为文本框dom对象
        text
          .setPlaceholder(&quot;Enter the full filepath&quot;) // 设置文本框 placeholder
          .setValue(this.plugin.settings.filepath) // 设置文本框内容
          .onChange(async (value) =&gt; { // 监听文本框的 change 事件
            this.plugin.settings.filepath = value
            await this.plugin.saveSettings() // 保存设置
          })
      )
  }
}
</code></pre>
<p>在自定义设置时需要引入自定义插件，以便将设置绑定到对应插件上。打开插件的入口文件 <code>main.ts</code> ，由于拉取的插件模板中存在其他示例内容，我们先“清理”一下 <code>main.ts</code> 文件，只保留我们需要的内容：</p>
<pre><code class="language-ts">// main.ts

// 引入 Plugin 类
import { Plugin } from &quot;obsidian&quot;

// 创建自定义插件
export default class InsertLinkPlugin extends Plugin {
  async onload() {
     // onload 方法在插件被启用时调用
  }
}
</code></pre>
<blockquote>
<p>💡 <strong>注：</strong></p>
<p>在 Obsidian 中，自定义插件的类继承自插件基类 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Plugin_2.html#plugin-2">Plugin</a>。插件存在两个生命周期函数：<strong>onload</strong> 以及 <strong>onunload</strong>，分别在组件启用时以及禁用时调用，具体可以参考<a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/concepts/plugin-anatomy.html#%E6%8F%92%E4%BB%B6%E5%89%96%E6%9E%90">插件剖析</a>。</p>
</blockquote>
<p>&quot;清理&quot;完成后，我们需要在 <code>main.ts</code> 中引入插件设置，并在 <strong>onload</strong> 阶段将自定义设置注册到插件上：</p>
<pre><code class="language-ts">// main.ts

import { Plugin } from &quot;obsidian&quot;
// 引入自定义设置
import { LinkKeeperSettingTab } from './settings'

// 定义自定义设置的类型
interface LinkKeeperSettings {
  filepath: string
}
// 定义自定义设置的默认值
const DEFAULT_SETTINGS: Partial&lt;LinkKeeperSettings&gt; = {
  filepath: `${process.env.HOME}/etl.json`
}

export default class LinkKeeperPlugin extends Plugin {
  settings: LinkKeeperSettings
  
  async onload() {
    // 加载自定义设置
    await this.loadSettings()
    // 将插件的配置 tab 添加到设置菜单中
    this.addSettingTab(new LinkKeeperSettingTab(this.app, this))
  }
  
  async loadSettings () {
    // 如果修改了配置项，可以覆盖默认配置
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...await this.loadData()
    }
  }
  
  // 用于保存设置，暴露给自定义设置类中使用
  async saveSettings () {
    await this.saveData(this.settings)
  }
}
</code></pre>
<p>做完上述步骤后，执行 <strong>pnpm run dev</strong>，之后打开设置界面，启用自定义插件，即可在设置中看到插件的自定义配置了：</p>
<p align="center">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eba8575a67d4c1f9eea944ea70e49e4~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<p>到这里，我们已经完成了第一步，接下来我们就可以开始着手实现我们的功能了~</p>
<h2 id="添加链接">添加链接</h2>
<p>要想添加链接，我们需要一个添加链接的界面。我们来设想下这个界面里需要实现哪些功能：</p>
<blockquote>
<ol>
<li>首先我们需要添加两个输入框用于设置链接的名称以及地址；</li>
<li>之后再添加一个按钮，点击后对输入的内容进行校验并保存；</li>
<li>如果遇到异常场景，比如文件不存在，输入内容为空等情况，我们需要给出友好的弹窗提示。</li>
</ol>
</blockquote>
<p>好，功能已经明确了，那我们就来逐步实现它们，冲冲冲！</p>
<h3 id="第一步添加链接的界面">第一步：添加链接的界面</h3>
<p>上文中提到的 <strong>界面</strong>，我们可以使用 Obsidian 提供的 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Modal.html#modal">Modal</a> 来实现。<strong>Modal</strong> 用于创建一个模态框，在模态框中，我们可以通过 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Setting.html#setting">Setting</a> 以及 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/guides/html-elements.html#html-elements">createEl</a> 的方式来自定义所需要显示的表单控件或者自定义元素内容。</p>
<p>首先，我们在项目根目录下新建 <code>modals.ts</code> 文件，用于创建模态框：</p>
<pre><code class="language-ts">// modal.ts

import { App, Modal } from &quot;obsidian&quot;

// 创建添加地址的模态框
export class AddLink extends Modal {
  linkName: string // 用于保存链接名称
  linkUrl: string // 用于保存链接地址

  constructor(
    app: App
  ) {
    super(app)
  }
  // 在模态框打开时调用
  onOpen (): void {
  }
  // 在模态框关闭时调用
  onClose(): void {
    // 需要清空模态框的内容
    this.contentEl.empty()
  }
}
</code></pre>
<h3 id="第二步添加名称-地址输入框">第二步：添加名称 &amp;&amp; 地址输入框</h3>
<p>通过 Obsidian 提供的 <strong>Setting</strong> 类，我们可以很方便的创建两个用于输入的文本框。创建文本框需要用到 <strong>Setting</strong> 中的 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Setting.html#addtext">addText</a> 方法。</p>
<p>在 <code>onOpen</code> 方法中，我们插入以下代码</p>
<pre><code class="language-ts">// modal.ts

onOpen (): void {
  // contentEl 是模态框的 Element 对象
  const { contentEl } = this
  // 设置模态框标题
  contentEl.createEl(&quot;h1&quot;, { text: &quot;Add Link&quot;, cls: &quot;title&quot; })
  // 创建用于设置地址名称的 input 框
  new Setting(contentEl).setName(&quot;Link name&quot;).addText(text =&gt; 
    text.setValue(this.linkName).setPlaceholder('name').onChange((value) =&gt; {
      this.linkName = value
    })
  )
  // 创建用于设置地址 url 的 input 框
  new Setting(contentEl).setName(&quot;Link url&quot;).addText(text =&gt;
    text.setValue(this.linkUrl).setPlaceholder('url').onChange((value) =&gt; {
      this.linkUrl = value
    })
  )
}
</code></pre>
<blockquote>
<p>💡 <strong>注：</strong></p>
<p><strong>createEl</strong> 方法用于自定义 Html 标签，其中 <code>cls</code> 用于设置标签的 <code>class</code> 属性，可以用于设置标签样式。样式统一设置在项目根目录的 <code>style.css</code> 文件中。</p>
</blockquote>
<h3 id="第三步添加保存按钮">第三步：添加保存按钮</h3>
<p>添加按钮需要用到 <strong>Setting</strong> 中的 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Setting.html#addbutton">addButton</a> 方法。</p>
<p>在 <code>onOpen</code> 方法中继续添加以下内容：</p>
<pre><code class="language-ts">// modal.ts

onOpen (): void {
  // 省略上述代码
  
  // 创建一个按钮
  new Setting(contentEl).addButton((btn) =&gt;
    btn
      .setButtonText('Add') // 设置按钮文案
      .setCta()
      .onClick(() =&gt; {
        // 按钮的点击事件
      })
  )
}
</code></pre>
<h3 id="第四步实现校验-保存功能">第四步：实现校验 &amp;&amp; 保存功能</h3>
<p>接下来，在点击按钮时，我们需要对文本框中的内容进行校验，并给出提示。在这里我们仅校验文本框中是否输入内容，如果文本框中的内容为空，则给出 popup 提示，否则就保存输入的内容。</p>
<p>Obsidian 中提供了 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Notice.html#notice">Notice</a> 类用于生成提示。由于提示的 popup 可能会在多出使用到，这里我们将其抽取到单独的 <code>utils.ts</code> 文件中：</p>
<pre><code class="language-ts">// utils.ts

import { Notice } from 'obsidian'

export const noticeHandler = (msg: string) =&gt; new Notice(msg) 
</code></pre>
<p>之后，我们在 <code>modals.ts</code> 文件中引入，并添加到检验判断中去：</p>
<pre><code class="language-ts">// modal.ts

import { noticeHandler } from './utils'

// 省略一大波代码

onOpen (): void {
  
  // 省略一小波代码
  
  new Setting(contentEl).addButton((btn) =&gt;
    btn
      .setButtonText('Add') // 设置按钮文案
      .setCta()
      .onClick(() =&gt; {
        // 在上述 input 的 onChange 事件中已经保存了 linkName 以及 linkUrl
        // 在这里我们可以直接获取进行校验
        const { linkName, linkUrl } = this
        if (!(linkName.trim())) {
          noticeHandler('Link name is required!')
        } else if (!(linkUrl.trim())) {
          noticeHandler('Link url is required!')
        }
      })
  )
}
</code></pre>
<p>通过校验后，我们需要对填入的值进行保存，所谓的保存其实就是将值写入文件中。为了保证模态框模块的纯净，我们将保存的逻辑放在 <code>main.ts</code> 中完成。所以，在 <code>main.ts</code> 中调用这个 <strong>Modal</strong> 的时候，需要传入一个回调函数，用于保存链接设置。同时，在 <code>main.ts</code> 中需要通过 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Plugin_2.html#addcommand">addCommand</a> 方法创建自定义指令，用于呼起模态框。</p>
<p>打开 <code>main.ts</code>，添加保存地址配置的方法，并且在 <code>onload</code> 方法中创建自定义指令的逻辑：</p>
<pre><code class="language-ts">// main.ts

import { Plugin, Editor } from &quot;obsidian&quot;
import { AddLink } from &quot;./modals&quot;
import { LinkKeeperSettingTab } from './settings'
import { readFile, writeFile } from 'fs/promises'
import { noticeHandler } from './utils'
interface LinkKeeperSettings {
  filepath: string
}

interface Options {
  [key: string]: string
}

const DEFAULT_SETTINGS: Partial&lt;LinkKeeperSettings&gt; = {
  filepath: `${process.env.HOME}/etl.json`
}

export default class LinkKeeperPlugin extends Plugin {
  settings: LinkKeeperSettings

  /**
   * get all links
   * @param cb 
   */
  async getLinks (cb: (data: Options) =&gt; void) {
    try {
      const data = await readFile(this.settings.filepath, { encoding: 'utf-8'})
      cb(JSON.parse(data || '{}'))
    } catch (err) {
      noticeHandler(err.message)
    }
  }
  
  /**
   * save link
   * @param data 
   * @param message 
   */
  async saveLink (data: Options, message: string) {
    try {
      await writeFile(this.settings.filepath, JSON.stringify(data))
      noticeHandler(message)
    } catch (err) {
      noticeHandler(err.message)
    }
  }

  /**
   * add link submission
   * @param name 
   * @param url 
   */
  onSubmit (name: string, url: string) {
    this.getLinks(async (data: Options) =&gt; {
      if (Object.prototype.toString.call(data) === '[object Object]') {
        this.saveLink({...data, [name]: url}, 'Add Link successfully!')
      } else {
        noticeHandler('Data format error! It must be a json object.')
      }
    })
  }

  /**
   * init modal
   * @param type 
   * @param options 
   * @returns 
   */
  initModal (type: string) {
    switch (type) {
      case 'addLink':
        return new AddLink(this.app, this.onSubmit.bind(this))

      default: break
    }
  }

  async onload() {
    // 添加呼起模态框的逻辑
    this.addCommand({
      id: &quot;add-link&quot;, // 用于设置模态框 id
      name: &quot;Add link&quot;, // 用于设置模态框名称
      callback: () =&gt; { // 执行命令的回调函数
        // 打开模态框
        this.initModal('addLink').open()
      }
    })
  }
}
</code></pre>
<p>这里我们添加了 <code>onSubmit</code> 方法，提供给模态框使用，用于保存地址设置。回到 <code>modal.ts</code> 文件中，我们需要在按钮的回调事件中加入保存地址的方法：</p>
<pre><code class="language-ts">// modal.ts

export class AddLink extends Modal {
  linkName: string
  linkUrl: string

  onSubmit: (linkName: string, linkUrl: string) =&gt; void

  constructor(
    app: App,
    onSubmit: (linkName: string, linkUrl: string) =&gt; void
  ) {
    // 省略一小波代码
    
    // 绑定传过来的 onSubmit 方法
    this.onSubmit = onSubmit
  }

  onOpen (): void {
    // 省略一小波代码
    new Setting(contentEl).addButton((btn) =&gt;
      btn
        .setButtonText('Add')
        .setCta()
        .onClick(() =&gt; {
          const { linkName, linkUrl } = this
          if (!(linkName.trim())) {
            noticeHandler('Link name is required!')
          } else if (!(linkUrl.trim())) {
            noticeHandler('Link url is required!')
          } else {
            this.close() // 添加完成后，需要关闭模态框
            this.onSubmit(this.linkName, this.linkUrl) // 调用传过来的 onSubmit 方法
          }
        })
    )
  }
  
  // 省略一小波代码
}
</code></pre>
<p>至此，我们的模态框功能已经完成了。还记得我们在 <code>modal.ts</code> 中添加的用于呼起模态框的自定义指令么？现在我们就来用它呼起添加地址的模态框。</p>
<p>点击 Obsidian 界面左侧的命令行图标，在弹出的界面中搜索 <code>Add link</code>（之前在 <code>addCommand</code> 中设置的自定义指令名称）:</p>
<p align="center">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b2b6e620c04e848558b48d37345d52~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<p>选择蓝框中的命令后，就会弹出添加地址的模态框了：</p>
<p align="center">
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3eb8f27f79c4410abae5afcac274eb3~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<p>直接点击添加按钮，也会在右上角看到提示信息。</p>
<h2 id="删除链接">删除链接</h2>
<p>老规矩，我们还是先来设想下用于删除的模态框需要实现哪些功能：</p>
<blockquote>
<ol>
<li>首先我们需要添加一个下拉框，用于选择需要删除的地址；</li>
<li>之后再添加一个按钮，点击后删除所选的地址；</li>
<li>如果遇到异常场景我们需要给出友好的弹窗提示。</li>
</ol>
</blockquote>
<p>有了添加链接的经验，创建删除链接的模态框就容易多了。在删除链接的模态框中，我们通过 <strong>Setting</strong> 中提供的 <a href="">addDropdown</a> 方法添加一个下拉框，用于选择需要删除的地址。此处直接上代码：</p>
<pre><code class="language-ts">export class DeleteLink extends Modal {
  linkName: string
  options: Options

  onDelete: (linkName: string) =&gt; void

  constructor (
    app: App,
    options: Options, // 用来接收下拉项
    onDelete: (linkName: string) =&gt; void // 删除事件
  ) {
    super(app)
    this.onDelete = onDelete
    this.options = options
    this.linkName = Object.keys(options)[0] || '' // 默认删除第一个
  }

  onOpen (): void {
    const { contentEl } = this

    contentEl.createEl(&quot;h1&quot;, { text: &quot;Delete Link&quot;, cls: &quot;title&quot; })
    
    // 创建下拉框
    new Setting(contentEl).setName(&quot;Link name&quot;).addDropdown(dp =&gt; 
      dp.addOptions(this.options).onChange(value =&gt; {
        this.linkName = value
      })
    )
    // 创建删除按钮
    new Setting(contentEl).addButton((btn) =&gt;
      btn
        .setButtonText('Delete')
        .setCta()
        .onClick(() =&gt; {
          const { linkName } = this
          if (!linkName) {
            noticeHandler('Link name is required!')
          } else {
            this.close()
            this.onDelete(this.linkName)
          }
        })
    )
  }

  onClose(): void {
    this.contentEl.empty()
  }
}
</code></pre>
<p>之后回到 <code>main.ts</code> 文件，我们需要加入 <strong>删除模态框的调出指令、获取删除下拉选项的 options 以及添加删除方法</strong>：</p>
<pre><code class="language-ts">// main.ts

import { Plugin, Editor } from &quot;obsidian&quot;
import { AddLink, DeleteLink } from &quot;./modals&quot;
import { LinkKeeperSettingTab } from './settings'
import { readFile, writeFile } from 'fs/promises'
import { noticeHandler } from './utils'
interface LinkKeeperSettings {
  filepath: string
}

interface Options {
  [key: string]: string
}

const DEFAULT_SETTINGS: Partial&lt;LinkKeeperSettings&gt; = {
  filepath: `${process.env.HOME}/etl.json`
}

export default class LinkKeeperPlugin extends Plugin {
  settings: LinkKeeperSettings

  /**
   * get all links
   * @param cb 
   */
  async getLinks (cb: (data: Options) =&gt; void) {
    try {
      const data = await readFile(this.settings.filepath, { encoding: 'utf-8'})
      cb(JSON.parse(data || '{}'))
    } catch (err) {
      noticeHandler(err.message)
    }
  }
  
  /**
   * delete link by name
   * @param name 
   */
  async onDelete (name: string) {
    await this.getLinks(async (data: Options) =&gt; {
      delete data[name]
      this.saveLink(data, `Link named ${name} has been deleted!`)
    })
  }

  /**
   * init modal
   * @param type 
   * @param options 
   * @returns 
   */
  initModal (type: string, options?: Options) {
    switch (type) {
      // 省略一小波代码
      
      // 创建删除地址的模态框
      case 'deleteLink':
        return new DeleteLink(this.app, options, this.onDelete.bind(this))

      default: break
    }
  }

  async onload() {
    // 省略一小波代码
    
    // 新增呼出删除模态框的自定义指令
    this.addCommand({
      id: &quot;delete-link&quot;,
      name: 'Delete link',
      callback: () =&gt; {
        this.getLinks(async (data: Options) =&gt; {
          // 创建删除的模态框，并传入 options
          this.initModal('deleteLink', Object.keys(data).reduce((obj, key) =&gt; ({
            ...obj,
            [key]: key
          }), {})).open()
        })
      }
    })
  }

  // 省略一小波代码
}
</code></pre>
<p>之后，点击 Obsidian 界面左侧的命令行图标，在弹出的界面中搜索 <code>Delete link</code> 并点击，就可以看到删除地址的模态弹框啦：</p>
<p align="center">
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92cb761ff8d143848c0d345c6437ef29~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<h2 id="查看-跳转链接">查看 &amp;&amp; 跳转链接</h2>
<p>在这个模态框中，我们需要提供以下几种功能：</p>
<blockquote>
<ol>
<li>提供一个可以按照地址名称进行筛选的搜索框；</li>
<li>列出已经保存的地址，显示对应的名称以及跳转地址，并且给地址加上链接，以便直接点击跳转</li>
</ol>
</blockquote>
<p>回到 <code>modals.ts</code> ，我们先创建用于罗列地址的模态框：</p>
<pre><code class="language-ts">// modal.ts

export class ListAllLinks extends Modal {
  options: Options

  constructor (
    app: App,
    options: Options // 用于接收地址配置
  ) {
    super(app)
    this.options = options
  }

  onOpen(): void {
    const { contentEl } = this
    // 创建标题
    contentEl.createEl(&quot;h1&quot;, { text: &quot;All Links&quot;, cls: &quot;title&quot; })
  }

  onClose(): void {
    this.contentEl.empty()
  }
}
</code></pre>
<h3 id="添加搜索框">添加搜索框</h3>
<p>这里要用到 <strong>Setting</strong> 中提供的 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/classes/Setting.html#addsearch">addSearch</a> 方法来创建一个搜索框：</p>
<pre><code class="language-ts">// modal.ts

// 省略一小波代码

onOpen(): void {
    const { contentEl } = this

    contentEl.createEl(&quot;h1&quot;, { text: &quot;All Links&quot;, cls: &quot;title&quot; })
    // 创建搜索框
    new Setting(contentEl).setName('Search').addSearch(el =&gt; {
      el.setPlaceholder('Input the link name...').onChange(val =&gt; {
        // 监听搜索框的 change 事件，在搜索框内容发生变化时重新渲染列表
      })
    })
}
</code></pre>
<h3 id="添加地址列表">添加地址列表</h3>
<p>在上述过程中一直有使用的 <strong>Setting</strong> 类主要是用来创建表单控件的，而列表内容主要由自定义标签构成，此时我们可以使用 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/guides/html-elements.html#create-html-elements-using-createel">createEl</a> 方法。由于在模态框初始化阶段以及搜索框内容变化阶段都需要渲染列表，因此我们需要将列表渲染的逻辑抽取出来。</p>
<pre><code class="language-ts">// modal.ts

export class ListAllLinks extends Modal {
  options: Options

  constructor (
    app: App,
    options: Options
  ) {
    super(app)
    this.options = options
  }
  
  /**
   * create list item
   * @param container list container
   * @param key link name
   * @param value link url
   * @param isLink determine whether it is a link
   */
  createListItem (container: Element, key: string, value: string, isLink = true) {
    // 向 list 容器中添加地址项
    const box = container.createEl(&quot;div&quot;, { cls: `list-item ${!isLink ? 'list-item-header' : ''}`})
    // 添加显示地址名称的容器
    box.createEl(&quot;div&quot;, { text: key })
    // 添加显示 url 的容器
    const linkBox = box.createEl(&quot;div&quot;)
    // 判断是否是链接
    if (isLink) {
      // 是链接的话添加 a 标签用于跳转
      linkBox.createEl('a', { text: value, href: value})
    } else {
      // 否则直接显示内容
      linkBox.createSpan({ text: value })
    }
  }
  
  // 渲染列表
  renderList (key = ''): Element {
    // 获取所有地址信息
    let options = this.options
    // 根据传过来的 key 筛选需要显示的地址内容
    if (key) {
      options = Object.keys(options).reduce((obj: Options, item) =&gt; {
        if (item.includes(key)) obj = { ...obj, [item]: options[item] }
        return obj
      }, {})
    }
    // 创建显示列表的内容容器
    const container = this.contentEl.createEl(&quot;div&quot;)
    // 添加表头信息
    this.createListItem(container, 'Name', 'Url', false)
    // 创建 list 容器
    const listContainer = container.createEl('div', { cls: 'list-container'})
    const keys = Object.keys(options)
    // 遍历显示列表
    if (keys.length) {
      keys.forEach(key =&gt; {
        this.createListItem(listContainer, key, options[key])
      })
    } else {
      // 当没有搜索到相应结果时，显示提示信息
      listContainer.createEl('div', { text: 'No results!', cls: 'list-empty' })
    }

    return container
  }

  onOpen(): void {
    const { contentEl } = this

    contentEl.createEl(&quot;h1&quot;, { text: &quot;All Links&quot;, cls: &quot;title&quot; })

    let contentBox: Element = null

    new Setting(contentEl).setName('Search').addSearch(el =&gt; {
      el.setPlaceholder('Input the link name...').onChange(val =&gt; {
        // 当搜索内容变化时，清空列表
        contentBox.empty()
        // 重新渲染列表
        contentBox = this.renderList(val)
      })
    })
    // 首次加载时渲染列表
    contentBox = this.renderList()
  }

  onClose(): void {
    this.contentEl.empty()
  }
}
</code></pre>
<p>之后，我们要将列表的样式写入 <code>style.css</code> 文件中：</p>
<pre><code class="language-css">// style.css
/* Sets all the text color to red! */
.title {
  text-align: center;
  font-size: 20px;
}

.list-container {
  max-height: 300px;
  overflow-y: scroll;
}

.list-item-header {
  font-size: 18px;
  font-weight: bold;
}

.list-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.list-item div {
  flex: 1;
}

.list-item:not(.list-item-header) div:first-child {
  color: #222;
  font-weight: bold;
}

.list-item div:last-child {
  text-align: right;
}

.list-item:not(.list-item-header) {
  background-color: #c0c0c0;
  padding: 8px;
  border-radius: 4px;
}

.list-empty {
  text-align: center;
  font-size: 16px;
}

</code></pre>
<p>最后，我们需要在 <code>main.ts</code> 文件中添加呼起显示列表的自定义指令，并将地址信息传给模态框：</p>
<pre><code class="language-ts">// main.ts

import { Plugin, Editor } from &quot;obsidian&quot;
import { AddLink, DeleteLink, ListAllLinks } from &quot;./modals&quot;
import { LinkKeeperSettingTab } from './settings'
import { readFile, writeFile } from 'fs/promises'
import { noticeHandler } from './utils'
interface LinkKeeperSettings {
  filepath: string
}

interface Options {
  [key: string]: string
}

const DEFAULT_SETTINGS: Partial&lt;LinkKeeperSettings&gt; = {
  filepath: `${process.env.HOME}/etl.json`
}

export default class LinkKeeperPlugin extends Plugin {
  settings: LinkKeeperSettings

  /**
   * get all links
   * @param cb 
   */
  async getLinks (cb: (data: Options) =&gt; void) {
    try {
      const data = await readFile(this.settings.filepath, { encoding: 'utf-8'})
      cb(JSON.parse(data || '{}'))
    } catch (err) {
      noticeHandler(err.message)
    }
  }
  
  // 省略一小波代码
  
  /**
   * init modal
   * @param type 
   * @param options 
   * @returns 
   */
  initModal (type: string, options?: Options) {
    switch (type) {
      // 省略一小波代码
      
      case 'listLink':
        return new ListAllLinks(this.app, options)

      default: break
    }
  }

  async onload() {
    // 省略一小波代码
    
    // 添加呼起显示地址列表模态框的指令
    this.addCommand({
      id: 'list-links',
      name: 'List links',
      icon: 'link',
      callback: () =&gt; {
        this.getLinks(async (data: Options) =&gt; {
          this.initModal('listLink', data).open()
        })
      }
    })
  }
  
  // 省略一小波代码
}
</code></pre>
<p>之后，点击 Obsidian 界面左侧的命令行图标，在弹出的界面中搜索 <code>List link</code> 并点击，就可以看到地址列表的模态弹框啦~在搜索框中输入内容，可以看到相应的搜索结果，如果没有符合搜索内容的地址信息，则会显示提示信息：</p>
<p align="center">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b112c98bf394ec1b3f6134f16af0f78~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<p>到这里，我们的插件就基本开发完成啦~~</p>
<h1 id="插件优化">插件优化</h1>
<h2 id="hotkeys">Hotkeys</h2>
<p>在上述过程中，我们都是通过自定义指令的方式来呼起模态框，虽然过程并不复杂，但多少还是有些繁琐。Obsidian 给插件的自定义指令提供了设置热键的功能，我们可以通过设置自定义指令的热键来简化这个过程：</p>
<p align="center">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67c6ab5528714e5790c21de10d93e417~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<h2 id="添加选中的地址">添加选中的地址</h2>
<p>如果在使用 Obsidian 的过程中，遇到想要保存文档中某个地址的情况，如果要先复制地址，然后再粘贴到模态框中去保存，感觉多少有些麻烦。那么我们是否可以选中想要添加的地址直接进行添加呢？</p>
<p>答案是肯定的！！</p>
<p>此时，我们可以在 <strong>addCommand</strong> 方法中的 <a href="https://luhaifeng666.github.io/obsidian-plugin-docs-zh/zh/api/interfaces/Command.html#editorcallback">editorCallback</a> 事件中获取到当前编辑器的 <code>editor</code> 对象，并借此获取到选中的地址，之后自动填入模态框中。美滋滋~</p>
<p>接下来，我们需要对先前添加的 <code>Add link</code> 自定义指令以及添加地址的模态框逻辑做些修改。</p>
<p>首先，我们需要将 <code>callback</code> 方法改为 <code>editorCallback</code> 方法，并将选中的内容传给模态框：</p>
<pre><code class="language-ts">// main.ts

// 省略一大波代码

initModal (type: string, options?: Options) {
  switch (type) {
    case 'addLink':
      return new AddLink(this.app, options.link, this.onSubmit.bind(this))
    // 省略一小波代码  
    default: break
  }
}

async onload() {
  // 省略一小波代码
  this.addCommand({
    id: &quot;add-link&quot;,
    name: &quot;Add link&quot;,
    editorCallback: (editor: Editor) =&gt; {
      // 获取选中的地址
      const selection = editor.getSelection()
      this.initModal('addLink', { link: selection }).open()
    }
  })
}
</code></pre>
<p>之后，我们需要修改添加地址的模态框代码，接受传入的地址，并将其作为默认值设置到链接地址的文本框中：</p>
<pre><code class="language-ts">// modals.ts

export class AddLink extends Modal {
  linkName: string
  linkUrl: string

  onSubmit: (linkName: string, linkUrl: string) =&gt; void

  constructor(
    app: App,
    linkUrl: string, // 接受传入的地址信息
    onSubmit: (linkName: string, linkUrl: string) =&gt; void
  ) {
    super(app)
    this.linkName = ''
    this.linkUrl = linkUrl // 将传入的地址信息设置为默认值
    this.onSubmit = onSubmit
  }
  
  // 省略一大波代码
}
</code></pre>
<p>改造完成后，此时我们选中想要添加的链接地址，然后通过 <strong>热键</strong> 的方式呼起模态框，即可看到地址已经被填入其中：</p>
<p align="center">
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4891cd74fd64787887104770ddd315a~tplv-k3u1fbpfcp-watermark.image?" />
</p>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，link-keeper 插件就已经完成啦~有兴趣的小伙伴可以<a href="https://github.com/luhaifeng666/obsidian-link-keeper">下载</a>使用。如果觉得插件还可的小伙伴们欢迎  star ~</p>
<p>另外，笔者最近在翻译 Obsidian 的<a href="https://github.com/luhaifeng666/obsidian-plugin-docs-zh">插件开发文档</a>，有兴趣的小伙伴可以加入我~ 由于本人水平有限，如果有翻译不到位之处也欢迎大佬们提 issue，以便我及时更正。</p>
<p align="center">
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b8c4600b4ca4e35bcebd0dd8bba4505~tplv-k3u1fbpfcp-watermark.image?" />
</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tauri 初体验 ]]></title>
        <id>https://luhaifeng666.github.io/post/tauri-chu-ti-yan/</id>
        <link href="https://luhaifeng666.github.io/post/tauri-chu-ti-yan/">
        </link>
        <updated>2022-02-16T14:13:50.000Z</updated>
        <summary type="html"><![CDATA[<p>提到桌面客户端开发，大家伙儿第一时间会想到的可能是元老级别的 <code>Electron</code>, 亦或者是去年微软新发布的<code>Webview2</code>。今天，我们来结识下一个后起之秀 -- <a href="https://tauri.studio/">Tauri</a>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>提到桌面客户端开发，大家伙儿第一时间会想到的可能是元老级别的 <code>Electron</code>, 亦或者是去年微软新发布的<code>Webview2</code>。今天，我们来结识下一个后起之秀 -- <a href="https://tauri.studio/">Tauri</a>。</p>
<!-- more -->
<p>截止目前，<a href="https://github.com/tauri-apps/tauri">Tauri</a> 的 star 数已经达到了 <code>31.4k+</code> 之多，既然它如此受欢迎，那我们就一起来体验一把，看看它到底有何过人之处。</p>
<p>话不多说，撸起袖子，开始</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68de4bc54a06486890513fe3255d3c77~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="什么是-tauri">什么是 Tauri</h1>
<h2 id="介绍">介绍</h2>
<p>Tauri 是一个用来帮助开发者们开发主流桌面平台应用的工具包 - 几乎可以使用任何一个现在已有的前端框架。它的核心是使用 <code>Rust</code> 进行构建，并且脚手架借助 <code>Node.js</code> 使 Tauri 成为一个真正意义上可以使用多语言开发与维护app的工具。</p>
<h2 id="优势">优势</h2>
<p>那 Tauri 与其他框架相比，有什么优势呢？在 Tauri 的 github 仓库中，官方给出了一个表格，将 Tauri 与 Electron 做了个对比，具体如下：</p>
<table>
<thead>
<tr>
<th>Detail</th>
<th>Tauri</th>
<th>Electron</th>
</tr>
</thead>
<tbody>
<tr>
<td>Installer Size Linux</td>
<td>3.1 MB</td>
<td>52.1 MB</td>
</tr>
<tr>
<td>Memory Consumption Linux</td>
<td>180 MB</td>
<td>462 MB</td>
</tr>
<tr>
<td>Launch Time Linux</td>
<td>0.39s</td>
<td>0.80s</td>
</tr>
<tr>
<td>Interface Service Provider</td>
<td>WRY</td>
<td>Chromium</td>
</tr>
<tr>
<td>Backend Binding</td>
<td>Rust</td>
<td>Node.js (ECMAScript)</td>
</tr>
<tr>
<td>Underlying Engine</td>
<td>Rust</td>
<td>V8 (C/C++)</td>
</tr>
<tr>
<td>FLOSS</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Multithreading</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Bytecode Delivery</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Multiple Windows</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Auto Updater</td>
<td>Yes</td>
<td>Yes1</td>
</tr>
<tr>
<td>Custom App Icon</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Windows Binary</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>MacOS Binary</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Linux Binary</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>iOS Binary</td>
<td>Soon</td>
<td>No</td>
</tr>
<tr>
<td>Android Binary</td>
<td>Soon</td>
<td>No</td>
</tr>
<tr>
<td>Desktop Tray</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Sidecar Binaries</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>总结一下：</p>
<blockquote>
<ol>
<li>相比于 Electron 的安装包大小，仅仅只有 3.1MB 的 Tauri 显然更小更轻便。因为 Tauri 放弃了庞大的 Chromium 内核，改用 <a href="https://github.com/tauri-apps/wry">WRY(Webview Rendering library)</a> (一种跨平台的 Webview 渲染器，支持主流的操作系统，例如 <strong>Windows, macOS, 以及 Linux。</strong>)，而且也放弃了 <code>Nodejs</code>，改用 <code>Rust</code>;</li>
<li>在内存占用以及启动速度上，Tauri 也更胜一筹；</li>
<li>除却 <strong>Windows, macOS, 以及 Linux</strong> 以外，Tauri 官方后续有计划支持 <code>Android</code> 以及 <code>iOS</code> 平台，这也是 Electron 所不具备的；</li>
<li>内部集成了多种模板（如下图所示），对于开发者也更加友好。使用 <code>vue-cli</code> 的小伙伴也可以直接安装官方提供的插件： <a href="https://github.com/tauri-apps/vue-cli-plugin-tauri">vue-cli-plugin-tauri</a>。</li>
</ol>
</blockquote>
<h1 id="tauri-初体验">Tauri 初体验</h1>
<blockquote>
<p><strong>注意：</strong> 笔者的环境搭建基于 <code>MacOS</code>, 想要了解在 <code>Windows</code> 或者 <code>Linux</code> 平台环境搭建的小伙伴们可以移步至<a href="https://tauri.studio/docs/getting-started/prerequisites">这里</a>。</p>
</blockquote>
<h2 id="tauri-环境配置">Tauri 环境配置</h2>
<h3 id="第一步安装-xcode">第一步：安装 Xcode</h3>
<p>你可以选择从 App Store 中下载，也可以选择运行如下命令：</p>
<pre><code>$ xcode-select --install
</code></pre>
<h3 id="第二步安装-node">第二步：安装 Node</h3>
<p>相信前端的小伙伴们都已经安装了。如果正在看这篇文章的你尚未安装 Nodejs，请移步至 <a href="http://nodejs.cn/">Nodejs官网</a> 下载。</p>
<h3 id="第三步安装-rust-编译器-rustup">第三步：安装 Rust 编译器 <a href="https://rustup.rs/">rustup</a></h3>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<blockquote>
<p><strong>注意：</strong> 如果有小伙伴在这一步骤卡壳，遇到了安装失败或者安装过于缓慢的问题，可以尝试科学上网（手动狗头）。</p>
</blockquote>
<p>安装完成后，可以通过如下命令验证是否安装成功：</p>
<pre><code>$ rustc --version
</code></pre>
<p>至此，我们的环境就已经准备好了，接下来我们就一起来开发一个简单的文档应用。</p>
<h2 id="tauri-vuepress-开发一个文档应用">Tauri + Vuepress 开发一个文档应用</h2>
<h3 id="背景">背景</h3>
<p>我们日常在查找文档的时候，一般会优先想到去对应的官网查看 Docs 文档。比如我们想去查看 Webpack 对应的文档时，操作流程一般就是：</p>
<blockquote>
<ol>
<li>打开浏览器</li>
<li>打开 Webpack 官方网站</li>
<li>点开文档地址</li>
<li>查看对应的文档</li>
</ol>
</blockquote>
<p>Webpack 官方也提供了一个本地的应用，方便小伙伴们直接在本地就可以查看相应的文档，节省一些繁琐的操作</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc980ab20f3c49ccafcabdcc04051bf6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>而我们要实现这个应用的功能就与之类似。</p>
<p>之前我一直在刷 Leetcode 的算法题，并把 <a href="https://github.com/luhaifeng666/arithmetic-practice">算法练习</a> 输出到了 Github 上，与此同时使用 <code>Vuepress</code> 创建了对应算法题的文档（如果可以的话，希望看到这里的大佬给个⭐️（捂脸奔逃~））。本文就使用 Tauri 将次该档打包成一个本地应用。</p>
<h3 id="开始开发">开始开发</h3>
<h4 id="步骤一创建-tauri-应用">步骤一：创建 Tauri 应用</h4>
<p><strong>第一步：</strong> 打开文档所在目录，并安装 Tauri 脚手架（本文是在已经存在的路径下创建 Tauri 应用，如果直接创建，可以通过 <code>yarn create tauri-app</code> 命令创建。详情可查阅 <a href="https://tauri.studio/docs/getting-started/beginning-tutorial">此文档</a>）：</p>
<pre><code>yarn add -D @tauri-apps/cli
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>该脚手架可以本地安装，也可以全局安装，官方推荐本地安装；</li>
<li>如果使用 npm 命令(而不是使用yarn命令)在本地安装了该脚手架，需要在 <code>package.json</code> 文件的 <code>scripts</code> 配置中添加 <code>&quot;tauri&quot;: &quot;tauri&quot;</code> 脚本。</li>
</ol>
</blockquote>
<p><strong>第二步：</strong> 执行完成后，将 tauri-cli 添加到 <a href="https://cargo.budshome.com/getting-started/installation.html">cargo</a>(<code>Rust</code> 的构建系统和包管理器) 子命令中：</p>
<pre><code>cargo install tauri-cli --locked --version ^1.0.0-rc
</code></pre>
<p><strong>第三步：</strong> 安装 <strong>@tauri-apps/api</strong>:</p>
<pre><code>yarn add @tauri-apps/api
</code></pre>
<p>这个包的作用是什么呢？假如我们的项目中使用了 ES modules，或者是使用了现在比较流行的一些打包构建工具，比如 <code>Webpack</code>、<code>Vite</code> 等等，使用这个包就可以比较安全的访问 Tauri 的接口（关于安全性，官方有专门撰写相应的文档，想了解具体内容小伙伴们可以参考 <a href="https://tauri.studio/docs/development/security">这篇文章</a>）。</p>
<p><strong>第四步：</strong> 初始化 Tauri 应用：</p>
<pre><code>yarn tauri init
</code></pre>
<p>项目名称以及窗口标题我们选择默认为项目名称，之后会让你设置静态资源的地址，默认设置为 <code>../dist</code>。这里我们设置成 Vuepress 打包后的 dist 目录： <code>../docs/.vuepress/dist</code>。最后的 <code>devServer</code> 我们也默认即可：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6c436c17b9b4a5bb1a461d50ad50688~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>至此，我们的 Tauri 项目就已经初始化完成。接下来，我们可以通过以下命令查看该项目的相关信息：</p>
<pre><code>yarn tauri info
</code></pre>
<p>执行完成后，会列出项目所对应的一些基本信息，包括 Tauri 脚手架的版本，Nodejs 的版本，项目的目录结构等等：</p>
<pre><code>Operating System - Mac OS, version 12.0.1 X64

Node.js environment
  Node.js - 14.15.0
  @tauri-apps/cli - 1.0.0-rc.4
  @tauri-apps/api - 1.0.0-rc.1

Global packages
  npm - 6.14.15
  pnpm - 6.19.0
  yarn - 1.22.17

Rust environment
  rustup - 1.24.3
  rustc - 1.58.1
  cargo - 1.58.0
  toolchain - stable-x86_64-apple-darwin 

App directory structure
/constants
/node_modules
/utils
/docs
/.github
/src-tauri
/Arithmetic
/preview
/.git
/coverage
/.idea
/src

App
  tauri - 1.0.0-rc.2 (no lockfile)
  tauri-build - no manifest (no lockfile)
  tao - no manifest (no lockfile)
  wry - no manifest (no lockfile)
  build-type - bundle
  CSP - unset
  distDir - ../docs/.vuepress/dist
  devPath - http://localhost:8080/
  framework - Vue.js
</code></pre>
<h4 id="步骤二修改配置">步骤二：修改配置</h4>
<p>在初始化完成后，我们的项目根目录下会多出一个目录：<code>src-tauri</code>，目录结构如下：</p>
<pre><code>└── src-tauri
    ├── .gitignore
    ├── Cargo.toml
    ├── rustfmt.toml
    ├── tauri.conf.json // tauri 配置文件
    ├── icons // 应用图表文件
    └── src // 打包相关
        ├── build.rs
        ├── cmd.rs
        └── main.rs
</code></pre>
<p>打开 <code>tauri.conf.json</code> 文件，修改 <code>build</code> 配置（配置中还可以修改应用的 icon，尺寸等其他信息，有兴趣的小伙伴可以自行探究）：</p>
<pre><code class="language-js">&quot;build&quot;: {
  &quot;distDir&quot;: &quot;../docs/.vuepress/dist&quot;,
  &quot;devPath&quot;: &quot;http://localhost:8080&quot;,
  &quot;beforeDevCommand&quot;: &quot;yarn docs:dev&quot;, // 在运行 yarn tauri dev 命令前执行的命令
  &quot;beforeBuildCommand&quot;: &quot;yarn docs:build&quot; // 在运行 yarn tauri build 命令前执行的命令
},
</code></pre>
<p>修改完成后，在执行命令之前，我们先看看 tauri 有哪些命令。执行 <code>yarn tauri help</code>：</p>
<pre><code class="language-js">USAGE:
    yarn run tauri &lt;SUBCOMMAND&gt; // 使用

OPTIONS:
    -h, --help       Print help information // 打印帮助信息
    -V, --version    Print version information // 打印版本信息

SUBCOMMANDS:
    build     Tauri build // 构建 tauri 包
    dev       Tauri dev // 本地开发命令
    help      Print this message or the help of the given subcommand(s) // 打印帮助信息
    info      Shows information about Tauri dependencies and project configuration // 打印项目信息
    init      Initializes a Tauri project // 初始化 tauri 项目
    plugin    Manage Tauri plugins // tauri 插件管理
    signer    Tauri updater signer // tauri 更新

</code></pre>
<p>了解完相关执行命令，我们执行 <code>yarn tauri dev</code> 命令。之后，会先执行我们先前配置的 <code>beforeDevCommand</code> 命令，在本地启动项目，然后会构建一个本地应用。</p>
<blockquote>
<p><strong>注意：</strong> 这里需要注意，本地 Vuepress 项目的端口号要与 <code>devPath</code> 中配置的一致！</p>
</blockquote>
<p>在等待一段时间后，便会启动本地的应用：</p>
<figure data-type="image" tabindex="4"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ee939a31854ea3af2f0c7aa920f4b5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>截止目前，我们的本地项目就已经可以成功运行啦~</p>
<h4 id="步骤三打包应用">步骤三：打包应用</h4>
<p>打包应用只需要运行 <code>build</code> 命令即可：</p>
<pre><code>yarn tauri build
</code></pre>
<p>打包完成后，会在 <code>src-tauri/target/release/bundle</code> 目录下生成相应的应用安装执行文件</p>
<figure data-type="image" tabindex="5"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/599f452f49724a45b2e4817918e15890~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>直接双击安装，之后便可以在本地使用这个应用来查看文档啦~ 大功告成，完结撒花~</p>
<h1 id="写在最后">写在最后</h1>
<p>看到这里，相信小伙伴们心中多少对 <code>Tauri</code> 这个后起之秀有了一些了解，有兴趣或者有需求的小伙伴们不妨来尝试一下~</p>
<p>本文是关于 Tauri 的一次浅尝，更多玩法大家可以参考<a href="https://tauri.studio/">官方文档</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pinia初体验]]></title>
        <id>https://luhaifeng666.github.io/post/pinia-chu-ti-yan/</id>
        <link href="https://luhaifeng666.github.io/post/pinia-chu-ti-yan/">
        </link>
        <updated>2022-01-27T18:58:57.000Z</updated>
        <summary type="html"><![CDATA[<p>1月20日，尤大在知乎平台发布 <a href="https://zhuanlan.zhihu.com/p/460055155"><code>Vue3</code> 将自2月7日起成为默认版本</a>的消息</p>
]]></summary>
        <content type="html"><![CDATA[<p>1月20日，尤大在知乎平台发布 <a href="https://zhuanlan.zhihu.com/p/460055155"><code>Vue3</code> 将自2月7日起成为默认版本</a>的消息</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/690b04d56e8d4672bc59056611c95967~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p><code>Vue3</code> 相关的技术栈也可以学习起来啦~本文就同大家一起初步体验下 “下一代的Vuex” -- <a href="https://pinia.vuejs.org/">Pinia</a>。</p>
<h1 id="什么是pinia">什么是Pinia</h1>
<h2 id="pinia-介绍">Pinia 介绍</h2>
<p>大概在2019年11月份左右，Pinia 的作者开始尝试重新设计 Store 状态管理以适用于 Composition API，其设计原则跟思想与 Vuex 保持一致。</p>
<p>在不同版本的 Vue 中，所使用的 Vuex 版本是不一样的。Vue2 中需要使用 Vuex 3.x的版本，而在 Vue3 中需要使用 Vuex 4.x。但是 Pinia 没有这个限制，无论是在 Vue2 中，还是在 Vue3 中均可以使用 Pinia，<strong>且不一定要与 Composition API 一起使用</strong>，API 的使用方式在两者中也是保持一致的。</p>
<p>现在，Pinia 也已经正式被纳入 Vue 官方体系中。笔者写这篇文章时，其版本已更新至 <strong>v2.0.9</strong> 。</p>
<h2 id="为啥要用-pinia">为啥要用 Pinia</h2>
<p>Pinia 是用于 Vue 中的状态管理器，允许你跨组件/页面共享状态。</p>
<p>如果小伙伴们已经对 Composition API 比较熟悉了的话，可能会考虑使用类似下面这种写法去共享全局状态：</p>
<pre><code class="language-vue">export const state = reactive({})
</code></pre>
<p>在 SPA 应用中，这样去做是可以的，但是如果是在 SSR 中去使用的话会存在安全隐患。所以还是建议使用 Pinia。</p>
<p>使用 Pinia 有以下好处：</p>
<ol>
<li>
<p><strong>调试工具支持</strong></p>
<p>笔者目前安装的是 beta 版本的 Vue devtool，小伙伴们可以去 <a href="chrome://extensions">谷歌应用商店</a> 中搜索 <code>Vue devtool</code> 下载对应的 beta 版本。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acca1566bfe4502bc35cee45a4f0589~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<ol>
<li>调试工具中支持追踪 actions，mutations 的timeline(时间线)；</li>
<li>可以显示当前组件中使用的 store 信息，也可以显示所有 store 容器的信息，支持直接修改数据进行调试；</li>
<li>支持 Time travel(时间旅行) 以方便调试。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>热模块替换</strong>：改变状态时无需手动刷新页面。</li>
<li><strong>插件支持</strong>：可以通过插件扩展 Pinia 的能力。</li>
<li><strong>良好的 Typescript 支持</strong>：可以提供较为完善的代码提示以及代码自动补充。</li>
<li><strong>支持 SSR</strong>。</li>
</ol>
<h2 id="pinia-与-vuex-的对比">Pinia 与 Vuex 的对比</h2>
<p>Pinia 与 Vuex4.x 以下版本相比，有如下区别：</p>
<blockquote>
<ol>
<li><strong>移除了 mutations</strong>： 在 Vuex 中，想要改变状态，需要通过提交 mutations 来实现，而 mutations 不能执行异步操作，因此诞生了 actions ，在异步获取数据后，通过 actions 调用 mutations 修改数据。现在在 Pinia 中，actions 同时支持同步与异步操作，所以 mutations 显得有些冗余了，因此不再需要；</li>
<li><strong>对于 Typescript 的支持更加友好</strong>：使用 Pinia 时,不再需要定义复杂的 wrappers（包装器）去支持Typescript;</li>
<li><strong>不会注入魔法字符串</strong>：在组件中使用 Vuex 时，经常会出现类似 <code>this.$store.commit(&quot;xxxxx&quot;)</code> 这样的魔法字符串，虽然会将这些字符串抽为常量暴露出来，但是维护起来还是不太方便。在 Pinia 中不再需要使用这种方式，而是直接调用 <code>defineStore</code> 后暴露出来的方法，而后通过 <code>$patch</code>, <code>action</code> 的方式，或者直接修改 store 中的值即可；</li>
<li><strong>不需要动态添加 stores</strong>：只要你愿意，你可以随时定义 stores，它们默认是动态的；</li>
<li><strong>不再需要嵌套结构的 modules</strong>;</li>
<li><strong>没有带命名空间的模块</strong>。</li>
</ol>
</blockquote>
<h1 id="pina的使用">Pina的使用</h1>
<h2 id="安装">安装</h2>
<p>我们先在本地搭建一个Vue3的项目，用于演示 <code>Pinia</code> 的使用，这里我们使用 <a href="https://cn.vitejs.dev/">Vite</a> 来搭建：</p>
<blockquote>
<p>Vite 需要 <a href="https://nodejs.org/en/">Node.js</a> 版本 &gt;= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<p>Vite官方提供了使用模板的方式构建本地项目，这里我们通过 <a href="https://www.pnpm.cn/">pnpm</a> 来构建一个 <code>Vite + Vue</code> 的本地项目。现在 Vue3 以及 Pinia 对于 Typescript 的支持已经非常良好了,建议大家在使用模板构建项目的时候直接选择 Typescript 对应的模板：</p>
<pre><code>pnpm create vite pinia-useage-examples -- --template vue-ts
</code></pre>
<p>之后，我们在项目中安装 <code>Pinia</code>:</p>
<pre><code> pnpm add pinia
</code></pre>
<p>准备工作完成，接下来就来一起体验一下 <code>Pinia</code> 吧~</p>
<h2 id="使用">使用</h2>
<p>首先，我们需要通过 <code>createPinia</code> 初始化 Pinia，并将其挂载到 Vue 的实例上：</p>
<pre><code class="language-ts">// src/main.ts

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

// 创建 pinia
const pinia = createPinia()

const app = createApp(App)
// 挂载到 Vue 实例上
app.use(pinia)
app.mount('#app')
</code></pre>
<p>之后按照惯例，我们先创建 <code>src/store/index.ts</code> 文件，用于存放 store:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  
})
</code></pre>
<p><strong>这里需要注意的是，<code>defineStore</code> 的第一个参数用于设置 store 的容器名称，该名称必须唯一，不可重复！</strong></p>
<p>上文中提到，相比于 Vuex，Pinia 中移除了 mutations，剩余需要了解的内容主要包含四个部分：</p>
<blockquote>
<ol>
<li><strong>State</strong>: 用于存放数据，有点儿类似 <code>data</code> 的概念；</li>
<li><strong>Getters</strong>: 用于获取数据，有点儿类似 <code>computed</code> 的概念；</li>
<li><strong>Actions</strong>: 用于修改数据，有点儿类似 <code>methods</code> 的概念；</li>
<li><strong>Plugins</strong>: Pinia 插件。</li>
</ol>
</blockquote>
<p>现在我们依次来看一看它们的用法。</p>
<h2 id="state">State</h2>
<h3 id="定义-state">定义 State</h3>
<p>在 Vuex 中，通过对象的形式来定义 state ，而在 Pinia 中则需要通过函数的方式定义 state，这种方式有点儿类似组件中 <code>data</code> 的概念:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  state: () =&gt; {
    return {
      count: 0,
      name: 'foo',
      list: [1, 2, 3]
    }
  }
})
</code></pre>
<h3 id="读取-state">读取 State</h3>
<p>state 定义完成后，我们在页面中可以通过引入暴露出去的 <code>useStore</code> 来读取 state 中的数据：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;p&gt;count: {{ myStore.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ myStore.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ myStore.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const myStore = useStore()
&lt;/script&gt;
</code></pre>
<p>看到这里，有的小伙伴不禁会问，在使用过程中，一直要写 <code>myStore.xxx</code> 不是很麻烦么？能否通过解构的方式来使用呢？</p>
<p>那我们就一起来试一试，看看是否可以通过解构的方式来获取 store 中的值:</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const { count, name, list } = useStore()
&lt;/script&gt;
</code></pre>
<p>通过这次尝试我们发现，确实可以通过解构的方式来获取到 store 的值。但是这种方式存在一个问题：<strong>直接通过解构的方式获取state中的值是非响应式的！</strong> 这就意味着后面在对 store 中的值进行修改之后，页面不会发生变化。</p>
<p>那我们改如何解决这个问题呢？答案是通过 Pinia 中提供的 <code>storeToRefs</code> 方法，将结构出来的值转换为响应式的值即可：</p>
<pre><code class="language-ts">// src/App.vue

&lt;script setup lang=&quot;ts&quot;&gt;
import { storeToRefs } from 'pinia'
import { useStore } from './store'

const { count, name, list } = storeToRefs(useStore())
&lt;/script&gt;
</code></pre>
<p>除了使用这两种方式以外，Pinia 也提供了 <code>mapState</code> 与 <code>computed</code> 相结合的方式去获取 store 中的值，这种方式与 Vuex 中的 <code>mapState</code> 类似：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ res.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ res.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ res.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, ['count', 'name', 'list'])
  }
  return {
    count: data.count(),
    name: data.name(),
    list: data.list()
  }
})
&lt;/script&gt;
</code></pre>
<p>由于是通过 <code>computed</code> 获取到的值，所以结构之后的值就是响应式的，不需要使用 <code>stateToRefs</code> 方法进行转换。</p>
<p>在 <code>computed</code> 内部也可以对属性进行重命名，或者重新定义新的返回值返回值：</p>
<pre><code class="language-js">&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, {
      // 重命名count为myCount, 并返回count + 1的结果
      myCount: state =&gt; state.count += 1,
      // 重命名name为没有Name，并返回name的值
      myName: 'name',
      // 重命名list为myList，并返回插入4之后的list
      myList: state =&gt; {
        state.list.push(4)
        return state.list
      }
    })
  }
  return {
    count: data.myCount(),
    name: data.myName(),
    list: data.myList()
  }
})
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>本文的示例中使用的是 <code>setup</code> 语法糖，如果不使用 <code>setup</code> 语法糖的话，<code>mapState</code> 的使用方式与本文中所举的🌰有些差别(关于这个问题，网上有使用 <code>bind</code> 的方式的栗子，具体可以参考<a href="https://blog.csdn.net/WaiTinglw/article/details/122091494">这篇文章</a>)。详情可以查阅<a href="https://pinia.vuejs.org/core-concepts/state.html#usage-with-the-options-api">官方文档</a>。如果本文中有使用不当之处，还请诸位大佬指正~ Orz；</li>
<li>通过 <code>computed</code> 返回的 state 无法使用结构的方式获取其中的值，因为返回的不是单纯的对象，而是一个 <code>ComputedRefImpl</code> 类型的值。</li>
<li>通过 <code>mapState</code> 获取到的值是<strong>只读</strong>的，如果想要其可写，可以使用 <code>mapWritableState</code> 的方式。</li>
</ol>
</blockquote>
<h3 id="修改-state">修改 State</h3>
<p>现在我们已经可以获取到 State 中存储的值了，那么我们该如何去修改 State 中的值呢？其实很简单，主要分为以下几种方式：</p>
<h4 id="第一种直接修改">第一种：直接修改</h4>
<p>直接修改 State 中的值即可：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()
// 修改store中的值
const handleChangeStore = () =&gt; {
  // 直接修改
  store.count += 1
}
&lt;/script&gt;
</code></pre>
<p>甚至可以通过暴力覆盖 <code>$state</code> 的方式将所有值进行替换修改：</p>
<pre><code class="language-ts">// src/App.vue

// 省略好多好多代码。。。

// 直接清空store
store.$state = {}
</code></pre>
<h4 id="第二种-通过-patch-的方式修改">第二种: 通过 <code>$patch</code> 的方式修改</h4>
<p>当我们需要一次性修改多个值的时候，我们可以使用 <code>$patch</code> 方法来批量修改多个值：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过 $patch 的方式修改
  store.$patch({
    name: 'test',
    list: [...store.list, 4]
  })
}
&lt;/script&gt;
</code></pre>
<p><code>$patch</code> 会将传入的对象与 Store 中的 state 进行 merge 覆盖。</p>
<p>除了直接传入对象外，如果存在较为复杂的操作，<code>$patch</code> 方法也接受传入一个回调函数，在回调函数中对需要修改的数据进行操作：</p>
<pre><code>// src/App.vue

// 省略好多好多代码。。。
store.$patch(state =&gt; {
  state.name = `我的名字是：${state.name}`
})

</code></pre>
<h4 id="第三种通过-reset-方法恢复原值">第三种：通过 <code>$reset</code> 方法恢复原值</h4>
<p>当我们修改了 state 中的值以后，倘若我们想让它们恢复到初始值，可以使用 <code>$reset</code> 方法。</p>
<h4 id="第四种通过调用-actions-中的方法去修改值">第四种：通过调用 <code>actions</code> 中的方法去修改值</h4>
<p>首先，我们需要在 Store 容器中定义 <code>actions</code>:</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  actions: {
    changeCount () {
      this.count ++
    }
  }
})
</code></pre>
<p>在 <code>actions</code> 中定义的方法，可以直接通过 <code>this</code> 来访问 state 中的属性，而无需像 Vuex 那样传入上下文才可以，使用方式有点儿类似 <code>methods</code>。</p>
<p>定义完成后，我们就可以在引用处直接使用它了：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过actions的方式修改
  store.changeCount()
}
&lt;/script&gt;
</code></pre>
<p>当然，<code>actions</code> 中的方法也可以接收入参，使用方式与 <code>methods</code> 并无区别，这里不做过多赘述。</p>
<h3 id="调试-state">调试 State</h3>
<p>打开控制台，切换到 Vue devtool 中，选择 <code>Pinia</code> 选项，就可以看到 store 容器的信息：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e6e06b6634e4ec8bfdcac7aeaf3c55d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>并且点击数据后面的编辑按钮，也可以修改 store 中的值进行调试，非常方便：</p>
<figure data-type="image" tabindex="4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99a0e1af8e74eefa41784219996ad81~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="getters">Getters</h2>
<p><code>getters</code> 的使用方式有点儿类似于 <code>computed</code>, 返回一个值(<strong>没有返回值也可以</strong>)且在页面中可以直接使用。如果 <code>getters</code> 中使用了 <code>state</code> 里的数据，当对应的数据发生变化时，<code>getters</code> 的值也会相应发生变化：</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  getters: {
    countPlusOne (state) {
      console.log('------countPlusOne------')
      return state.count + 1
    }
  }
})
</code></pre>
<p>直接在页面中使用，并且 <code>getters</code> 也有缓存，在页面中多次使用时，只会计算一次：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;p&gt;countPlusOne: {{ store.countPlusOne }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()
&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf3831592af4344a1cfe7483c520ec6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>我们可以看到日志只打印了一次，说明后面两次是取的缓存中的数据。</p>
<blockquote>
<p>注意：</p>
<ol>
<li><code>getters</code> 中定义的方法，入参 <code>state</code> 是可选参数，如果不传入 <code>state</code>, 可以直接使用 <code>this</code> 访问 <code>state</code> 中的数据；</li>
<li>如果不传入 <code>state</code> 的话，Typescript 会有报错提示，因为无法推导出 <code>getters</code> 中方法的返回值类型，需要手动声明返回值类型。</li>
</ol>
</blockquote>
<h2 id="actions">Actions</h2>
<p>上文中提到可以通过 <code>Actions</code> 的方式修改 <code>State</code> 中的值，只不过所使用的是同步的方式。在一开始对 Pinia 的介绍中也提到，<code>Actions</code> 同时支持同步与异步两种修改数据的方式。接下来我们看看如何通过 <code>Actions</code> 异步修改数据。</p>
<pre><code class="language-ts">// src/store/index.ts

// 省略好多好多代码。。。
actions: {
  async changeName () {
    const newName: string = await new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('newName')
      }, 1000)
    }).catch(err =&gt; {
    })
    this.name = newName
  }
}
</code></pre>
<p>通过上述代码我们不难发现，其实 <code>Actions</code> 通过异步修改数据的方式与寻常使用 <code>methods</code> 异步修改 <code>data</code> 中的数据类似，相较于 Vuex 简便许多。</p>
<h2 id="plugins">Plugins</h2>
<h3 id="插件介绍">插件介绍</h3>
<p>通过自定义 <code>Plugins</code> 可以扩展 <code>Stores</code>，它可以完成以下这些事情：</p>
<blockquote>
<ol>
<li>新增 <code>store</code> 中的属性;</li>
<li>定义 <code>store</code> 时传入新的配置项;</li>
<li>新增 <code>store</code> 中的方法;</li>
<li>包装 <code>store</code> 中的既有方法;</li>
<li>修改甚至取消 <code>actions</code>;</li>
<li>实现一些副作用操作，例如设置 local storage 缓存等等;</li>
<li>只会应用于特定的 <code>store</code>: 在 Pinia 挂载到 app 上后，插件会挂载到之后创建的 Stores 上，在此之前 Plugins 不会被挂载。</li>
</ol>
</blockquote>
<h3 id="插件定义-使用">插件定义 &amp; 使用</h3>
<p>插件本质上是一个函数，插件接受一个可选入参： <code>context</code>, 改入参是个对象，其中包含四项内容：</p>
<ol>
<li><strong>context.pinia:</strong> 通过 <code>createPinia()</code> 方式创建的 Pinia 实例</li>
<li><strong>context.app:</strong> 通过 <code>createApp()</code> 方式创建的 app 实例(仅支持Vue 3)</li>
<li><strong>context.store:</strong> store 对象</li>
<li><strong>context.options:</strong> 获取定义 store 时传入的配置项</li>
</ol>
<p>函数可以通过返回对象的方式，将对象中的值绑定到<strong>所有的</strong> store 上去：</p>
<pre><code class="language-ts">// src/main.ts

function SecretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}
</code></pre>
<p>定义完成后，通过 <code>pinia.use()</code> 的方式使用这个插件：</p>
<pre><code class="language-ts">// src/main.ts
import { createPinia } from 'pinia'

const pinia = createPinia()

pinia.use(SecretPiniaPlugin)
</code></pre>
<p>之后，在页面中打印 Store 中的 <code>secret</code> 属性时，即可看到我们设定的值。并且通过这种方式新增到 store 中的属性可以被 Vue devtool 捕获到：</p>
<figure data-type="image" tabindex="6"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5de1b7353e4de3b4a5deca838997c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>当然你也可以选择直接将值绑定到 store 对象上，但是这样<strong>无法被 Vue devtool捕获</strong>：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7178d567ae64a8d9a61e9c40bb0a93a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>此时我们不难发现，上述步骤中的 <code>customProperties</code> 属性不见了。如果在调试过程中需要在 Vue devtool 中看到插件中定义的 store 内容，需要手动添加：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}
</code></pre>
<p>添加完属性后，当我们直接在页面中使用时，发现页面上并不能显示出插件插入到 store 中的属性，这是因为插入的属性是<strong>非响应式的</strong>，此时，我们只需将插入的属性值变为<strong>响应式数据</strong>即可：</p>
<pre><code class="language-ts">import { createApp, ref } from 'vue'
import { createPinia } from 'pinia'

// 创建 pinia
const pinia = createPinia()

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = ref('the cake is a lie')
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}

// 使用插件
pinia.use(SecretPiniaPlugin)
</code></pre>
<p>设置完成后，再在页面中使用时，就可以在页面上看到数据啦~</p>
<p>此外，在插件中可以通过 <code>store.$subscribe</code> 以及 <code>store.$onActions</code> 方法监听 actions 的触发。</p>
<p>关于插件的更多玩法可以参考<a href="https://pinia.vuejs.org/core-concepts/plugins.html">官方文档</a>。</p>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，相信大家对于 <code>Pinia</code> 已经有了一个初步的印象。文章中若有描述不当之处还请诸位大佬指正。</p>
<p>好记性不如烂笔头，关于 Pinia 的其他更多玩法等待着小伙伴们去挖掘。赶快动手 <s>卷起来</s> 尝个鲜吧~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手写练习：防抖节流]]></title>
        <id>https://luhaifeng666.github.io/post/shou-xie-lian-xi-fang-dou-jie-liu/</id>
        <link href="https://luhaifeng666.github.io/post/shou-xie-lian-xi-fang-dou-jie-liu/">
        </link>
        <updated>2022-01-18T16:45:06.000Z</updated>
        <summary type="html"><![CDATA[<p>不论在日常工作中，还是在面试过程中，<code>防抖节流</code> 总是会时不时的出现在我们的视野里。在日常使用的时候，可能会直接使用第三方库封装好的方法，比如 <code>lodash</code> 中的防抖方法 <a href="https://lodash.com/docs/4.17.15#debounce"><em>.debounce</a> 和节流方法 <a href="https://lodash.com/docs/4.17.15#throttle"></em>.throttle</a>。抑或是使用开发团队的小伙伴们封装好的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>不论在日常工作中，还是在面试过程中，<code>防抖节流</code> 总是会时不时的出现在我们的视野里。在日常使用的时候，可能会直接使用第三方库封装好的方法，比如 <code>lodash</code> 中的防抖方法 <a href="https://lodash.com/docs/4.17.15#debounce"><em>.debounce</a> 和节流方法 <a href="https://lodash.com/docs/4.17.15#throttle"></em>.throttle</a>。抑或是使用开发团队的小伙伴们封装好的方法。</p>
<!-- more -->
<p>在忙碌的工作中，也许小伙伴们知道它们的作用，但是对其中的原理逐渐陌生。今天我们就把这两个 <code>老朋友</code> 请出来，再来一起看看是如何实现的吧~</p>
<h1 id="节流方法throttle">节流方法：throttle</h1>
<h2 id="什么是节流">什么是节流</h2>
<p>用一句话概括节流：</p>
<blockquote>
<p>在规定的延时时间内，不管你执行多少次，我都只认第一次。</p>
</blockquote>
<h2 id="节流的实现">节流的实现</h2>
<pre><code class="language-js">/**
 * 节流函数
 * @param fn
 * @param delay
 */
function throttle (fn, delay) {
 // 上一次的调用时间
 let lastTime = 0

 // 将throttle结果以函数形式返回
 return function () {
  // 保存执行时上下文
  const context = this
  // 保存调用throttle结果函数时传入的参数
  const args = arguments
  // 本地调用的时间
  const time  = new Date()
  // 如果本次调用时间减去上一次的调用时间大于延迟时间，则触发传入的fn
  if (time - lastTime &gt; delay) {
   lastTime = time
   fn.apply(context, args)
  }
 }
}
</code></pre>
<h1 id="防抖方法debounce">防抖方法：debounce</h1>
<h2 id="什么是防抖">什么是防抖</h2>
<p>用一句话概括防抖：</p>
<blockquote>
<p>在规定的延时时间内，不管你触发多少次回调，都只认最后一次。</p>
</blockquote>
<h2 id="防抖的实现">防抖的实现</h2>
<pre><code class="language-js">/**
 * 防抖
 * @param fn
 * @param delay
 */
function debounce (fn, delay) {
 // 保存延时
 let timer = null
 // 将debounce的处理结果以函数形式返回
 return function () {
  // 保存执行时上下文
  const context = this
  // 保存执行时传入的参数
  const args = arguments
  // 如果存在定时器，则将其清除
  timer &amp;&amp; clearTimeout(timer)
  // 设置新的定时器，在计时结束后触发回调
  timer = setTimeout(() =&gt; {
   fn.apply(context, args)
  }, delay)
 }
}
</code></pre>
<h1 id="防抖的弊端">防抖的弊端</h1>
<p>防抖与节流的目的，都是在一定时间内限制回调函数被调用的次数，从而在一定程度上提升性能。</p>
<p>但是防抖存在一个弊端，那就是如果在 <code>delay</code> 指定的时间内不断触发防抖，就会导致回调函数迟迟不会有响应。只有在你 <code>停手</code> 之后，经过 <code>dealy</code> 这段时间后，回调函数才会有响应。</p>
<p>既然如此，如果我们能在一开始就触发回调，然后在后续频繁的操作里保持防抖的特性，岂不是美滋滋~</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f590f56f027483396cbd269655ac3e6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="加强版的节流方法strongerthrottle">加强版的节流方法：strongerThrottle</h1>
<p>回顾我们之前所实现的 <code>节流</code> 方法，它不正是在一开始就可以立即调用回调函数的么？既然如此，我们可以使用 <code>throttle</code> 方法来对 <code>debounce</code> 方法进行优化，实现一个加强版的节流方法。</p>
<pre><code class="language-js">/**
 * 更健壮的节流，结合了防抖
 * @param fn
 * @param delay
 */
function strongerThrottle (fn, delay) {
 // 保存计时器与最后一次调用时间
 let timer = null
 let lastTime = 0
 // 将调用strongerThrottle的结果以函数形式返回
 return function () {
  // 保存执行上下文
  const context = this
  // 保存传入的参数
  const args = arguments
  // 保存当前调用时间
  const time = new Date()
  // 如果当前调用的时间减去最后一次调用的时间小于延迟时间，则设置定时器
  if (time - lastTime &lt; delay) {
   // 如果存在定时器，则先清空
   timer &amp;&amp; clearTimeout(timer)
   // 设置新的定时器，在计时结束后触发回调
   timer = setTimeout(function () {
    lastTime = time
    fn.apply(context, args)
   }, delay)
  } else {
   // 如果超出时间，则给出响应
   lastTime = time
   fn.apply(context, args)
  }
 }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS学习：边框内圆角]]></title>
        <id>https://luhaifeng666.github.io/post/css-xue-xi-bian-kuang-nei-yuan-jiao/</id>
        <link href="https://luhaifeng666.github.io/post/css-xue-xi-bian-kuang-nei-yuan-jiao/">
        </link>
        <updated>2022-01-17T13:35:26.000Z</updated>
        <summary type="html"><![CDATA[<p>需求：<strong>元素边框内侧的四个角为圆角，形成内圆角的效果</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<p>需求：<strong>元素边框内侧的四个角为圆角，形成内圆角的效果</strong>。</p>
<!-- more -->
<h3 id="想法一">想法一</h3>
<p>这个需求主要分为两部分，边框和圆角。实现边框跟圆角并不困难，只要使用border以及<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">border-radius</a>属性即可：</p>
<h4 id="代码1">代码1</h4>
<pre><code class="language-css">border: 10px solid #67C23A;  
border-radius: 10px;  
</code></pre>
<p>实现效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3508271000114aada421533011a1808c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>我们可以看到，最终实现的是外圆角内直角的效果，因为在设置 <code>border-radius</code> 的时候，是算上边框的。</p>
<h3 id="想法二">想法二</h3>
<p>在<a href="https://juejin.cn/post/7052624943795666974">多重边框</a>这篇文章中提到过 <code>outline</code>，那我们是否可以通过 <code>outline</code> 以及 <code>border-radius</code> 的方式来实现这个效果呢：</p>
<h4 id="代码2">代码2</h4>
<pre><code class="language-css">outline: 10px solid #67C23A;  
border-radius: 10px;  
</code></pre>
<p>具体效果如下所示：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ebe260ff7d4596841484ddd16b8fe0~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>实际效果距离我们的预期已经非常接近了，可是在元素的四个角还存在白色的空隙，那该怎么填上呢？答案是<strong>box-shadow!</strong> 我们可以利用它来实现这个效果：</p>
<h4 id="代码3">代码3</h4>
<pre><code class="language-css">outline: 10px solid #67C23A;  
border-radius: 10px;  
box-shadow 0 0 0 4px #67C23A  
</code></pre>
<p>最后的效果如下所示：</p>
<demo-1-4 :type="'type3'" />  
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb97b6321e5e4948b5ddf7d757f7bd85~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>那这个偏移量我们要设置多少合适呢？其实计算也非常简单。四个内圆角其实就是4个1/4圆:<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa239afce1e942338be271fa28241430~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></p>
<p>通过勾股定理可以求得 <code>L = √2R</code> ，<code>box-shadow</code> 需要设置的偏移量为 <code>L - R = (√2 - 1) * R</code>，其中，<code>R</code> 是 <code>border-radius</code> 的值。所以在上述例子中，偏移量的距离大概为：<code>0.414 * 10 = 4px</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[背景定位]]></title>
        <id>https://luhaifeng666.github.io/post/bei-jing-ding-wei/</id>
        <link href="https://luhaifeng666.github.io/post/bei-jing-ding-wei/">
        </link>
        <updated>2022-01-14T02:19:40.000Z</updated>
        <summary type="html"><![CDATA[<p>CSS2.1中，使用 <code>background-position</code> 属性进行背景定位，可以通过设置 <code>top,left,right,bottom</code> 来实现，也可以设置具体的数值或者百分比来实现，但是在不固定宽高的容器中，想要跟容器的边框保留固定的边距，就只能通过百分比实现大概的间距，不能精确到具体位置。而在CSS3中，则存在两种方案，可以实现背景定位的位置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>CSS2.1中，使用 <code>background-position</code> 属性进行背景定位，可以通过设置 <code>top,left,right,bottom</code> 来实现，也可以设置具体的数值或者百分比来实现，但是在不固定宽高的容器中，想要跟容器的边框保留固定的边距，就只能通过百分比实现大概的间距，不能精确到具体位置。而在CSS3中，则存在两种方案，可以实现背景定位的位置。</p>
<!-- more -->
<h3 id="1-background-position的扩展语法">1、background-position的扩展语法</h3>
<p>在CSS3中，可以指定背景图片<strong>距离任意角的偏移量</strong>，只要我们在<strong>偏移量前指定关键字即可。</strong></p>
<pre><code class="language-css">background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-color: #409EFF;  
</code></pre>
<p>效果如下图所示:</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42078d94ae5f4eb2b901920556799c96~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>此时，图中的喵酱距离上边10px，距离左边10px。这样就可以实现精确定位。</p>
<h3 id="2-background-origin">2、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin">background-origin</a></h3>
<p>在日常开发过程中，有这样一个场景，我需要图片的偏移量与内边距一致。如果继续使用上述方法的话，可能会出现如下代码：</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-color: #409EFF;  
</code></pre>
<p>这样写确实实现了我们想要的效果，可是如果此时我的需求发生变化，内边距需要改为20px，这样一来，就导致我们需要改三个地方的数值。如果只是少数几个地方还好，如果改动的地方比较多，那么久增加了日常维护的成本。</p>
<p>我们知道，除去margin以外，元素的内容主要分成以下三个部分：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fdd248584a482a8012d40c85b0766d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>背景定位中的 <code>top,left,right,bottom</code> ，它们的定位都是依据 <code>padding-box</code> 来的，此时，我们可以通过 <code>background-origin</code> 来修改默认的参照：</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat top 10px left 10px / 30%;  
background-origin: content-box;  
</code></pre>
<p>我们只需要修改 <code>padding</code> 一个值，就可以灵活应对上述变化了。<br><br>
与之相仿，我们也可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc">calc</a>来实现定位。</p>
<pre><code class="language-css">padding: 10px;  
background: url(../public/images/orange.jpeg) no-repeat calc(100% - 20px) calc(100% - 10px) / 30%;  
background-origin: content-box;  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多重边框]]></title>
        <id>https://luhaifeng666.github.io/post/css-xue-xi-duo-chong-bian-kuang/</id>
        <link href="https://luhaifeng666.github.io/post/css-xue-xi-duo-chong-bian-kuang/">
        </link>
        <updated>2022-01-13T09:42:24.000Z</updated>
        <summary type="html"><![CDATA[<p>多重边框主要分为两种情况，一种是两层边框，还有一种是2层以上的边框。针对这两种情况，分别对应有不同的处理方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>多重边框主要分为两种情况，一种是两层边框，还有一种是2层以上的边框。针对这两种情况，分别对应有不同的处理方案。</p>
<!-- more -->
<h3 id="1-outline">1、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/outline">outline</a></h3>
<p>某些情况下，如果你只需要两层边框，那么可以使用 <code>outline</code> 来实现。</p>
<pre><code class="language-css">background: #409EFF;  
border: 10px solid #67C23A;  
outline: 5px solid #E6A23C;  
</code></pre>
<p>如<a href="https://codepen.io/luhaifeng666/pen/QWqzwKO">demo1</a>。其中，绿色的是 <code>border</code>，黄色的是 <code>outline</code>。</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db1c4a60f8ff486893e11bd1cc5985cc~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p><strong>优点</strong></p>
<ol>
<li>比较灵活，可以自由设置边框的样式；</li>
<li>也可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset">outline-offset</a>来设置跟元素边缘之间的距离，这个属性可以接受负值。设置负值时则是显示的内边框，类似于 <code>box-shadow</code> 的 <code>inset</code> 。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>只适用于双边框的样式，多边框的样式不能用；</li>
<li>产生的边框不能贴合设置了圆角的元素，需要配合 <code>box-shadow</code> 来优化这个问题（后面会提到）;</li>
<li>根据CSS基本UI特性(第三版)规范，<strong>描边可以不是矩形</strong>，使用时要测试各个浏览器的表现情况。</li>
</ol>
</blockquote>
<h3 id="2-box-shadow">2、<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow">box-shadow</a></h3>
<p>常规的 <code>box-shadow</code> 是用来设置阴影的，但是这个属性可以设置多值，通过它的偏移特性，我们可以生成多重边框。</p>
<pre><code class="language-css">margin: 50px auto;  
box-shadow: 0 0 0 10px #67C23A, 0 0 0 20px #F56C6C, 0 0 0 30px #E6A23C;  
</code></pre>
<p>参考<a href="https://codepen.io/luhaifeng666/pen/QWqzwKO">demo2</a>。</p>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185eaf1c75844b09962a19f6694305df~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p><strong>优点</strong></p>
<ol>
<li>相比较于 <code>outline</code> ，这种方式可以设置多重边框；</li>
<li>除了边框，<code>box-shadow</code> 的偏移还能实现其他更多神奇的效果</li>
</ol>
</blockquote>
<blockquote>
<p><strong>缺点</strong></p>
<ol>
<li>相比较outline边框的自由设置，<code>box-shadow</code> 不能实现类似边框虚线的效果；</li>
<li>不会影响布局，也不会受到<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing">box-sizing</a>属性的影响；</li>
<li>不会影响鼠标的事件，比如hover还有click，使用的时候要注意。</li>
</ol>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[半透明边框]]></title>
        <id>https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/</id>
        <link href="https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/">
        </link>
        <updated>2022-01-12T02:34:10.000Z</updated>
        <summary type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
]]></summary>
        <content type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
<!-- more -->
<p>我们在想实现一个透明边框的时候，通常想到的可能是以下代码：</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
</code></pre>
<p>可是如果这时候给元素添加一个背景色或者背景图片，背景图片与背景色会透过透明边框显示出来。这是因为<strong>在默认情况下,背景会延伸到边框所在区域的下层。</strong></p>
<p>先来看一个<a href="https://codepen.io/luhaifeng666/pen/MWEzyag?editors=1111">栗子</a>~</p>
<p>通过这个例子我们可以看到，元素的背景色被设置为蓝色，背景色设置为<code>rgba(255,255,255,.6)</code> ,此时，透过透明边框可以看到元素的背景色。</p>
<h3 id="解决办法">解决办法</h3>
<p>通过添加 <code>background-clip</code> 来解决此类问题。</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
background-clip: padding-box;
</code></pre>
<blockquote>
<p>background-clip属性是用来设置背景裁剪区域的，该属性接受三个参数：content-box | padding-box | border-box | text，裁剪区域如下：</p>
<ol>
<li>content-box: content部分，背景被裁剪至内容区（content box）外沿。</li>
<li>padding-box: content + padding部分，背景延伸至内边距（padding）外沿。不会绘制到边框处。</li>
<li>border-box: content + padding + border部分，背景延伸至边框外沿（但是在边框下层）。</li>
<li>text: 裁剪为text前景色</li>
</ol>
</blockquote>
<p>具体用法可以参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip">background-clip</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mini-vue学习：reactivity 的核心流程]]></title>
        <id>https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/</id>
        <link href="https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/">
        </link>
        <updated>2021-12-29T12:38:48.000Z</updated>
        <summary type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
<!-- more -->
<h2 id="写在开始">写在开始</h2>
<p>在正式开始学习之前，我们先一起来了解一个思想：<code>TDD</code>。什么是 <code>TDD</code> 呢？我们先来看下它的概念：</p>
<pre><code>TDD是测试驱动开发（Test-Driven Development）的英文简称。
它是敏捷开发中的一项核心实践和技术，也是一种设计方法论。
TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。
TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于其他开发方法和过程。
</code></pre>
<p>简而言之，就是 <code>测试驱动开发</code>，在动手开发之前先写好测试用例，然后再进行开发。<br><br>
在接下来的学习过程中，<code>TDD</code> 的思想将贯穿始终。话不多说，让我们一起进入vue3的源码学习吧~</p>
<blockquote>
<p><strong>声明：</strong><br><br>
笔记中的内容来源于 <strong>崔大(wx: cuixr1314)</strong> 的 <a href="https://github.com/cuixiaorui/mini-vue">mini-vue</a> 教学，目前已经 <code>4k+</code>的⭐️了，欢迎大家踊跃star~<br><br>
热爱学习的小伙伴们，可以搜索 <code>催学社</code> 微信群，里面都是一群热爱学习的小伙伴，学习氛围一级棒！期待你的加入~<br><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab46bb312db444c8352d44cbe9f4c70~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></p>
</blockquote>
<h2 id="正文开始">正文开始</h2>
<p>我们知道，不论是在 <code>vue2</code> 中，还是在 <code>vue3</code> 中， <code>响应式数据</code> 一直都是vue的核心概念。这一节，我们也先从 <code>响应式数据</code> 开始说起。</p>
<h3 id="vue2-与-vue3-中对响应式数据处理的区别">vue2 与 vue3 中对响应式数据处理的区别</h3>
<p>熟悉 <code>vue2</code> 的小伙伴儿们都知道，在 <code>vue2</code> 中，数据的响应式是通过 <code>Object.defineProperty</code> 来实现的。针对对象，通过遍历对象的属性，来设置属性对应的 <code>getter</code> 以及 <code>setter</code> 方法，以达到 <code>依赖收集</code> 与 <code>触发依赖</code> 的目的；<br>
而针对数组，则是通过重写数组一系列更新元素的方法来实现对数组元素修改的劫持。<br><br>
但是通过这种方式来实现数据响应式，存在以下几个问题：</p>
<pre><code>1. 对象直接新添加新的属性，或者删除已有的属性, 界面不会自动更新；
2. 直接通过替换数组对应下标的元素，或者更新数组的length, 界面也不会自动更新；
3. 如果对象的属性较多，且嵌套层次较深时，需要深度遍历，循环量大，性能损耗较大。
</code></pre>
<p>针对以上几个问题，<code>vue3</code> 中使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 来代替 <code>Object.defineProperty</code>。<br><br>
针对 <code>问题1</code> 和 <code>问题3</code>，<code>Proxy</code> 代理了整个对象，并且提供了多达13种对对象属性的操作（如属性查找、赋值、枚举、函数调用等），在对象发生变化时，<code>Proxy</code> 都可以进行捕获，与 <code>Object.defineProperty</code> 不同，无需遍历所有属性；<br><br>
针对 <code>问题2</code>，<code>Proxy</code> 对数组的监听相较于 <code>Object.defineProperty</code> 性能更优。具体大家可以参考 <a href="https://cloud.tencent.com/developer/news/485729">这篇文章</a> 。<br></p>
<p>那在 <code>vue3</code> 中具体是如何通过 <code>Proxy</code> 的方式实现响应式的呢？</p>
<h3 id="reactivity-第一步reactive"><code>reactivity</code> 第一步：reactive</h3>
<blockquote>
<p><strong>注：</strong> <br><br>
本文以 vue3 中的 <code>reactive</code> 为例，如果对 <code>reactive</code> 操作尚不熟悉的同学可以看下 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html">这篇文档</a>。至于 <code>ref</code>，其底层也是 <code>reactive</code>, 关于 <code>ref</code> 的内容，在完成 <code>reactive</code> 所有相关功能的梳理后，后续的文章中会做补充，这里先埋个伏笔~（手动🌺🐔）</p>
</blockquote>
<p>还记得开篇时提到的 <code>TDD</code> 么？开始之前，我们先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/reactive.spec.ts

import { reactive } from '../reactive'

describe('reactive', () =&gt; {
  it ('happy path', () =&gt; {
    const original = { foo: 1 }
    // 创建Proxy代理对象
    const observeOriginal = reactive(original)
    // 响应式对象与原对象应该不相等，因为observeOriginal被Proxy包裹
    expect(observeOriginal).not.toBe(original)
    // 取值
    expect(observeOriginal.foo).toBe(1)
  })
})
</code></pre>
<p>测试用例中， <code>reactive</code> 将传入的对象转换成 <code>Proxy</code> 代理对象，之后通过代理对象来获取其中的值。既然如此，那我们就从 <code>reactive</code> 入手。先来看下 <code>reactive</code> 的定义：</p>
<pre><code class="language-ts">// src/reactivity/reactive.ts

import { mutableHandlers } from './baseHandlers'

export const reactiveMap = new WeakMap()

/**
 * 创建reactive对象
 * @param target
 */
export function reactive (target) {
  return createReactiveObject(target, reactiveMap, mutableHandlers)
}

/**
 * 创建响应式对象
 * @param target
 * @param proxyMap
 * @param baseHandlers
 */
export function createReactiveObject (target, proxyMap, baseHandlers) {
  // 判断proxy是否已经保存过
  if (proxyMap.has(target)) {
    // 如果存在，则返回
    return proxyMap.get(target)
  }

  const proxy = new Proxy(target, baseHandlers)

  // 存储创建好的proxy
  proxyMap.set(target, proxy)
  return proxy
}
</code></pre>
<p>从上述代码可以看出，<code>reactive</code> 中调用了 <code>createReactiveObject</code> 方法，既然 <code>reactive</code> 方法是用来返回 <code>Proxy</code> 对象的，那在 <code>createReactiveObject</code> 中又发生了什么呢？我们一起来分析一下：</p>
<ol>
<li><code>createReactiveObject</code> 接收三个参数：需要被代理的对象 <code>target</code>, 也就是在 <code>reactive</code> 接收的 <code>target</code> 参数、用于存储 <code>Proxy</code> 对象的 <code>proxyMap</code> 以及 <code>Proxy</code> 对象的处理器 <code>baseHandlers</code>;</li>
<li>先判断在 <code>proxyMap</code> 是否已经存在当前对象所对应的 <code>Proxy</code> 对象，如果存在，则直接返回, 否则新建一个 <code>Proxy</code> 对象，并以当前的 <code>target</code> 为key，存储到 <code>proxyMap</code>，以便下次取用，并将新建的 <code>Proxy</code> 返回。</li>
</ol>
<p>诶，写到这里，细心的小伙伴儿们就会问了，那 <code>baseHandlers</code> 这个处理器具体又干了啥嘞？别急别急，我们现在就一起来看一看。</p>
<p>这里的 <code>baseHandlers</code> 实际上是从 <code>reactive</code> 中传过来的 <code>mutableHandlers</code>, 我们来一起看下它的定义：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

const get = createGetter()
const set = createSetter()

export const mutableHandlers = {
  get,
  set
}

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)
    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    return res
  }
}
</code></pre>
<p>从上述代码中不难看出，实际上 <code>mutableHandlers</code> 就是定义了 <code>Proxy</code> 对象的 <code>get</code> 和 <code>set</code> 方法。</p>
<p>回到测试用例中的 <code>expect(observeOriginal.foo).toBe(1)</code> 这个步骤，在获取代理对象的foo属性时，便会触发 <code>get</code> 方法，从而返回属性对应的值。同样，当设置代理对象的foo属性时，便会触发 <code>set</code> 方法，对属性的值做出改变。</p>
<p>写到这里，我们通过一张流程图，来捋一捋 <code>reactive</code> 的流程：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b014fadb17d641048dcd12f01695afaf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>扩展阅读：关于 <code>Proxy</code> 中为啥要用到 <code>Reflect</code>，有兴趣的小伙伴可以参考下 <code>张鑫旭</code> 大佬的这篇文章：<a href="https://www.zhangxinxu.com/wordpress/2021/07/js-proxy-reflect/">Proxy是代理，Reflect是干嘛用的？</a></p>
</blockquote>
<p><strong>综上：<code>reactive</code> 通过 <code>createReactiveObject</code> 方法，返回 <code>target</code> 所对应的 <code>proxy</code> 对象，并对 <code>target</code> 中属性的读取与写入操作做了拦截处理。</strong></p>
<h3 id="reactivity-第二步依赖收集-触发依赖"><code>reactivity</code> 第二步：依赖收集 &amp;&amp; 触发依赖</h3>
<p>现在我们已经知道了如何通过 <code>Proxy</code> 拦截对象的属性操作, 接下来我们一起看下如何实现 <code>依赖收集</code> 与 <code>依赖触发</code>。</p>
<p>老规矩，我们还是先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/effect.spec.ts

import { reactive } from '../reactive'
import { effect } from  '../effect'

describe('effect', () =&gt; {
  it ('should observe basic properties', () =&gt; {
    let dummy = 0
    // 获取proxy对象
    const data = reactive({ num: 0 })
    // ？
    effect(() =&gt; { dummy = data.num })
    expect(dummy).toBe(0)
    // 改变值
    data.num = 1
    expect(dummy).toBe(1)
  })
})
</code></pre>
<p>测试用例中，在调用了 <code>reactive</code> 方法获取到 <code>Proxy</code> 对象后，又调用了 <code>effect</code> 方法。那这个 <code>effect</code> 方法又是干啥的呢？我们先来看下 <code>effect</code> 方法的定义：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * @param fn
 */
export function effect(fn) {
  const reactiveEffect = new ReactiveEffect(fn)
  reactiveEffect.run()
}
</code></pre>
<p>可以看到，<code>effect</code> 接受一个函数作为参数，并且在其内部实例化了一个名为 <code>ReactiveEffect</code> 的类，并将接收到的函数传入这个类中，然后执行 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法。那这个 <code>ReactiveEffect</code> 类又是何方神圣呢？执行 <code>run</code> 又做了什么事情呢？让我们来一探究竟:</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

let activeEffect = void 0

export class ReactiveEffect {
  // 存放所有依赖
  public deps: any = new Set()

  // 初始化依赖列表
  constructor(fn) {
    if (fn) this.deps.add(fn)
  }

  // 执行收集到的所有依赖
  run () {
    activeEffect = this as any
    this.deps.forEach(dep =&gt; dep())
  }
}
</code></pre>
<p>通过上面的代码我们可以得知，<code>ReactiveEffect</code> 类在被实例化时，将接收到的函数存储到自己的 <code>deps</code> 属性中，并且在执行它的 <code>run</code> 方法时，则是遍历自身的 <code>deps</code> 属性，执行其中存储的函数。</p>
<p>由此可知，<strong>借助 <code>ReactiveEffect</code> 类所提供的能力，我们可以将方法保存起来，也可以触发已经被保存起来的方法。</strong></p>
<blockquote>
<p><strong>提问：</strong> 在调用 <code>run</code> 方法时，为什么还要将 <code>this</code> 赋值给全局变量 <code>activeEffect</code> 呢？</p>
</blockquote>
<p>带着这个问题，我们接着往下看。现在，我们已经拥有了 <code>收集方法</code> 以及 <code>触发被保存方法</code> 的能力。那我们又该如何将收集到的方法绑定到对应的对象及其属性上去呢？</p>
<p>我们一起来看下具体的实现：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

const targetMap = new WeakMap()

/**
 * 依赖收集
 * @param target
 * @param type
 * @param key
 */
export function track(target, type, key) {
  // 判断targetMap中是否保存有target对象对应的map
  let depsMap = targetMap.get(target)
  
  // 如果没有，则给该对象新建一个空的map，并绑定到targetMap中
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  
  // 取出target对应的map中，target属性key所对应的依赖
  let dep = depsMap.get(key)
  
  // 如果依赖不存在，则给当前的key创建一个空的依赖集合，并保存到target对象对应的map中
  if (!dep) {
    dep = new Set()
    depsMap.set(key, dep)
  }
  
  // 添加依赖
  dep.add(activeEffect)
}
</code></pre>
<p><code>track</code> 接收三个参数，需要进行 <code>依赖收集</code> 的对象 <code>target</code> 、收集类型 <code>type</code> 以及绑定依赖的 <code>key</code>。具体流程如注释。</p>
<p><strong>注意最后一步中的 <code>添加依赖</code> 操作。</strong> 在这一步骤中，将先前保存有 <code>ReactiveEffect</code> 类的 <code>this</code> 的全局变量添加到了 <code>target</code> 对应属性的依赖中。</p>
<blockquote>
<p><strong>解答：</strong> 回到刚才的提问，之所以要将 <code>ReactiveEffect</code> 的 <code>this</code> 赋值给全局变量，就是在进行 <code>依赖收集</code> 的时候可以将其添加到对应属性的依赖中去。所以 <code>收集依赖</code> 其实就是收集的 <code>ReactiveEffect</code> 的实例。</p>
</blockquote>
<p>现在，我们已经可以成功收集到依赖了，那我们又该如何 <code>触发依赖</code> 呢？</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * 触发依赖
 * @param target
 * @param key
 */
export function trigger(target, key) {
  const depsMap = targetMap.get(target)
  const dep = depsMap.get(key)

  // 遍历执行依赖
  for(const effect of dep) {
    effect.run()
  }
}
</code></pre>
<p>其实依赖的触发很简单，只需要将 <code>key</code> 中保存的 <code>ReactiveEffect</code> 实例都取出来，然后执行它们的 <code>run</code> 方法即可。</p>
<p>现在，我们已经完成了依赖的收集与触发功能，那我们又该在何时 <code>收集</code>，又在何时 <code>触发</code> 呢？</p>
<p>答案是：<strong>在使用时 <code>收集</code>，在改变时 <code>触发</code>。</strong></p>
<p>回到刚才的测试用例中的 <code>effect(() =&gt; { dummy = data.num })</code> 这一步，在调用了 <code>effect</code> 方法后，会通过 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法执行传入的函数，函数中读取了代理对象上的 <code>num</code> 属性，因此会触发 <code>get</code> 方法，在 <code>get</code> 方法中，我们需要进行 <code>依赖收集</code> 的操作；之后通过 <code>data.num = 1</code> 这一步骤，设置 <code>num</code> 属性的值，继而会触发 <code>set</code> 方法，在 <code>set</code> 方法中，我们需要进行 <code>依赖触发</code> 的操作。</p>
<p>综上所述，我们只需要在 <code>get</code> 中加入 <code>track</code> 方法，在 <code>set</code> 中加入 <code>trigger</code> 方法即可：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

// ...省略部分代码

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)

    // 触发依赖收集
    track(target, 'get', key)

    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return res
  }
}
</code></pre>
<p>最后，我们将 <code>依赖收集</code> 与 <code>依赖触发</code> 的流程补充到先前的流程图中去，来完成的看下响应式的流程吧：</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23ce7a3145b4e3f8580958b8a82297a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，我们已经完成了基本的响应式操作，也捋清了其中的基本原理。如果有描述不当之处，还请各位大佬帮忙指正~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Gridea + Valine搭建属于自己的博客]]></title>
        <id>https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/</id>
        <link href="https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/">
        </link>
        <updated>2021-12-24T17:15:10.000Z</updated>
        <summary type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
<!-- more -->
<h1 id="通过gridea快速搭建博客">通过Gridea快速搭建博客</h1>
<pre><code>Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。
</code></pre>
<p>以上是 <a href="https://gridea.dev/">Gridea</a> 官方对这款博客客户端的描述。它到底有多容易呢？那我们就自己动手来试下吧~</p>
<h2 id="简单两步完成博客搭建">简单两步，完成博客搭建</h2>
<h3 id="第一步下载gridea客户端">第一步：下载Gridea客户端</h3>
<p><code>Gridea</code> 客户端是使用 <code>Electron</code> 开发的，使用它之前，需要先去 <a href="https://gridea.dev/#started">官网下载</a>。官方提供了 <code>MacOS</code>, <code>Windows</code> 以及 <code>Linux</code> 三端的安装包，小伙伴们可以根据自己的需求自行下载~<br>
<img src="https://luhaifeng666.github.io/post-images/1640367698849.jpg" alt="" loading="lazy"></p>
<h3 id="第二步发布">第二步：发布</h3>
<p>是的！你没有听错！下载完成后直接就可以进入发布流程了，是不是很快！<br>
<code>Gridea</code> 提供了将博客部署到 <code>GitHub Pages</code>、<code>Coding Pages</code> 和通过 <code>SFTP</code> 的方式上传到自己的服务器的功能。官方提供了非常详细的Github Pages发布流程，这里不做赘述，<a href="https://gridea.dev/gridea-start/">请戳进来看吧~</a></p>
<h2 id="一些可能需要注意的点">一些可能需要注意的点</h2>
<p>经过上面两步的操作，相信各个小伙伴已经拥有了属于自己的博客~可喜可贺！在这里，我列举几个我遇到的问题，希望可以提供给遇到相同问题的小伙伴一些帮助：</p>
<h4 id="问题1关于同步">问题1：关于同步</h4>
<ul>
<li>由于同步是将你的改动同步到 <code>GitHub Pages</code> 上的，由于现阶段国内访问Github会有长时间打不开页面，需要翻墙的情况，建议小伙伴们在长时间无法同步的情况下，尝试下翻墙同步，可能会稍好一些；</li>
<li>我当前使用的 <code>Gridea</code> 的版本是 <code>0.9.2</code>，存在这样一个问题，在检测远程连接时，提示我连接成功，但是同步却一直都失败，无论是否开启翻墙，均是如此。官方在 <a href="https://github.com/getgridea/gridea/issues/890">#890</a> 这个issue中提供了一个解决方案，并给出了修复后的包的下载地址，我下载后使用并不理想（不排除是我本地网络环境的原因），但依旧可以作为一个解决方案提供给小伙伴们尝试下~</li>
</ul>
<h4 id="问题2关于主题">问题2：关于主题</h4>
<p>目前我使用的是 <code>Simple</code> 主题，各方面使用情况都还不错，推荐大家使用这款。<br>
当然，官方也提供了其他的 <a href="https://gridea.dev/themes">多款主题</a> 供小伙伴们食用，大家可以根据自己的喜好自行选择。<br>
如果有精力有兴趣的小伙伴儿们也可以尝试自己 <a href="https://gridea.dev/theme/">开发一个主题</a> ，毕竟自己动手，丰衣足食嘛~<br>
至于我遇到的问题，是在我使用 <code>Notes</code> 这个主题的时候，发现在编辑完文章后，markdown中的代码区块内容在预览时表现正常，但是在同步到 <code>GitHub Pages</code> 之后，打开页面发现markdown中的代码区块没有正常渲染出来，大家在食用的时候需要留意下~</p>
<h1 id="添加vline评论">添加Vline评论</h1>
<p>现在已经有了自己的博客了，也有个地方可以记录自己的工作，学习，生活了，自然也不能少了让 <code>看官们</code> 留下自己足迹的地方~<br>
我使用的 <code>Simple</code> 主题默认提供了两种发布评论的平台：<br>
<img src="https://luhaifeng666.github.io/post-images/1640368636573.jpg" alt="" loading="lazy"><br>
这里我推荐使用 <a href="https://valine.js.org/">Valine</a>，想对于上述的两个而言，它更加友好。至于接入方式，官方也给出了相应的 <a href="https://kveln.cn/post/qE678A4ce/">参考文档</a>。这里我针对官方的文档做一些补充说明以及踩坑的经验分享。</p>
<h2 id="关于文档中的说明">关于文档中的说明</h2>
<p>在官方提供的文档中有这么一处说明：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369031378.png" alt="" loading="lazy"><br>
其中，<code>Valine.min.js</code> 的引入需要放在对应主题的 <code>post.ejs</code> 模板下。</p>
<h2 id="关于leancloud的配置">关于LeanCloud的配置</h2>
<h3 id="创建class">创建Class</h3>
<p>评论会调用 <code>LeanCloud</code> 提供的数据接口，其中有个接口是获取评论总数的：<code>https://xxxx/1.1/classes/Comment</code>。调用这个接口的前提，是需要在 <code>数据存储 &gt; 结构化数据</code> 下手动创建一个名为 <code>Comment</code> 的class，否则接口会报404，这个需要注意下：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369813288.png" alt="" loading="lazy"></p>
<h3 id="创建应用">创建应用</h3>
<p>创建应用时，可以选择创建区域:<br>
<img src="https://luhaifeng666.github.io/post-images/1640369444506.png" alt="" loading="lazy"><br>
我这里选择的是 <code>华东</code>。之所以选择华东，是因为在华北创建完应用后，在调用接口时调不通，这可能跟我所处的区域有关。所以小伙伴们在创建完成之后，可以去 <code>设置 &gt; 应用凭证</code> 中，访问下提供的 <code>REST API 服务器地址</code> ，看看是不是可以调通，可以的话就没有问题。如果不行的话，建议切换下区域重新创建一个应用：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369984692.png" alt="" loading="lazy"></p>
<h1 id="写在最后">写在最后</h1>
<p>以上是我在使用 <code>Gridea + Vline</code> 搭建自己博客的时候所遇到的问题，希望对看到这篇文章的小伙伴有所帮助。<br>
当前博客已部署，以后会陆续分享自己的学习笔记以及心得琐碎等等。感兴趣的小伙伴欢迎<a href="https://luhaifeng666.github.io/">戳~</a>。<br>
现在快动起手来，快速搭建一个属于自己的天地吧~</p>
]]></content>
    </entry>
</feed>