<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luhaifeng666.github.io</id>
    <title>酱豆腐精的小站</title>
    <updated>2022-01-12T03:14:25.211Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luhaifeng666.github.io"/>
    <link rel="self" href="https://luhaifeng666.github.io/atom.xml"/>
    <subtitle>我吹，你听</subtitle>
    <logo>https://luhaifeng666.github.io/images/avatar.png</logo>
    <icon>https://luhaifeng666.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 酱豆腐精的小站</rights>
    <entry>
        <title type="html"><![CDATA[半透明边框]]></title>
        <id>https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/</id>
        <link href="https://luhaifeng666.github.io/post/ban-tou-ming-bian-kuang/">
        </link>
        <updated>2022-01-12T02:34:10.000Z</updated>
        <summary type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
]]></summary>
        <content type="html"><![CDATA[<p>《CSS秘密花园》学习笔记：半透明边框。</p>
<!-- more -->
<p>我们在想实现一个透明边框的时候，通常想到的可能是以下代码：</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
</code></pre>
<p>可是如果这时候给元素添加一个背景色或者背景图片，背景图片与背景色会透过透明边框显示出来。这是因为<strong>在默认情况下,背景会延伸到边框所在区域的下层。</strong></p>
<p>举个<a href="https://codepen.io/luhaifeng666/pen/MWEzyag?editors=1111">栗子</a></p>
<p>通过这个例子我们可以看到，元素的背景色被设置为蓝色，背景色设置为<code>rgba(255,255,255,.6)</code> ,此时，透过透明边框可以看到元素的背景色。</p>
<h3 id="解决办法">解决办法</h3>
<p>通过添加background-clip可以解决。</p>
<pre><code class="language-css">border: 3px solid rgba(255,255,255,0.6);
background-clip: padding-box;
</code></pre>
<blockquote>
<p>background-clip属性是用来设置背景裁剪区域的，该属性接受三个参数：content-box | padding-box | border-box | text，裁剪区域如下：</p>
<ol>
<li>content-box: content部分，背景被裁剪至内容区（content box）外沿。</li>
<li>padding-box: content + padding部分，背景延伸至内边距（padding）外沿。不会绘制到边框处。</li>
<li>border-box: content + padding + border部分，背景延伸至边框外沿（但是在边框下层）。</li>
<li>text: 裁剪为text前景色</li>
</ol>
</blockquote>
<p>具体用法可以参考MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip">background-clip</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mini-vue学习：reactivity 的核心流程]]></title>
        <id>https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/</id>
        <link href="https://luhaifeng666.github.io/post/mini-vue-xue-xi-reactivity-de-he-xin-liu-cheng/">
        </link>
        <updated>2021-12-29T12:38:48.000Z</updated>
        <summary type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过这篇文章，我们一起来学习下，在 <code>vue3</code> 中，数据的响应式是如何实现的。</p>
<!-- more -->
<h2 id="写在开始">写在开始</h2>
<p>在正式开始学习之前，我们先一起来了解一个思想：<code>TDD</code>。什么是 <code>TDD</code> 呢？我们先来看下它的概念：</p>
<pre><code>TDD是测试驱动开发（Test-Driven Development）的英文简称。
它是敏捷开发中的一项核心实践和技术，也是一种设计方法论。
TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。
TDD虽是敏捷方法的核心实践，但不只适用于XP（Extreme Programming），同样可以适用于其他开发方法和过程。
</code></pre>
<p>简而言之，就是 <code>测试驱动开发</code>，在动手开发之前先写好测试用例，然后再进行开发。<br><br>
在接下来的学习过程中，<code>TDD</code> 的思想将贯穿始终。话不多说，让我们一起进入vue3的源码学习吧~</p>
<blockquote>
<p><strong>声明：</strong><br><br>
笔记中的内容来源于 <strong>崔大(wx: cuixr1314)</strong> 的 <a href="https://github.com/cuixiaorui/mini-vue">mini-vue</a> 教学，目前已经 <code>4k+</code>的⭐️了，欢迎大家踊跃star~<br><br>
热爱学习的小伙伴们，可以搜索 <code>催学社</code> 微信群，里面都是一群热爱学习的小伙伴，学习氛围一级棒！期待你的加入~<br><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab46bb312db444c8352d44cbe9f4c70~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></p>
</blockquote>
<h2 id="正文开始">正文开始</h2>
<p>我们知道，不论是在 <code>vue2</code> 中，还是在 <code>vue3</code> 中， <code>响应式数据</code> 一直都是vue的核心概念。这一节，我们也先从 <code>响应式数据</code> 开始说起。</p>
<h3 id="vue2-与-vue3-中对响应式数据处理的区别">vue2 与 vue3 中对响应式数据处理的区别</h3>
<p>熟悉 <code>vue2</code> 的小伙伴儿们都知道，在 <code>vue2</code> 中，数据的响应式是通过 <code>Object.defineProperty</code> 来实现的。针对对象，通过遍历对象的属性，来设置属性对应的 <code>getter</code> 以及 <code>setter</code> 方法，以达到 <code>依赖收集</code> 与 <code>触发依赖</code> 的目的；<br>
而针对数组，则是通过重写数组一系列更新元素的方法来实现对数组元素修改的劫持。<br><br>
但是通过这种方式来实现数据响应式，存在以下几个问题：</p>
<pre><code>1. 对象直接新添加新的属性，或者删除已有的属性, 界面不会自动更新；
2. 直接通过替换数组对应下标的元素，或者更新数组的length, 界面也不会自动更新；
3. 如果对象的属性较多，且嵌套层次较深时，需要深度遍历，循环量大，性能损耗较大。
</code></pre>
<p>针对以上几个问题，<code>vue3</code> 中使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 来代替 <code>Object.defineProperty</code>。<br><br>
针对 <code>问题1</code> 和 <code>问题3</code>，<code>Proxy</code> 代理了整个对象，并且提供了多达13种对对象属性的操作（如属性查找、赋值、枚举、函数调用等），在对象发生变化时，<code>Proxy</code> 都可以进行捕获，与 <code>Object.defineProperty</code> 不同，无需遍历所有属性；<br><br>
针对 <code>问题2</code>，<code>Proxy</code> 对数组的监听相较于 <code>Object.defineProperty</code> 性能更优。具体大家可以参考 <a href="https://cloud.tencent.com/developer/news/485729">这篇文章</a> 。<br></p>
<p>那在 <code>vue3</code> 中具体是如何通过 <code>Proxy</code> 的方式实现响应式的呢？</p>
<h3 id="reactivity-第一步reactive"><code>reactivity</code> 第一步：reactive</h3>
<blockquote>
<p><strong>注：</strong> <br><br>
本文以 vue3 中的 <code>reactive</code> 为例，如果对 <code>reactive</code> 操作尚不熟悉的同学可以看下 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html">这篇文档</a>。至于 <code>ref</code>，其底层也是 <code>reactive</code>, 关于 <code>ref</code> 的内容，在完成 <code>reactive</code> 所有相关功能的梳理后，后续的文章中会做补充，这里先埋个伏笔~（手动🌺🐔）</p>
</blockquote>
<p>还记得开篇时提到的 <code>TDD</code> 么？开始之前，我们先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/reactive.spec.ts

import { reactive } from '../reactive'

describe('reactive', () =&gt; {
  it ('happy path', () =&gt; {
    const original = { foo: 1 }
    // 创建Proxy代理对象
    const observeOriginal = reactive(original)
    // 响应式对象与原对象应该不相等，因为observeOriginal被Proxy包裹
    expect(observeOriginal).not.toBe(original)
    // 取值
    expect(observeOriginal.foo).toBe(1)
  })
})
</code></pre>
<p>测试用例中， <code>reactive</code> 将传入的对象转换成 <code>Proxy</code> 代理对象，之后通过代理对象来获取其中的值。既然如此，那我们就从 <code>reactive</code> 入手。先来看下 <code>reactive</code> 的定义：</p>
<pre><code class="language-ts">// src/reactivity/reactive.ts

import { mutableHandlers } from './baseHandlers'

export const reactiveMap = new WeakMap()

/**
 * 创建reactive对象
 * @param target
 */
export function reactive (target) {
  return createReactiveObject(target, reactiveMap, mutableHandlers)
}

/**
 * 创建响应式对象
 * @param target
 * @param proxyMap
 * @param baseHandlers
 */
export function createReactiveObject (target, proxyMap, baseHandlers) {
  // 判断proxy是否已经保存过
  if (proxyMap.has(target)) {
    // 如果存在，则返回
    return proxyMap.get(target)
  }

  const proxy = new Proxy(target, baseHandlers)

  // 存储创建好的proxy
  proxyMap.set(target, proxy)
  return proxy
}
</code></pre>
<p>从上述代码可以看出，<code>reactive</code> 中调用了 <code>createReactiveObject</code> 方法，既然 <code>reactive</code> 方法是用来返回 <code>Proxy</code> 对象的，那在 <code>createReactiveObject</code> 中又发生了什么呢？我们一起来分析一下：</p>
<ol>
<li><code>createReactiveObject</code> 接收三个参数：需要被代理的对象 <code>target</code>, 也就是在 <code>reactive</code> 接收的 <code>target</code> 参数、用于存储 <code>Proxy</code> 对象的 <code>proxyMap</code> 以及 <code>Proxy</code> 对象的处理器 <code>baseHandlers</code>;</li>
<li>先判断在 <code>proxyMap</code> 是否已经存在当前对象所对应的 <code>Proxy</code> 对象，如果存在，则直接返回, 否则新建一个 <code>Proxy</code> 对象，并以当前的 <code>target</code> 为key，存储到 <code>proxyMap</code>，以便下次取用，并将新建的 <code>Proxy</code> 返回。</li>
</ol>
<p>诶，写到这里，细心的小伙伴儿们就会问了，那 <code>baseHandlers</code> 这个处理器具体又干了啥嘞？别急别急，我们现在就一起来看一看。</p>
<p>这里的 <code>baseHandlers</code> 实际上是从 <code>reactive</code> 中传过来的 <code>mutableHandlers</code>, 我们来一起看下它的定义：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

const get = createGetter()
const set = createSetter()

export const mutableHandlers = {
  get,
  set
}

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)
    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    return res
  }
}
</code></pre>
<p>从上述代码中不难看出，实际上 <code>mutableHandlers</code> 就是定义了 <code>Proxy</code> 对象的 <code>get</code> 和 <code>set</code> 方法。</p>
<p>回到测试用例中的 <code>expect(observeOriginal.foo).toBe(1)</code> 这个步骤，在获取代理对象的foo属性时，便会触发 <code>get</code> 方法，从而返回属性对应的值。同样，当设置代理对象的foo属性时，便会触发 <code>set</code> 方法，对属性的值做出改变。</p>
<p>写到这里，我们通过一张流程图，来捋一捋 <code>reactive</code> 的流程：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b014fadb17d641048dcd12f01695afaf~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<p>扩展阅读：关于 <code>Proxy</code> 中为啥要用到 <code>Reflect</code>，有兴趣的小伙伴可以参考下 <code>张鑫旭</code> 大佬的这篇文章：<a href="https://www.zhangxinxu.com/wordpress/2021/07/js-proxy-reflect/">Proxy是代理，Reflect是干嘛用的？</a></p>
</blockquote>
<p><strong>综上：<code>reactive</code> 通过 <code>createReactiveObject</code> 方法，返回 <code>target</code> 所对应的 <code>proxy</code> 对象，并对 <code>target</code> 中属性的读取与写入操作做了拦截处理。</strong></p>
<h3 id="reactivity-第二步依赖收集-触发依赖"><code>reactivity</code> 第二步：依赖收集 &amp;&amp; 触发依赖</h3>
<p>现在我们已经知道了如何通过 <code>Proxy</code> 拦截对象的属性操作, 接下来我们一起看下如何实现 <code>依赖收集</code> 与 <code>依赖触发</code>。</p>
<p>老规矩，我们还是先从测试用例入手：</p>
<pre><code class="language-ts">// src/reactivity/__tests__/effect.spec.ts

import { reactive } from '../reactive'
import { effect } from  '../effect'

describe('effect', () =&gt; {
  it ('should observe basic properties', () =&gt; {
    let dummy = 0
    // 获取proxy对象
    const data = reactive({ num: 0 })
    // ？
    effect(() =&gt; { dummy = data.num })
    expect(dummy).toBe(0)
    // 改变值
    data.num = 1
    expect(dummy).toBe(1)
  })
})
</code></pre>
<p>测试用例中，在调用了 <code>reactive</code> 方法获取到 <code>Proxy</code> 对象后，又调用了 <code>effect</code> 方法。那这个 <code>effect</code> 方法又是干啥的呢？我们先来看下 <code>effect</code> 方法的定义：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * @param fn
 */
export function effect(fn) {
  const reactiveEffect = new ReactiveEffect(fn)
  reactiveEffect.run()
}
</code></pre>
<p>可以看到，<code>effect</code> 接受一个函数作为参数，并且在其内部实例化了一个名为 <code>ReactiveEffect</code> 的类，并将接收到的函数传入这个类中，然后执行 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法。那这个 <code>ReactiveEffect</code> 类又是何方神圣呢？执行 <code>run</code> 又做了什么事情呢？让我们来一探究竟:</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

let activeEffect = void 0

export class ReactiveEffect {
  // 存放所有依赖
  public deps: any = new Set()

  // 初始化依赖列表
  constructor(fn) {
    if (fn) this.deps.add(fn)
  }

  // 执行收集到的所有依赖
  run () {
    activeEffect = this as any
    this.deps.forEach(dep =&gt; dep())
  }
}
</code></pre>
<p>通过上面的代码我们可以得知，<code>ReactiveEffect</code> 类在被实例化时，将接收到的函数存储到自己的 <code>deps</code> 属性中，并且在执行它的 <code>run</code> 方法时，则是遍历自身的 <code>deps</code> 属性，执行其中存储的函数。</p>
<p>由此可知，<strong>借助 <code>ReactiveEffect</code> 类所提供的能力，我们可以将方法保存起来，也可以触发已经被保存起来的方法。</strong></p>
<blockquote>
<p><strong>提问：</strong> 在调用 <code>run</code> 方法时，为什么还要将 <code>this</code> 赋值给全局变量 <code>activeEffect</code> 呢？</p>
</blockquote>
<p>带着这个问题，我们接着往下看。现在，我们已经拥有了 <code>收集方法</code> 以及 <code>触发被保存方法</code> 的能力。那我们又该如何将收集到的方法绑定到对应的对象及其属性上去呢？</p>
<p>我们一起来看下具体的实现：</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

const targetMap = new WeakMap()

/**
 * 依赖收集
 * @param target
 * @param type
 * @param key
 */
export function track(target, type, key) {
  // 判断targetMap中是否保存有target对象对应的map
  let depsMap = targetMap.get(target)
  
  // 如果没有，则给该对象新建一个空的map，并绑定到targetMap中
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  
  // 取出target对应的map中，target属性key所对应的依赖
  let dep = depsMap.get(key)
  
  // 如果依赖不存在，则给当前的key创建一个空的依赖集合，并保存到target对象对应的map中
  if (!dep) {
    dep = new Set()
    depsMap.set(key, dep)
  }
  
  // 添加依赖
  dep.add(activeEffect)
}
</code></pre>
<p><code>track</code> 接收三个参数，需要进行 <code>依赖收集</code> 的对象 <code>target</code> 、收集类型 <code>type</code> 以及绑定依赖的 <code>key</code>。具体流程如注释。</p>
<p><strong>注意最后一步中的 <code>添加依赖</code> 操作。</strong> 在这一步骤中，将先前保存有 <code>ReactiveEffect</code> 类的 <code>this</code> 的全局变量添加到了 <code>target</code> 对应属性的依赖中。</p>
<blockquote>
<p><strong>解答：</strong> 回到刚才的提问，之所以要将 <code>ReactiveEffect</code> 的 <code>this</code> 赋值给全局变量，就是在进行 <code>依赖收集</code> 的时候可以将其添加到对应属性的依赖中去。所以 <code>收集依赖</code> 其实就是收集的 <code>ReactiveEffect</code> 的实例。</p>
</blockquote>
<p>现在，我们已经可以成功收集到依赖了，那我们又该如何 <code>触发依赖</code> 呢？</p>
<pre><code class="language-ts">// src/reactivity/effect.ts

/**
 * 触发依赖
 * @param target
 * @param key
 */
export function trigger(target, key) {
  const depsMap = targetMap.get(target)
  const dep = depsMap.get(key)

  // 遍历执行依赖
  for(const effect of dep) {
    effect.run()
  }
}
</code></pre>
<p>其实依赖的触发很简单，只需要将 <code>key</code> 中保存的 <code>ReactiveEffect</code> 实例都取出来，然后执行它们的 <code>run</code> 方法即可。</p>
<p>现在，我们已经完成了依赖的收集与触发功能，那我们又该在何时 <code>收集</code>，又在何时 <code>触发</code> 呢？</p>
<p>答案是：<strong>在使用时 <code>收集</code>，在改变时 <code>触发</code>。</strong></p>
<p>回到刚才的测试用例中的 <code>effect(() =&gt; { dummy = data.num })</code> 这一步，在调用了 <code>effect</code> 方法后，会通过 <code>ReactiveEffect</code> 类上提供的 <code>run</code> 方法执行传入的函数，函数中读取了代理对象上的 <code>num</code> 属性，因此会触发 <code>get</code> 方法，在 <code>get</code> 方法中，我们需要进行 <code>依赖收集</code> 的操作；之后通过 <code>data.num = 1</code> 这一步骤，设置 <code>num</code> 属性的值，继而会触发 <code>set</code> 方法，在 <code>set</code> 方法中，我们需要进行 <code>依赖触发</code> 的操作。</p>
<p>综上所述，我们只需要在 <code>get</code> 中加入 <code>track</code> 方法，在 <code>set</code> 中加入 <code>trigger</code> 方法即可：</p>
<pre><code class="language-ts">// src/reactivity/baseHandlers.ts

// ...省略部分代码

export function createGetter () {
  return function (target, key, receiver) {
    const res =  Reflect.get(target, key, receiver)

    // 触发依赖收集
    track(target, 'get', key)

    return res
  }
}

export function createSetter () {
  return function (target, key, value, receiver) {
    const res = Reflect.set(target, key, value, receiver)
    trigger(target, key)
    return res
  }
}
</code></pre>
<p>最后，我们将 <code>依赖收集</code> 与 <code>依赖触发</code> 的流程补充到先前的流程图中去，来完成的看下响应式的流程吧：</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23ce7a3145b4e3f8580958b8a82297a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，我们已经完成了基本的响应式操作，也捋清了其中的基本原理。如果有描述不当之处，还请各位大佬帮忙指正~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Gridea + Valine搭建属于自己的博客]]></title>
        <id>https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/</id>
        <link href="https://luhaifeng666.github.io/post/shi-yong-gridea-vline-da-jian-shu-yu-zi-ji-de-bo-ke/">
        </link>
        <updated>2021-12-24T17:15:10.000Z</updated>
        <summary type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前搭建博客都是通过 <code>vuepress</code> + <code>Github Pages</code> 的方式，虽然也很方便，但是如果有个可视化可编辑的博客界面，可以做许多个性化的定制，岂不不是美滋滋~（手动🌺🐔）</p>
<!-- more -->
<h1 id="通过gridea快速搭建博客">通过Gridea快速搭建博客</h1>
<pre><code>Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。
</code></pre>
<p>以上是 <a href="https://gridea.dev/">Gridea</a> 官方对这款博客客户端的描述。它到底有多容易呢？那我们就自己动手来试下吧~</p>
<h2 id="简单两步完成博客搭建">简单两步，完成博客搭建</h2>
<h3 id="第一步下载gridea客户端">第一步：下载Gridea客户端</h3>
<p><code>Gridea</code> 客户端是使用 <code>Electron</code> 开发的，使用它之前，需要先去 <a href="https://gridea.dev/#started">官网下载</a>。官方提供了 <code>MacOS</code>, <code>Windows</code> 以及 <code>Linux</code> 三端的安装包，小伙伴们可以根据自己的需求自行下载~<br>
<img src="https://luhaifeng666.github.io/post-images/1640367698849.jpg" alt="" loading="lazy"></p>
<h3 id="第二步发布">第二步：发布</h3>
<p>是的！你没有听错！下载完成后直接就可以进入发布流程了，是不是很快！<br>
<code>Gridea</code> 提供了将博客部署到 <code>GitHub Pages</code>、<code>Coding Pages</code> 和通过 <code>SFTP</code> 的方式上传到自己的服务器的功能。官方提供了非常详细的Github Pages发布流程，这里不做赘述，<a href="https://gridea.dev/gridea-start/">请戳进来看吧~</a></p>
<h2 id="一些可能需要注意的点">一些可能需要注意的点</h2>
<p>经过上面两步的操作，相信各个小伙伴已经拥有了属于自己的博客~可喜可贺！在这里，我列举几个我遇到的问题，希望可以提供给遇到相同问题的小伙伴一些帮助：</p>
<h4 id="问题1关于同步">问题1：关于同步</h4>
<ul>
<li>由于同步是将你的改动同步到 <code>GitHub Pages</code> 上的，由于现阶段国内访问Github会有长时间打不开页面，需要翻墙的情况，建议小伙伴们在长时间无法同步的情况下，尝试下翻墙同步，可能会稍好一些；</li>
<li>我当前使用的 <code>Gridea</code> 的版本是 <code>0.9.2</code>，存在这样一个问题，在检测远程连接时，提示我连接成功，但是同步却一直都失败，无论是否开启翻墙，均是如此。官方在 <a href="https://github.com/getgridea/gridea/issues/890">#890</a> 这个issue中提供了一个解决方案，并给出了修复后的包的下载地址，我下载后使用并不理想（不排除是我本地网络环境的原因），但依旧可以作为一个解决方案提供给小伙伴们尝试下~</li>
</ul>
<h4 id="问题2关于主题">问题2：关于主题</h4>
<p>目前我使用的是 <code>Simple</code> 主题，各方面使用情况都还不错，推荐大家使用这款。<br>
当然，官方也提供了其他的 <a href="https://gridea.dev/themes">多款主题</a> 供小伙伴们食用，大家可以根据自己的喜好自行选择。<br>
如果有精力有兴趣的小伙伴儿们也可以尝试自己 <a href="https://gridea.dev/theme/">开发一个主题</a> ，毕竟自己动手，丰衣足食嘛~<br>
至于我遇到的问题，是在我使用 <code>Notes</code> 这个主题的时候，发现在编辑完文章后，markdown中的代码区块内容在预览时表现正常，但是在同步到 <code>GitHub Pages</code> 之后，打开页面发现markdown中的代码区块没有正常渲染出来，大家在食用的时候需要留意下~</p>
<h1 id="添加vline评论">添加Vline评论</h1>
<p>现在已经有了自己的博客了，也有个地方可以记录自己的工作，学习，生活了，自然也不能少了让 <code>看官们</code> 留下自己足迹的地方~<br>
我使用的 <code>Simple</code> 主题默认提供了两种发布评论的平台：<br>
<img src="https://luhaifeng666.github.io/post-images/1640368636573.jpg" alt="" loading="lazy"><br>
这里我推荐使用 <a href="https://valine.js.org/">Valine</a>，想对于上述的两个而言，它更加友好。至于接入方式，官方也给出了相应的 <a href="https://kveln.cn/post/qE678A4ce/">参考文档</a>。这里我针对官方的文档做一些补充说明以及踩坑的经验分享。</p>
<h2 id="关于文档中的说明">关于文档中的说明</h2>
<p>在官方提供的文档中有这么一处说明：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369031378.png" alt="" loading="lazy"><br>
其中，<code>Valine.min.js</code> 的引入需要放在对应主题的 <code>post.ejs</code> 模板下。</p>
<h2 id="关于leancloud的配置">关于LeanCloud的配置</h2>
<h3 id="创建class">创建Class</h3>
<p>评论会调用 <code>LeanCloud</code> 提供的数据接口，其中有个接口是获取评论总数的：<code>https://xxxx/1.1/classes/Comment</code>。调用这个接口的前提，是需要在 <code>数据存储 &gt; 结构化数据</code> 下手动创建一个名为 <code>Comment</code> 的class，否则接口会报404，这个需要注意下：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369813288.png" alt="" loading="lazy"></p>
<h3 id="创建应用">创建应用</h3>
<p>创建应用时，可以选择创建区域:<br>
<img src="https://luhaifeng666.github.io/post-images/1640369444506.png" alt="" loading="lazy"><br>
我这里选择的是 <code>华东</code>。之所以选择华东，是因为在华北创建完应用后，在调用接口时调不通，这可能跟我所处的区域有关。所以小伙伴们在创建完成之后，可以去 <code>设置 &gt; 应用凭证</code> 中，访问下提供的 <code>REST API 服务器地址</code> ，看看是不是可以调通，可以的话就没有问题。如果不行的话，建议切换下区域重新创建一个应用：<br>
<img src="https://luhaifeng666.github.io/post-images/1640369984692.png" alt="" loading="lazy"></p>
<h1 id="写在最后">写在最后</h1>
<p>以上是我在使用 <code>Gridea + Vline</code> 搭建自己博客的时候所遇到的问题，希望对看到这篇文章的小伙伴有所帮助。<br>
当前博客已部署，以后会陆续分享自己的学习笔记以及心得琐碎等等。感兴趣的小伙伴欢迎<a href="https://luhaifeng666.github.io/">戳~</a>。<br>
现在快动起手来，快速搭建一个属于自己的天地吧~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记一：一些基础知识]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-yi-yi-xie-ji-chu-zhi-shi/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-yi-yi-xie-ji-chu-zhi-shi/">
        </link>
        <updated>2021-12-24T08:44:20.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常开发过程中，相信大家都会使用到脚手架，比如 <code>vue-cli</code> 等等。诚然，脚手架可以让我们的日常开发更加便利，但是久而久之，逐渐依赖脚手架进行开发的我们，可能会对一些工具的使用逐渐生疏，比如 <code>webpack</code> 。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常开发过程中，相信大家都会使用到脚手架，比如 <code>vue-cli</code> 等等。诚然，脚手架可以让我们的日常开发更加便利，但是久而久之，逐渐依赖脚手架进行开发的我们，可能会对一些工具的使用逐渐生疏，比如 <code>webpack</code> 。</p>
<!-- more -->
<p>尤其在公司的技术栈日趋稳定之后，我们手动配置 <code>webpack</code> 的机会就越来越少，我就是如此...Orz。所以借此机会，我决定再重头学习一遍这个熟悉而又有点陌生的工具，并将笔记做一个梳理，希望对同样有此感触，或者想学习 <code>webpack</code> 的小伙伴们有所帮助~</p>
<p>此处主子镇楼~</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456b7108fbd64ed8b270b7287cb4b364~tplv-k3u1fbpfcp-watermark.awebp" alt="主子" loading="lazy"></figure>
<blockquote>
<p>本章节及后面的章节使用的webpack及webpack-cli的版本如下：<br><br>
<code>&quot;webpack&quot;: &quot;4.41.6&quot;</code> <br><br>
<code>&quot;webpack-cli&quot;: &quot;3.3.11&quot;</code></p>
</blockquote>
<p>在开始学习<code>webpack</code>之前，我们先来了解一下与之相关的一些基础知识。</p>
<h1 id="构建工具的概念">构建工具的概念</h1>
<p>通俗点来说，构建工具就是包含一系列小工具的大工具。<br><br>
我们来举个🌰：比如我们需要将less、sass等css预处理器写的代码编译成正常的css代码，则需要相应的编译工具；而需要将ES6+的代码转换为兼容性更高的ES5的代码，也需要相应的编译工具。而将诸如此类的小工具包含起来的大工具，就叫 <code>构建工具</code> (比如我们接下来要学习的 <code>webpack</code> 就是构建工具)。在构建工具中,我们可以处理所有的这些操作。</p>
<h1 id="静态模块打包器的概念">静态模块打包器的概念</h1>
<p>这个概念里主要分为两个小的概念，即 <code>静态模块</code> 与 <code>打包</code>。<br><br>
我们来看下如下代码：</p>
<pre><code class="language-js">// main.js
import $ from 'Jquery'
import './less/common.less'
</code></pre>
<p>我们在入口文件中引入了两个模块，webpack在打包的时候，会先生成对应的依赖关系，即在 <code>main.js</code> 中引入了 <code>Jquery</code> 以及<code>common.less</code> 两个模块：<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463c25df4e2e4c06a694a61c0b4cb717~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
其中 <code>main.js</code> , <code>Jquery</code> , <code>common.less</code> 称为 <code>（静态）模块</code>，也叫做 <code>chunk</code> ，含义就是代码块; 之后webpack会对chunk代码块进行处理，将less以及ES6语法做转换，转换成浏览器可识别的内容，这个过程叫做<code>打包</code>。打包完成后，输出的文件称之为 <code>bundle</code>。</p>
<h1 id="webpack的五个核心概念"><a href="https://www.webpackjs.com/concepts/">Webpack的五个核心概念</a></h1>
<ol>
<li>entry：指示webpack从哪个入口开始打包，分析并构建内部依赖图。</li>
<li>output：指示webpack打包之后的bundle文件生成到哪里去。</li>
<li>loader：webpack只能处理js内容，loader的作用就是将非js的内容（比如css/image）转换成webpack可以识别的内容。</li>
<li>plugins：相较于loader只能用作代码翻译，plugins可以做更多复杂强大的事情。</li>
<li>mode：主要分为development以及production模式。相较于生产模式，开发模式的配置会比较简单，具体的区别可以参照下表：<br>
| 环境 | 描述 | 特点 |<br>
| ------ | ------ | ------ |<br>
| development | 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>。<br>启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code>。  | 能本地调试 |<br>
| production | 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>。<br>启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>。 | 能优化生产环境的代码 |</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记二：Webpack初体验]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-er-webpack-chu-ti-yan/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-er-webpack-chu-ti-yan/">
        </link>
        <updated>2021-12-24T08:43:24.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>webpack的使用依托于nodejs，本文及之后的篇幅里，使用的node版本为：<code>10.17.0</code>。</p>
</blockquote>
<h1 id="初始化node项目">初始化node项目</h1>
<p>开始之前，切换到存放项目的路径，在本地目录下初始化一个node项目，本文是在 <code>webpack-study</code> 目录下。初始化的命令如下：</p>
<pre><code class="language-js">cd webpack-study
npm init
</code></pre>
<p>根据步骤设置下项目名称等一些基础信息，其他的步骤按照默认配置一路回车到底即可。创建完成后，在 <code>webpack-study</code> 目录下会生成最基本的package.json文件。</p>
<h1 id="创建代码目录">创建代码目录</h1>
<p>在 <code>webpack-study</code> 目录下创建 <code>src</code> 目录，用于存放源代码。并在src下创建index.js作为入口文件，这里先写一段简单的代码用作示例：</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y
console.log(add(1, 2))
</code></pre>
<h1 id="安装webpack">安装Webpack</h1>
<pre><code class="language-js">npm i webpack webpack-cli
</code></pre>
<p>这里除了用到 <code>webpack</code> ，我们也会用到 <code>webpack-cli</code>, 它是webpack的脚手架。</p>
<h1 id="创建webpack配置文件">创建Webpack配置文件</h1>
<p>想要使用webpack对资源进行打包，首先我们需要配置下webpack的配置文件。我们在项目根目录下创建 <code>webpack.config.js</code> 文件。上一篇中，我们提到webpack的5个基本概念，(如果印象不是很深的小伙伴可以回看：<a href="https://juejin.cn/post/6902441939560300558#heading-3">Webpack学习笔记一：一些基础知识</a>。)现在我们根据上一节中提到的5个基础概念来创建一个简单的webpack配置文件：</p>
<pre><code class="language-js">// 引入node的path模块
const { resolve } = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 文件输出配置
    output: {
    	// 输出的文件名称
        // 配置[name]则取的是入口文件的名称
    	filename: 'js/[name].js',
        // 输出的文件路径
        // 这里是指输出到根目录下的build目录下，如果对__dirname不是很了解的小伙伴可以去nodejs官网了解一下
        path: resolve(__dirname, 'build')
    },
    // 用于配置loader
    module: {},
    // 用于配置插件信息
    plugins: [],
    // 启用开发模式
    mode: 'development'
}
</code></pre>
<h1 id="添加打包命令">添加打包命令</h1>
<p>webpack的打包命令就是 <code>webpack</code>，我们可以在指令脚本中添加一些设置参数：</p>
<pre><code class="language-js">// 开发环境
webpack ./src/index.js -o ./build/index.js --mode=development
// 生产环境
webpack ./src/index.js -o ./build/index.js --mode=production
</code></pre>
<p>稍微解释下上面的脚本，上述脚本的含义是：webpack使用 <code>开发/生产</code> 模式( <code>mode</code> )，将 <code>./src/index.js</code> 打包输出( <code>-o</code> )到 <code>./build/index.js</code> 中。<br><br>
细心的小伙伴儿应该已经发现，上述两种指令的唯一区别在于 <code>mode</code> 的参数不同，一个是 <code>development</code>,代表开发环境; 另一个是 <code>production</code> ，代表生产环境。那两者有什么区别呢？<br><br>
我们先将两种指令配置到 <code>package.json</code> 的 <code>scripts</code> 中，方便我们后期可以直接使用 <code>npm</code> 或者 <code>yarn</code> 命令来执行它们。当然也可以直接将这两种指令复制到控制台中运行，但是显然这样就不是很方便了。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;webpack_study&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=development&quot;,
    &quot;build:prd&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=production&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;webpack&quot;: &quot;4.41.6&quot;,
    &quot;webpack-cli&quot;: &quot;3.3.11&quot;
  }
}
</code></pre>
<p>然后我们分别通过执行 <code>build:dev</code> 以及 <code>build:prd</code> 来看下打包后的区别。</p>
<blockquote>
<p>Tips: <br><br>
可能有小伙伴注意到了，在 <code>webpack.config.js</code> 文件中配置了 <code>mode: 'development'</code>，而在我们 <code>package.json</code> 的指令中也指定了 <code>--mode='development'</code>，那么两者究竟以谁为准呢？<br><br>
答案是以 <code>package.json</code> 中配置的为准。有兴趣的小伙伴可以去试试看~</p>
</blockquote>
<h2 id="builddev">build:dev</h2>
<pre><code class="language-js">npm run build:dev
</code></pre>
<p>运行这个指令后，我们在根目录的 <code>build/js</code> 路径下可以看到打包后生成的 <code>index.js</code> 文件。打开这个文件:</p>
<pre><code class="language-js">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = &quot;&quot;;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = &quot;./src/js/index.js&quot;);
/******/ })
/************************************************************************/
/******/ ({

/***/ &quot;./src/js/index.js&quot;:
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(&quot;const add = (x, y) =&gt; x + y;\n\nconsole.log(add(1, 2));\n\n\n//# sourceURL=webpack:///./src/js/index.js?&quot;);

/***/ })

/******/ });
</code></pre>
<p>滑动到最底部，我们可以看到之前写的代码被转换成了字符串形式写入到了 <code>eavl</code> 方法中，并且以 <code>源码路径</code> 为key，同时将之作为value，以对象的形式作为入参，传入打包生成的方法中。</p>
<h2 id="buildprd">build:prd</h2>
<p>我们再来看下通过运行 <code>build:prd</code> 打包生成的文件是什么样的呢：</p>
<pre><code class="language-js">npm run build:prd
</code></pre>
<p>运行完成后生成如下代码：</p>
<pre><code class="language-js">!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.t=function(e,t){if(1&amp;t&amp;&amp;(e=n(e)),8&amp;t)return e;if(4&amp;t&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;t&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return n.d(t,&quot;a&quot;,t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=&quot;&quot;,n(n.s=0)}([function(e,t){console.log(1+2)}]);
</code></pre>
<p>我们发现代码精简了许多，没有了注释，没有了空格折行，显然代码被压缩过了。由此可以得出结论：</p>
<blockquote>
<p>相较于development模式，production模式会对打包后的代码进行压缩。主要是因为production模式下启用了webpack的 <code>UglifyJsPlugin</code> 插件，这个插件的作用就是对代码进行压缩。</p>
</blockquote>
<h1 id="控制台输出信息">控制台输出信息</h1>
<p>打包完成后，让我们回过头来，再来一起看下控制台中显示的信息，并对这些信息做一个简单的了解。我们先来看下刚才打包完成后的控制台输出:</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f2ba8e9346040388a50d65a6c7b9d46~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>我们依次看下这些参数的含义：</p>
<blockquote>
<p>Hash: 打包之后生成的唯一ID，后续可用作文件名中的唯一表示，防止访问缓存；<br><br>
Version: webpack的版本；<br><br>
Time:  打包所耗的时间；<br><br>
Built at: 打包开始的时间; <br><br>
Asset：打包的资源；<br><br>
Size：文件大小；<br><br>
Chunks: 所属的chunk名称；<br><br>
Chunk Names：chunk名称；<br><br>
EntryPoint main: 入口文件名称；<br><br>
[....]:  参与打包的模块，也就是上一节中提到的静态模块。</p>
</blockquote>
<p>行文至此，我们已经实现了简单的webpack打包功能，并且对webpack的一些基本配置、打包命令以及不同模式下打包的区别做了一个简单的了解。与此同时，我们对控制台中输出信息的含义也了然于胸。<br><br>
在后面的章节中，我会依次介绍webpack的其他功能，借此可以帮助大家逐步熟悉webpack的配置，让小伙伴们在之后的开发过程中不会再对webpack的配置感到晦涩陌生。篇幅也许不会太长，但是希望对小伙伴们有所助益~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记三：js的兼容性处理]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-san-js-de-jian-rong-xing-chu-li/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-san-js-de-jian-rong-xing-chu-li/">
        </link>
        <updated>2021-12-24T08:42:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6903529588271136782">上一节</a>中我们简单实现了webpack的打包功能，并且对webpack的一些基本配置、打包命令以及不同模式下打包的区别做了一个简单的了解，也了解了下控制台输出信息的含义。接下来的几节我们一起来了解下，针对于不同类型的资源，webpack是如何进行编译打包的，在打包期间又需要做一些什么处理。</p>
<h1 id="js兼容性处理">js兼容性处理</h1>
<p>在上一节中，我们写了一段简单的js代码，用来做打包示例，并对js的打包有了初步的了解：</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y
console.log(add(1, 2))
</code></pre>
<p>我们截取打包后的代码：</p>
<pre><code class="language-js">eval(&quot;const add = (x, y) =&gt; x + y;\n\nconsole.log(add(1, 2));\n\n\n//# sourceURL=webpack:///./src/js/index.js?&quot;);
</code></pre>
<p>我们可以看到，在打包出来的代码中，<code>add</code> 的定义依旧是使用的 <code>const</code>，而不是兼容性最好的 <code>var</code>。现阶段，在我们的日常开发过程中基本上使用的都是ES6语法，但是一些版本较低的浏览器并不能完全兼容ES6语法，此时我们就要对js代码做兼容性处理。<br><br>
要对js做兼容性处理，这里我们需要用到两个工具：<code>babel-loader</code> 以及 <code>@babel/core</code>。我们先来安装下这两个工具：</p>
<pre><code class="language-js">yarn add babel-loader @babel/core
</code></pre>
<p>安装完成后要怎么使用呢？这里我们需要使用到webpack五个基本概念中的 <code>loader</code>。在上一篇配置的基础上，我们加入 <code>loader</code> 的配置。<code>loader</code> 的相关配置写到配置文件的 <code>module</code> 中：</p>
<pre><code class="language-js">// 引入node的path模块
const { resolve } = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 文件输出配置
    output: {
    	// 输出的文件名称
        // 配置[name]则取的是入口文件的名称
    	filename: 'js/[name].js',
        // 输出的文件路径
        // 这里是指输出到根目录下的build目录下，如果对__dirname不是很了解的小伙伴可以去nodejs官网了解一下
        path: resolve(__dirname, 'build')
    },
    // 用于配置loader
    module: {
      rules: [
      	{
          // 匹配.js文件
          test: /\.js$/,
          // 需要忽略掉node_modules，不然会对其中的内容也做检查, 会降低打包的性能
          exclude: /node_modules/, 
          // 使用babel-loader
          loader: 'babel-loader',
          // loader的相关配置
          options: {}
        }
      ]
    },
    // 用于配置插件信息
    plugins: [],
    // 启用开发模式
    mode: 'development'
}
</code></pre>
<p>配置完成后，我们运行 <code>yarn build:dev</code> 命令，我们会发现结果跟之前是一样的，ES6的代码并没有被转换。这是因为我们还没有“告诉” <code>babel-loader</code> 要怎么去做兼容性处理。那具体该怎么去处理js的兼容性问题呢？我们接着往下看。</p>
<h1 id="处理js兼容的三种方式">处理js兼容的三种方式</h1>
<p>针对js的兼容性处理主要有三种方式，我们依次来了解一下。</p>
<h2 id="方法一基本兼容性处理">方法一：基本兼容性处理</h2>
<p>基本兼容性处理是指可以处理一些基本的js兼容性问题，比如js中的const/let定义的转换，箭头函数的转换等等。此时我们需要用到一个工具：<code>@babel/preset-env</code>。这个工具可以帮助我们处理一些基本的js兼容性问题。</p>
<pre><code class="language-js">yarn add -D @babel/preset-env
</code></pre>
<p>安装完成后，我们在 <code>babel-loader</code> 的 <code>options</code> 中加入以下配置：</p>
<pre><code class="language-js">/* ... */
module: {
  rules: [
    {
      // 匹配.js文件
      test: /\.js$/,
      // 需要忽略掉node_modules，不然会对其中的内容也做检查, 会降低打包的性能
      exclude: /node_modules/, 
      // 使用babel-loader
      loader: 'babel-loader',
      // loader的相关配置
      options: {
        presets: ['@babel/preset-env']
      }
    }
  ]
},
/* ... */
</code></pre>
<p>配置完成后 ，我面再去执行刚才的打包命令, 然后截取出我们所写的代码：</p>
<pre><code class="language-js">eval(&quot;var add = function add(x, y) {\n  return x + y;\n};\n\nconsole.log(add(1, 2));\n\n//# sourceURL=webpack:///./src/js/index.js?&quot;);
</code></pre>
<p>此时我们可以发现，代码中的 <code>const</code> 声明已经被转换成了 <code>var</code>, 而原先的 <code>箭头函数</code> 也被转换成了普通的函数形式。说明loader已经生效了。<br><br>
在介绍这种兼容性处理方式的时候有提到过此种方式只能处理一些基本的js问题。如果我们在文件中加入一些稍微复杂的东西，比如 <code>Promise</code>， 然后执行打包会发生什么呢？</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y;
console.log(add(1, 2));

const promiseHandle = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('完成');
  }, 1000)
})
console.log(promiseHandle);
</code></pre>
<p>执行打包命令后，我们再来看下我们所写的代码：</p>
<pre><code class="language-js">eval(&quot;var add = function add(x, y) {\n  return x + y;\n};\n\nconsole.log(add(1, 2));\nvar promiseHandle = new Promise(function (resolv
</code></pre>
<p>我们可以看到，类似于 <code>const</code> 以及 <code>箭头函数</code> 的定义都被转换成了ES5的语法，但是 <code>Promise</code> 的内容并没有被转换，而且代码中也没有其他对 <code>Promise</code> 进行处理的方法。此时要怎么处理呢？莫慌，我们来看第二种js的兼容性处理方式。</p>
<h2 id="方法二babelpolyfill">方法二：@babel/polyfill</h2>
<p>如题，我们需要引入另外一种工具：<code>@babel/polyfill</code>。这种兼容方法比较全面，它可以对 <strong>全部js</strong> 做兼容性处理。</p>
<pre><code class="language-js">yarn add -D @babel/polyfill
</code></pre>
<p>这个工具使用比较简单，安装完成后，只需在需要使用的js文件中引入即可。我们在刚才的js文件基础上，引入这个包。</p>
<pre><code class="language-js">import '@babel/polyfill'

const add = (x, y) =&gt; x + y;
console.log(add(1, 2));

const promiseHandle = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve('完成');
  }, 1000)
})
console.log(promiseHandle);
</code></pre>
<p>再次执行打包命令，此时我们打开打包之后的js文件，会发现js文件中引入了大量的polyfill来对js兼容性的处理，其中就有对Promise的兼容处理(由于内容太长，此处就不贴代码了，建议小伙伴们动手试一下~)。此种方式可以解决我们第一种兼容性处理中的问题。<br><br>
但是，使用这种方式又会引发另外一个问题。我们来看下打包后的文件输出：</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/816a05df0ea642a38d0367050c9552ed~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>不难发现，由于引入了大量的polyfill，导致我们原先仅仅只有几k的文件，膨胀到了511k, 因为引入的polyfill囊括了所有的兼容性处理，这显然不是我们愿意看到的。而且事实上我们也用不到这么多的兼容性处理。那我们又该如何处理这个问题呢？我们来看下第三种兼容性处理方案。</p>
<h2 id="方法三core-js">方法三：core-js</h2>
<p>说白了，要解决方法二中的弊端，核心思路就是 <code>按需引入</code>。这个时候，我们需要使用到 <code>code-js</code>。其实在方法二中用到的 <code>@babel/polyfill</code>中也有它的影子, 有兴趣的小伙伴们可以去打包生成的文件中找找看~这里我们单独安装一份 <code>core-js</code>:</p>
<pre><code class="language-js">yarn add -D core-js
</code></pre>
<p>想要使用它，我们需要对刚才的 <code>babel-loader</code> 配置再进行一些改造：</p>
<pre><code class="language-js">/* ... */
module: {
  rules: [
    {
      // 匹配.js文件
      test: /\.js$/,
      // 需要忽略掉node_modules，不然会对其中的内容也做检查, 会降低打包的性能
      exclude: /node_modules/, 
      // 使用babel-loader
      loader: 'babel-loader',
      // loader的相关配置
      options: {
        &quot;presets&quot;: [
          [
            &quot;@babel/preset-env&quot;,
            {
              // 指定按需加载
              &quot;useBuiltIns&quot;: &quot;usage&quot;,
              // 指定core-js的版本
              &quot;corejs&quot;: {
                &quot;version&quot;: 3
              },
              // 指定兼容的浏览器版本
              &quot;targets&quot;: {
                &quot;chrome&quot;: &quot;60&quot;,
                &quot;firefox&quot;: &quot;60&quot;,
                &quot;ie&quot;: &quot;9&quot;,
                &quot;safari&quot;: &quot;10&quot;,
                &quot;edge&quot;: &quot;17&quot;
              }
            }
          ]
        ]
      }
    }
  ]
},
/* ... */
</code></pre>
<p>此时，我们指定了按需加载，指定了coreJs的版本是3，指定了需要兼容的具体的浏览器的版本。</p>
<blockquote>
<p>注意：使用这种方式的时候，需要把第二种方式中引入的@babel/polyfill注释掉，两者不可共用！！</p>
</blockquote>
<p>然后我们再次进行打包：</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c69c325e1b14ecb9a607f7e39156d07~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>再次打包后我们可以发现，Promise的兼容性处理会被引入进来，并且文件大小也缩小至105k, 相较于第二种方式，显然此种方式更佳~如果有小伙伴觉得这样配置显得代码有些冗余，不够优雅，我们也可将 <code>presets</code> 中配置的内容移动到根目录的 <code>.babelrc</code> 文件中：</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        // 指定按需加载
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        // 指定core-js的版本
        &quot;corejs&quot;: {
          &quot;version&quot;: 3
        },
        // 指定兼容的浏览器版本
        &quot;targets&quot;: {
          &quot;chrome&quot;: &quot;60&quot;,
          &quot;firefox&quot;: &quot;60&quot;,
          &quot;ie&quot;: &quot;9&quot;,
          &quot;safari&quot;: &quot;10&quot;,
          &quot;edge&quot;: &quot;17&quot;
        }
      }
    ]
  ]
}
</code></pre>
<p>行文至此，js的打包方式以及处理兼容的几种方式都已经介绍完毕。当然loader的配置不止这些，在日后的开发过程中，小伙伴们可以根据项目需要去查询对应loader的文档，来定制化适合自己项目的配置。<br><br>
处理完js的兼容性问题，那么开发团队在日常开发中的js风格统一化又该怎么去处理？一些容易犯的低级错误又该怎么去避免呢？下一章节我们就来介绍处理这些问题的方法~<br><br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90b2c8f2bb0447828ffbea8e6eab02a6~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记四：eslint语法检查]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-si-eslint-yu-fa-jian-cha/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-si-eslint-yu-fa-jian-cha/">
        </link>
        <updated>2021-12-24T08:42:08.000Z</updated>
        <content type="html"><![CDATA[<p>在<a href="https://juejin.cn/post/6903910160184868878">上一节</a>文章末尾，我们提出了一个问题，<strong>我们要如何控制代码风格的统一，避免一些低级错误</strong>。这一节我们就来介绍下解决这两个问题的方法：<strong>eslint语法检查</strong>。</p>
<h1 id="背景">背景</h1>
<p>在日常开发过程中，项目一般都是多人合作。为了保证代码的统一和规范，我们需要借助eslint去完成。在此过程中，我们需要使用到<code>eslint-loader</code> 以及 <code>eslint</code>。</p>
<h3 id="安装">安装</h3>
<pre><code class="language-js">yarn add -D eslint eslint-loader
</code></pre>
<h3 id="基本配置">基本配置</h3>
<p>安装完成后，在webpack.config.js中添加如下配置：</p>
<pre><code class="language-js">/* ... */
module: {
  rules: [
    {
        test: /\.js$/,
        exclude: /node_modules/, // 需要忽略掉node_modules，不然会对其中的内容也做检查
        loader: 'eslint-loader',
        options: {}
    }
  ]
}
/* ... */
</code></pre>
<p>配置完成后，eslint还需要知道具体的规则是什么。此时，我们需要在 <code>package.json</code> 文件中配置 <code>eslintConfig</code> 属性，或者在根目录下添加 <code>.eslintrc</code> 文件来配置eslint的规则。<br><br>
但是手动配置规则显然比较麻烦，此时我们可以借助第三方的工具来完成这件事情。这里我们使用 <code>airbnb</code> 的配置。<br><br>
想要使用airbnb的eslint规则，我们需要安装几个插件：<code>eslint-config-arbnb-base</code> 与 <code>eslint-plugin-import</code>。</p>
<pre><code class="language-js">yarn add -D eslint-config-airbnb-base  eslint-plugin-import
</code></pre>
<p>之后在 <code>package.json</code> 中添加如下配置：</p>
<pre><code class="language-js">&quot;eslintConfig&quot;: {
  &quot;extends&quot;: &quot;airbnb-base&quot;
}
</code></pre>
<p>或者在 <code>.eslintrc</code> 文件中添加：</p>
<pre><code class="language-js"> &quot;extends&quot;: &quot;airbnb-base&quot;
</code></pre>
<p>这样就会继承airbnb的eslint配置。再次打包或者运行时，控制台就会给出相应的报错提示：<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d666da14a1b644da8d910166ffd750a3~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<blockquote>
<p>我们也可以通过添加 <code>VScode</code>, 或者小伙伴们所用的其他IDE的 <code>ESlint插件</code> 去辅助我们日常的开发。在这里，笔者使用的是 <code>VScode</code>，如果有跟笔者一样使用这个IDE的小伙伴，推荐安装这个插件：</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eae5c1e455844d3b3ab03fdefe8bd0f~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>安装并启用这个插件之后，我们就可以在编辑器中看到eslint给出的相应提示：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7187fa4a4f9473d801b9d3d439709bb~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>当我们将光标移动至波浪线上时，在弹出的窗口中点击 <code>Quick Fix</code>选项后，插件也会提供一些快速修复的方法, 使得修复更加便捷：</p>
<figure data-type="image" tabindex="3"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/438ed3f9940c41abad755558f8411fbb~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
</blockquote>
<h3 id="自动修复配置">自动修复配置</h3>
<p>如果我们需要自动修复这些问题，我们可以添加一项配置：</p>
<pre><code class="language-js">module: {
  rules: [
    {
      test: /\.js$/,
      exclude: /node_modules/, // 需要忽略掉node_modules，不然会对其中的内容也做检查
      loader: 'eslint-loader',
      options: {
          fix: true // 自动修复一些eslint问题
      }
    }
  ]
}
</code></pre>
<p>这样则会自动修复一些问题。但是不是所有的问题都会被自动修复，有一些仍需要手动修复：<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d4612c60024378a027b819b8124953~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
此时我们只要根据给出的提示逐一修复即可。</p>
<h3 id="配合babel-loader一起使用">配合babel-loader一起使用</h3>
<p>行文至此，我们已经知道了 <code>ESlint</code> 怎么去使用。那么在日常开发中，如果先对所写的代码做过检查，然后再使用 <code>babel-loader</code> 转换一下，岂不是美滋滋？（手动滑稽）<br><br>
那如何才能与上一节中提到的 <code>babel-loader</code> 一起去使用呢？当然是一起写到loader配置里就好啦~这里我们需要注意一点：<strong>loader的执行顺序是自左向右，自下向上的，简而言之就是按照从后往前的顺序执行</strong>。所以如果我们需要先检查代码，之后再对代码打包的话，那么 <code>eslint-loader</code> 需要配置在 <code>babel-loader</code> 之后：</p>
<pre><code class="language-js">// 这里由于都是匹配的js文件，所以我们将两个loader写在一起
// 注意写法的改变，原先直接是写的loader，现在改为use数组的形式
module: {
  rules: [
    {
      // 匹配.js文件
      test: /\.js$/,
      // 需要忽略掉node_modules，不然会对其中的内容也做检查, 会降低打包的性能
      exclude: /node_modules/,
      use: [
      	// 使用 babel-loader
        {
          loader: 'babel-loader',
          // loader的相关配置
          options: {
            presets: ['@babel/preset-env'],
          },
        }, 
        // 使用 eslint-loader, 配置写在 babel-loader之后，优先执行
        {
          loader: 'eslint-loader',
          options: {
            fix: true,
          },
        },
      ],
    },
  ],
},
</code></pre>
<p>配置完成后，我们就可以实现先做代码检查，后进行语法转换啦~ <br></p>
<h1 id="预告">预告</h1>
<p>结合上一节的内容，我们介绍了webpack在对js文件做处理时的一些基本操作，包括 <code>语法转换</code> 以及 <code>语法检查</code>。介绍完了js，在下一章节中，我们一起来看下webpack在处理css文件的时候又会做哪些基本操作呢？拭目以待吧~</p>
<figure data-type="image" tabindex="4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd370ca53e2c47eeb502d251080d7f90~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记五：打包css文件]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-wu-da-bao-css-wen-jian/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-wu-da-bao-css-wen-jian/">
        </link>
        <updated>2021-12-24T08:41:39.000Z</updated>
        <content type="html"><![CDATA[<p>上两节我们了解了webpack是如何打包js文件的，以及在打包js文件过程中还做了兼容性处理和语法检查的操作。这一节我们来看下webpack是如何处理css文件的。<br><br>
我们知道，webpack只能识别js的内容，显然直接让webpack识别css文件是不可行的。那要如何将css文件中的内容转换成webpack可以识别的js内容呢？这里我们又需要借助“翻译官” <code>loader</code> 的帮助了。<br><br>
要想将css转换成js，我们需要用到两个loader：<code>style-loader</code> 以及 <code>css-loader</code>。我们先来简单看下这两个loader的作用：</p>
<blockquote>
<p>style-loader：生成style标签 ，将js中的css内容写入style标签中，并将其插入head标签中。<br><br>
css-loader：将css内容变成 <code>commonjs</code> 模块加载到js中，里面的内容是样式字符串。</p>
</blockquote>
<h1 id="安装">安装</h1>
<pre><code class="language-js">yarn add -D style-loader css-loader
</code></pre>
<h1 id="使用">使用</h1>
<p>在上一节中，我们了解到loader的执行是有顺序的，即<strong>按照从后往前的配置顺序执行</strong>。根据上面对两个loader的描述，我们需要先通过 <code>css-loader</code> 将css内容转换成js，然后通过 <code>style-loader</code> 将js中的css内容写入到style标签中。所以loader的顺序应该是 <code>css-loader</code> 先于 <code>style-loader</code> 执行。因此，我们需要在 <code>webpack.config.js</code> 中添加的配置如下：</p>
<pre><code class="language-js">const { resolve } = require('path')

module.exports = {
  // 入口文件
  entry: './src/index.js',
  // 输出
  output: {
    filename: '[name].js',
    //   __dirname表示当前文件所在目录的绝对路径
    path: resolve(__dirname, 'build'),
  },
  // loader配置
  module: {
    rules: [
      {
        test: /\.css$/, // 匹配以css结尾的文件
        // 使用哪些loader包处理，执行顺序是从后往前
        use: [
          // 生成style标签，将js中的样式资源写入其中，并添加到head标签中
          'style-loader',
          // 将css的内容变成commonjs模块加载到js中，里面的内容是样式字符串
          'css-loader'
        ]
      }
    ]
  },
  // 插件
  plugins: [],
  // 模式 development / production
  mode: 'development'
}
</code></pre>
<p>配置完成后，我们先准备一个简单的css文件，保存在 <code>src/css/index.css</code>中：</p>
<pre><code class="language-css">html, body {
  padding: 0;
  margin: 0;
  background: #ff5512;
}
</code></pre>
<p>然后在入口 <code>index.js</code> 文件中引入 <code>index.css</code> 文件，之后执行打包操作。在打包生成的js文件中，我们就可以看到 <code>index.css</code> 中的内容：<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db759eb2c3bf4db4b38563e9a3f2680b~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
之后，我们新建一个 <code>index.html</code> 文件，将打包之后的js文件引入页面，即可以看到样式生效。</p>
<h1 id="sass-loader">sass-loader</h1>
<p>在现阶段项目的开发过程中，我们经常会用到诸如 <code>sass</code>、<code>less</code>、<code>stylus</code>等等的 <code>css预处理器</code>。那应该如何让webpack可以识别出我们使用这些 <code>css预处理器</code> 写出的css代码呢？<br><br>
其实也并不复杂，基本的思路就是<strong>使用对应 <code>css预处理器</code> 的 <code>loader</code>，将代码转换为普通的css代码，然后再通过 <code>css-loader</code> 与 <code>style-loader</code> 将css转换成js代码，并插入到页面的style标签中去。</strong><br><br>
本文中以 <code>sass</code> 为例。想要将 <code>sass</code> 代码转换为普通的css代码，我们需要安装两个工具：</p>
<pre><code class="language-js">yarn add -D sass sass-loader
</code></pre>
<p>之后只需要在 <code>webpack.config.js</code> 文件中加入相应的loader配置，并将文件匹配的正则调整下即可：</p>
<pre><code class="language-js">/* ... */
// loader配置
module: {
  rules: [
    {
      test: /\.s[ac]ss$/, // 匹配以.scss或者.sass结尾的文件
      // 使用哪些loader包处理，执行顺序是从后往前
      use: [
        // 生成style标签，将js中的样式资源写入其中，并添加到head标签中
        'style-loader',
        // 将css的内容变成commonjs模块加载到js中，里面的内容是样式字符串
        'css-loader',
        // 将使用sass编写的代码转换为普通的css代码 
        'sass-loader'
      ]
    }
  ]
},
/* ... */
</code></pre>
<p>修改完配置后，我们将 <code>index.css</code> 文件修改为 <code>index.scss</code>，并在其中加入sass的语法：</p>
<pre><code class="language-css">html, body {
  padding: 0;
  margin: 0;
  background: #ff5512;
  div {
    background: blue
  }
}
</code></pre>
<p>然后运行打包命令，打开打包后的js文件，我们可以看到sass的内容会被转换为普通的css内容：<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af9c3a2e6a724c1094fa9048b93a37b2~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<h1 id="预告">预告</h1>
<p>这一节我们知道了在webpack中如何对css文件做处理，以及在使用 <code>css预处理器</code> 时如何对其内容做相应的转换。<br><br>
但是css的内容在转换过后，依旧存在于js文件中。随着我们项目开发的推进，打包出来的js文件会愈发庞大。除此之外，针对于不同平台以及不同设备，我们所写的css代码也需要做相应的兼容性处理。<br><br>
针对以上的问题，我们下节一起来看下如何将js中的css代码提取成单独的文件，并对其做相应的兼容性与代码压缩处理。敬请期待~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记六：css兼容性处理以及文件提取]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-liu-css-jian-rong-xing-chu-li-yi-ji-wen-jian-ti-qu/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-liu-css-jian-rong-xing-chu-li-yi-ji-wen-jian-ti-qu/">
        </link>
        <updated>2021-12-24T08:40:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6905647041368555527">上一节</a>我们学习到webpack中如何处理css文件，以及在使用了 <code>css预处理器</code> 后又改怎么处理。文章末尾我们也提到了两个需要解决的问题：</p>
<blockquote>
<ol>
<li>随着项目推进，一直将css写入js中会导致文件逐渐臃肿；</li>
<li>css兼容性<br>
这一节，我们将针对这两个问题提出相应的解决方案。</li>
</ol>
</blockquote>
<h1 id="css文件提取">css文件提取</h1>
<p>上一节中我们使用到了 <code>style-loader</code> 、 <code>css-loader</code> 以及 <code>sass-loader</code> 三种loader，在这三种loader的协同作用下，.scss文件先通过sass-loader转成普通的css文件，再通过css-loader将css转换成commonjs模块并打包到js中，最后通过style-loader将js文件中的css样式加载到head里的style标签中去。<br><br>
除了上面提到的第一个问题外，这样也会导致页面会有短暂的错乱，然后等js文件加载完成后，页面样式才会恢复正常，这显然不符合我们的要求，用户的体验也非常不好。此时，我们需要将js中的css单独提取出来，作为css文件引入页面，这样就可以解决这个问题。而且js的文件体积会更小，上述第一个问题也能被解决。</p>
<h2 id="如何使用">如何使用</h2>
<p>要将js中的css提取成单独的文件，我们需要用到一个 <code>插件</code> ：<code>mini-css-extract-plugin</code>。</p>
<h3 id="安装">安装</h3>
<pre><code class="language-js">yarn add -D mini-css-extract-plugin
</code></pre>
<h3 id="配置">配置</h3>
<p>前几节我们主要使用的是webpack中的 <code>loader</code> ，与 <code>loader</code> 不同的是，<code>插件</code> 在使用之前需要先引入进来，然后在wbepack.config.js的 <code>plugin</code> 字段中添加配置：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    /* ... */
    plugins: [
    	new MiniCssExtractPlugin({
         filename: 'css/index.[contenthash:10].css',
       }),
    ]
    /* ... */
}
</code></pre>
<p>其中，在实例化这个插件时，可以传入配置。上述配置中指定了提取出css文件的输出路径。<br><br>
在配置完插件之后，我们来回顾一下之前的处理方式，最终的结果是<strong>通过 <code>style-loader</code> 将css的内容插入到页面的style标签中</strong>。而现在我们要实现的是<strong>将css文件单独提取出来</strong>。所以我们需要将 <code>style-loader</code> 替换掉。<br><br>
在 <code>mini-css-extract-plugin</code> 插件内部提供了一个用于提取css的loader: <code>MiniCssExtractPlugin.loader</code>，我们只需要将 <code>style-loader</code> 替换为 <code>MiniCssExtractPlugin.loader</code> 即可：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    /* ... */
    module: {
        rules: [
            /* ... */
            {
              test: /\.s[ac]ss/,
              exclude: /(node_modules|build)/,
              use: [
                MiniCssExtractPlugin.loader,,
                'css-loader',
                'sass-loader'
              ],
            },
        ]
    },
    plugins: [
    	new MiniCssExtractPlugin({
         filename: 'css/index.[contenthash:10].css',
       }),
    ]
    /* ... */
}
</code></pre>
<h1 id="css兼容性处理">css兼容性处理</h1>
<p>在日常开发中，为了让css样式能够适用于大多数的设备或者浏览器，我们需要对css做好兼容性处理。<br><br>
css的兼容性处理需要用到 <a href="https://www.postcss.com.cn/">postcss</a>。 <code>postcss</code> 是一个用 JavaScript 工具和插件转换 CSS 代码的工具。在webpack中使用它需要用到两个包：<code>postcss-loader</code> 以及 <code>postcss-preset-env</code>。<br><br>
其中，<code>postcss-preset-env</code> 的作用是帮助 <code>postcss-loader</code> 找到 <code>browserslist</code> 的配置，加载指定的兼容性。<code>browserslist</code> 一般会配置到package.json下，或者在根目录下有一个 <code>.browserslistrc</code> 的文件去写相关的配置。</p>
<blockquote>
<p>注意：package.json中的配置与.browserslistrc文件，两者只能存其一，否则会报错！！</p>
</blockquote>
<h3 id="安装-2">安装</h3>
<pre><code class="language-js">yarn add -D postcss-loader postcss-preset-env
</code></pre>
<h3 id="配置-2">配置</h3>
<p>我们在上面的loader配置基础上进行一些修改：</p>
<pre><code class="language-js">{
  test: /\.s[ac]ss$/i,
  use: [
    MiniCssExtractPlugin.loader,
    'css-loader',
    {
      loader: 'postcss-loader',
      options: {
        postcssOptions: {
          plugins: [
            [
              'postcss-preset-env',
              {
                // Options
              },
            ],
          ],
        },
      }
    },
    // 将 Sass 编译成 CSS
    'sass-loader',
  ],
},
</code></pre>
<p>然后在 <code>package.json</code> 文件中添加如下配置（更多配置可以参考:<a href="https://github.com/browserslist/browserslist">browserslist</a>）：</p>
<pre><code class="language-json">&quot;browserslist&quot;: {
    &quot;development&quot;: [ // 开发环境
      &quot;last 1 chrome version&quot;,
      &quot;last 1 safari version&quot;,
      &quot;last 1 firefox version&quot;
    ],
    &quot;production&quot;: [ // 生产环境
      &quot;&gt; 0.2%&quot;,
      &quot;not dead&quot;,
      &quot;not op_mini all&quot;
    ]
}
</code></pre>
<p>或者也可以在根目录下创建.browserslistrc文件。</p>
<blockquote>
<p>注意：配置项是有顺序的！！&gt; 0.2%写到后面会报错</p>
</blockquote>
<pre><code class="language-json">&gt; 0.2%
not dead
not op_mini all
</code></pre>
<p>关于postcss-loader更多的配置可以<a href="https://webpack.js.org/loaders/postcss-loader/#root">参考</a>。</p>
<h1 id="css文件压缩">css文件压缩</h1>
<p>在对css文件做完兼容性处理并提取成单个文件之后，我们可以进一步对其进行优化，将抽出的css文件进行压缩。此时我们需要用到一个插件： <code>optimize-css-assets-webpack-plugin</code>。</p>
<h3 id="安装-3">安装</h3>
<pre><code class="language-js">yarn add -D optimize-css-assets-webpack-plugin
</code></pre>
<h3 id="使用">使用</h3>
<p>使用非常简单 ，只需要在 <code>webpack.config.js</code> 中引入使用即可。默认配置已经可以满足压缩需要，如果需要添加配置，可以<a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin">参考</a>。</p>
<pre><code class="language-js">const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    /* ... */
    module: {
      rules: [
        /* ... */
        {
          test: /\.s[ac]ss$/i,
          use: [
            MiniCssExtractPlugin.loader,
            'css-loader',
            {
              loader: 'postcss-loader',
              options: {
                postcssOptions: {
                  plugins: [
                    [
                      'postcss-preset-env',
                      {
                        // Options
                      },
                    ],
                  ],
                },
              }
            },
            // 将 Sass 编译成 CSS
            'sass-loader',
          ],
        },
      ]
    },
    plugins: [
    	new MiniCssExtractPlugin({
         filename: 'css/index.[contenthash:10].css',
       }),
       new OptimizeCssAssetsWebpackPlugin()
    ]
    /* ... */
}
</code></pre>
<h1 id="预告">预告</h1>
<p>通过这两节，我们已经知道了webpack中如何对css文件进行处理，并在此过程中对其做了一些优化，包括提取单个css文件，兼容性处理以及css代码压缩。<br><br>
下一节我们一起来看下，除了css文件与js文件外，其他的文件webpack要如何进行处理呢？拭目以待吧~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack学习笔记七：其他文件的打包]]></title>
        <id>https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-qi-qi-ta-wen-jian-de-da-bao/</id>
        <link href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-qi-qi-ta-wen-jian-de-da-bao/">
        </link>
        <updated>2021-12-24T08:38:47.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6907627139198107655">上一节</a>我们介绍了如何对css做兼容性处理，以及如何将代码中的css单独提取成css文件，并对其进行压缩处理。结合前几个章节的内容，我们已经知道了在webpack中如何对js以及css文件处理。那么除了js与css文件外，类似于 <code>html资源</code>、 <code>图片资源</code> 以及 <code>其他的资源</code> 又该怎么去处理呢？这一节我们一起来看一下~</p>
<h1 id="打包html资源">打包html资源</h1>
<p>要想对html资源进行打包，我们需要用到一个插件：<code>html-webpack-plugin</code>。这个插件的作用主要是<strong>生成html文件，并自动将output生成的文件引入</strong>。</p>
<h3 id="安装">安装</h3>
<pre><code class="language-js">yarn add -D html-webpack-plugin
</code></pre>
<h3 id="配置">配置</h3>
<p>安装完成后，我们需要在 <code>webpack.config.js</code> 中引入插件，并配置到 <code>plugins</code> 选项中：</p>
<pre><code class="language-js">const { resolve } = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: './src/js/index.js',
  // 输出
  output: {
    filename: 'js/[name].[contenthash:10].js',
    //   __dirname表示当前文件所在目录的绝对路径
    path: resolve(__dirname, 'build'),
  },
  module: {
    rules: [/*...*/]
  },
  plugins: [
    new HtmlWebpackPlugin()
  ],
  mode: 'development'
}
</code></pre>
<p>配置完成后，执行打包命令，会看到在 <code>build</code> 目录下多出了一个 <code>index.html</code> 文件。这个文件就是通过 <code>html-webpack-plugin</code> 插件生成出来的。</p>
<h3 id="js与css文件的自动引入">js与css文件的自动引入</h3>
<p>打开生成的 <code>index.html</code> 文件，我们可以看到打包出来的js文件被自动引入了：<br>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5fc7220af747ce826b51e9f028175e~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
还记的我们上一节中提到的提取css文件的操作么？如果我们将css文件也提取出来之后也会被自动引入到 <code>index.html</code> 文件中么？我们一起来试一试，将上节中的配置写入进来：</p>
<pre><code class="language-js">const { resolve } = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  entry: './src/js/index.js',
  // 输出
  output: {
    filename: 'js/[name].[contenthash:10].js',
    //   __dirname表示当前文件所在目录的绝对路径
    path: resolve(__dirname, 'build'),
  },
  module: {
    rules: [
    	{
        // 匹配.js文件
        test: /\.js$/,
        // 需要忽略掉node_modules，不然会对其中的内容也做检查, 会降低打包的性能
        exclude: /node_modules/,
        // 使用babel-loader
        use: [
          {
            loader: 'babel-loader',
            // loader的相关配置
            options: {
              presets: [
                [
                  '@babel/preset-env',
                  {
                    // 指定按需加载
                    useBuiltIns: 'usage',
                    // 指定core-js的版本
                    corejs: {
                      version: 3,
                    },
                    // 指定兼容的浏览器版本
                    targets: {
                      chrome: '60',
                      firefox: '60',
                      ie: '9',
                      safari: '10',
                      edge: '17',
                    },
                  },
                ],
              ],
            },
          },
        ],
      },
      {
        test: /\.s[ac]ss/,
        exclude: /(node_modules|build)/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          'sass-loader'
        ],
      },
    ]
  },
  plugins: [
    new HtmlWebpackPlugin(),
    new MiniCssExtractPlugin({
      filename: 'css/index.[contenthash:10].css', // 设置css文件的输出路径
    }),
  ],
  mode: 'development'
}
</code></pre>
<p>此时我们再次执行打包命令，之后打开生成的 <code>index.html</code> 文件，我们可以看到提取出来的css文件也会被引入进来：<br>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8827558e583a431f80e9abc49002de1d~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<h3 id="配置自定义html模板">配置自定义html模板</h3>
<p>在上面的栗子中，我们只是单纯的使用了 <code>html-webpack-plugin</code> 这个插件。在不传入任何配置的情况下，这个插件会生成一个最简单的html文件。如果我们对生成的html文件有定制化的需求，此时，我们可以给这个插件传入相应的参数，用来声明生成html文件时所需要使用的模板。<br><br>
在传入配置之前，我们先在src目录下创建一个 <code>index.html</code> 文件，用来定义我们自定义的页面模板：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;webpack-image&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;我的自定义模板&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>之后，我们给插件传入如下配置：</p>
<pre><code class="language-js">const { resolve } = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  /* ... */
  plugins: [
    new HtmlWebpackPlugin({
    	template: resolve(__dirname, 'src/index.html')
    })
  ]
  /* ... */
}
</code></pre>
<p>此时，当我们再次执行打包命令后，点开生成的html文件：<br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79acb15065944aca998e86eeb4b5c002~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
我们可以看到，在生成的html文件中，存在我们自定义的内容，与此同时，css与js文件也会被自动引入进来。</p>
<blockquote>
<p><strong>注意</strong> <br><br>
由于js与css文件会被自动引入进来，所以我们在模板中不需要手动引入css与js，否则会出现重复引入的情况！</p>
</blockquote>
<h3 id="指定html文件的生成目录">指定html文件的生成目录</h3>
<p>除此之外，我们也可以指定html文件生成的路径：</p>
<pre><code class="language-js">const { resolve } = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  /* ... */
  plugins: [
    new HtmlWebpackPlugin({
       template: resolve(__dirname, 'src/index.html'),
       filename: 'html/index.html'
    })
  ]
  /* ... */
}
</code></pre>
<p>配置完成后，html文件就会被打包至 <code>build/html</code> 路径下，文件名为 <code>index.html</code>。</p>
<h1 id="打包图片资源">打包图片资源</h1>
<p>图片资源主要有两个来源，一个是来自于html文件中，另一个是来源于css文件中。针对这两种不同的情况，处理的方式也各有不同。</p>
<h2 id="打包css文件中的图片">打包css文件中的图片</h2>
<p>要想打包css文件中的图片，我们需要用到一个loader工具：<code>url-loader</code>。这个loader的作用是<strong>处理css中的图片</strong>(其依赖于file-loader，所以也要下下来)。</p>
<h3 id="安装-2">安装</h3>
<pre><code class="language-js">yarn add -D url-loader file-loader
</code></pre>
<h3 id="配置-2">配置</h3>
<p>安装完成后，我们在 <code>webpack.config.js</code> 中加入以下配置:</p>
<pre><code class="language-js">/* ... */
rules: [
  {
    test: /\.(jpeg|png|gif|jpg)$/,
    loader: 'url-loader',
    options: {
      // 限制图片大小为8kb，含义是当图片的大小小于8kb时，会被编译成base64的形式写入样式，而超过8kb则会引入图片。
      // 优点：减少请求
      // 缺点：base64之后的大小可能会比原先图片的大小更大
      limit: 8 * 1024, 
      // 设置打包出来的图片名称，其中hash表示hash值，10表示截取hash值的前10位，ext表示保留图片原本的后缀名
      // 可以设置图片打包出去的路径
      // 比如'img/[hash:10].[ext]'表示将图片打包到build下的img文件夹中
      // 注意：1、此处的路径设置是相对于build文件夹的，如果设置'../[hash:10].[ext]'就是打包到build的上一级目录。
      // 2、这里设置的路径，也是最后css文件中引入的路径。比如设置的'img/[hash:10].[ext]'，那在css中引入的就是：background: url(img/....)。
      name: '[hash:10].[ext]'
    }
  }
]
/* ... */
</code></pre>
<h2 id="打包html文件中的图片">打包html文件中的图片</h2>
<p>处理html中的图片文件需要使用到另外一个loader：<code>html-loader</code>。这个loader的作用是<strong>引入html文件中的img，从而可以使其被url-loader处理</strong>。</p>
<h3 id="安装-3">安装</h3>
<pre><code class="language-js">yarn add -D html-loader
</code></pre>
<h3 id="配置-3">配置</h3>
<p>安装完成后，我们只需要在 <code>webpack.config.js</code> 的 <code>rules</code> 配置项中加入以下内容：</p>
<pre><code class="language-js">{
  test: /\.html$/,
  loader: 'html-loader'
}
</code></pre>
<p>然后在上述的 <code>src/index.html</code> 模板中，引入一张图片：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;webpack-image&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;我的自定义模板&lt;/p&gt;
  &lt;img src=&quot;./images/luoxiaohei1.jpeg&quot; alt=&quot;&quot;&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>之后运行打包命令，打开生成的html文件，我们即可看到引入的图片。<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c1209c0e30e46968d9d375cae4350e2~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<blockquote>
<p><strong>注意</strong> <br><br>
如果图片的显示路径是&quot;[Object Module]&quot;，原因是url-loader默认试用ES6的方式解析，而html-loader引入的图片是commonjs，所以在解析时会报错。此时需要将url-loader的 <code>esModule</code> 属性设置为fasle:</p>
<pre><code class="language-js">{
  test: /\.(jpeg|png|gif|jpg)$/,
  loader: 'url-loader',
  options: {
    limit: 8 * 1024,
    name: '[name].[hash:10].[ext]',
    esModule: false
  },
},
</code></pre>
</blockquote>
<h1 id="打包其他资源">打包其他资源</h1>
<p>打包其他资源（比如字体文件等不需要进过loader处理的文件）就是将其他资源原封不动原样输出。这需要用到 <code>file-loader</code>。在上述对css中的图片进行打包时，我们已经安装过这个包了。接下来的配置很简单 ，只需要在 <code>webpack.config.js</code> 中加入如下配置：</p>
<pre><code class="language-js">{
    exclude: /\.(html|js|css|sass)$/,
    loader: 'file-loader',
    options: {
      name: '[name]-[hash:10].[ext]'
    }
}
</code></pre>
<p>与其他loader配置不同的是，我们不需要用test的属性去匹配具体格式的文件，而是通过exclude的方式将不需要处理的文件排除出去，之后通过file-loader进行处理输出即可。</p>
<h1 id="devserver">devServer</h1>
<p>在日常开发过程中，我们通常会在本地启动一个服务用来做一些诸如自动编译，自动刷新等等的自动化操作。此时，我们需要用到 <code>devServer</code>。相对于打包输出文件到对应目录，<strong>devServer不会有任何文件输出</strong>。</p>
<h3 id="安装-4">安装</h3>
<pre><code class="language-js">yarn add -D webpack-dev-server
</code></pre>
<h3 id="配置-4">配置</h3>
<p>在 <code>webpack.config.js</code> 文件下，我们加入以下配置：</p>
<pre><code class="language-js">const { resolve } = require('path')

module.exports = {
  entry: './src/js/index.js',
  // 输出
  output: {
    filename: 'js/[name].[contenthash:10].js',
    //   __dirname表示当前文件所在目录的绝对路径
    path: resolve(__dirname, 'build'),
  },
  module: {
    rules: [/*...*/]
  },
  plugins: [
    /* ... */
  ],
  mode: 'development',
  devServer: {
    // 设置运行的项目路径
    contentBase: resolve(__dirname, 'build'),
    // 启动后打开浏览器
    open: true,
    // 启动gzip压缩
    compress: true,
    // 端口配置
    port: 3000
  }
}
</code></pre>
<h3 id="启动">启动</h3>
<p>配置完成后，我们可以在控制台中输入启动命令（也可以将启动命令写入 <code>package.json</code> 文件中）：</p>
<pre><code class="language-js">npx webpack-dev-server
</code></pre>
<p>启动完成后，会自动唤起浏览器，打开端口为3000的本地页面，并且当我们对代码进行修改时，它会自动监听代码的改动进行自动编译，并刷新页面。</p>
]]></content>
    </entry>
</feed>