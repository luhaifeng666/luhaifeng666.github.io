<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Webpack学习笔记二：Webpack初体验 | 酱豆腐精的小站</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://luhaifeng666.github.io/favicon.ico?v=1640361599713">
<link rel="stylesheet" href="https://luhaifeng666.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
webpack的使用依托于nodejs，本文及之后的篇幅里，使用的node版本为：10.17.0。

初始化node项目
开始之前，切换到存放项目的路径，在本地目录下初始化一个node项目，本文是在 webpack-study 目录下。初..." />
    <meta name="keywords" content="学习" />
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://luhaifeng666.github.io">
        <img src="https://luhaifeng666.github.io/images/avatar.png?v=1640361599713" class="site-logo">
        <h1 class="site-title">酱豆腐精的小站</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      我吹，你听
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/luhaifeng666" target="_blank">酱豆腐精</a> | <a class="rss" href="https://luhaifeng666.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Webpack学习笔记二：Webpack初体验</h2>
            <div class="post-date">2021-12-24</div>
            
              <div class="feature-container" style="background-image: url('https://luhaifeng666.github.io/post-images/webpack-xue-xi-bi-ji-er-webpack-chu-ti-yan.jpeg')">
              </div>
            
            <div class="post-content" v-pre>
              <blockquote>
<p>webpack的使用依托于nodejs，本文及之后的篇幅里，使用的node版本为：<code>10.17.0</code>。</p>
</blockquote>
<h1 id="初始化node项目">初始化node项目</h1>
<p>开始之前，切换到存放项目的路径，在本地目录下初始化一个node项目，本文是在 <code>webpack-study</code> 目录下。初始化的命令如下：</p>
<pre><code class="language-js">cd webpack-study
npm init
</code></pre>
<p>根据步骤设置下项目名称等一些基础信息，其他的步骤按照默认配置一路回车到底即可。创建完成后，在 <code>webpack-study</code> 目录下会生成最基本的package.json文件。</p>
<h1 id="创建代码目录">创建代码目录</h1>
<p>在 <code>webpack-study</code> 目录下创建 <code>src</code> 目录，用于存放源代码。并在src下创建index.js作为入口文件，这里先写一段简单的代码用作示例：</p>
<pre><code class="language-js">const add = (x, y) =&gt; x + y
console.log(add(1, 2))
</code></pre>
<h1 id="安装webpack">安装Webpack</h1>
<pre><code class="language-js">npm i webpack webpack-cli
</code></pre>
<p>这里除了用到 <code>webpack</code> ，我们也会用到 <code>webpack-cli</code>, 它是webpack的脚手架。</p>
<h1 id="创建webpack配置文件">创建Webpack配置文件</h1>
<p>想要使用webpack对资源进行打包，首先我们需要配置下webpack的配置文件。我们在项目根目录下创建 <code>webpack.config.js</code> 文件。上一篇中，我们提到webpack的5个基本概念，(如果印象不是很深的小伙伴可以回看：<a href="https://juejin.cn/post/6902441939560300558#heading-3">Webpack学习笔记一：一些基础知识</a>。)现在我们根据上一节中提到的5个基础概念来创建一个简单的webpack配置文件：</p>
<pre><code class="language-js">// 引入node的path模块
const { resolve } = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 文件输出配置
    output: {
    	// 输出的文件名称
        // 配置[name]则取的是入口文件的名称
    	filename: 'js/[name].js',
        // 输出的文件路径
        // 这里是指输出到根目录下的build目录下，如果对__dirname不是很了解的小伙伴可以去nodejs官网了解一下
        path: resolve(__dirname, 'build')
    },
    // 用于配置loader
    module: {},
    // 用于配置插件信息
    plugins: [],
    // 启用开发模式
    mode: 'development'
}
</code></pre>
<h1 id="添加打包命令">添加打包命令</h1>
<p>webpack的打包命令就是 <code>webpack</code>，我们可以在指令脚本中添加一些设置参数：</p>
<pre><code class="language-js">// 开发环境
webpack ./src/index.js -o ./build/index.js --mode=development
// 生产环境
webpack ./src/index.js -o ./build/index.js --mode=production
</code></pre>
<p>稍微解释下上面的脚本，上述脚本的含义是：webpack使用 <code>开发/生产</code> 模式( <code>mode</code> )，将 <code>./src/index.js</code> 打包输出( <code>-o</code> )到 <code>./build/index.js</code> 中。<br><br>
细心的小伙伴儿应该已经发现，上述两种指令的唯一区别在于 <code>mode</code> 的参数不同，一个是 <code>development</code>,代表开发环境; 另一个是 <code>production</code> ，代表生产环境。那两者有什么区别呢？<br><br>
我们先将两种指令配置到 <code>package.json</code> 的 <code>scripts</code> 中，方便我们后期可以直接使用 <code>npm</code> 或者 <code>yarn</code> 命令来执行它们。当然也可以直接将这两种指令复制到控制台中运行，但是显然这样就不是很方便了。</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;webpack_study&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=development&quot;,
    &quot;build:prd&quot;: &quot;webpack ./src/index -o ./build/index.js --mode=production&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;webpack&quot;: &quot;4.41.6&quot;,
    &quot;webpack-cli&quot;: &quot;3.3.11&quot;
  }
}
</code></pre>
<p>然后我们分别通过执行 <code>build:dev</code> 以及 <code>build:prd</code> 来看下打包后的区别。</p>
<blockquote>
<p>Tips: <br><br>
可能有小伙伴注意到了，在 <code>webpack.config.js</code> 文件中配置了 <code>mode: 'development'</code>，而在我们 <code>package.json</code> 的指令中也指定了 <code>--mode='development'</code>，那么两者究竟以谁为准呢？<br><br>
答案是以 <code>package.json</code> 中配置的为准。有兴趣的小伙伴可以去试试看~</p>
</blockquote>
<h2 id="builddev">build:dev</h2>
<pre><code class="language-js">npm run build:dev
</code></pre>
<p>运行这个指令后，我们在根目录的 <code>build/js</code> 路径下可以看到打包后生成的 <code>index.js</code> 文件。打开这个文件:</p>
<pre><code class="language-js">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module &amp;&amp; module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = &quot;&quot;;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = &quot;./src/js/index.js&quot;);
/******/ })
/************************************************************************/
/******/ ({

/***/ &quot;./src/js/index.js&quot;:
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval(&quot;const add = (x, y) =&gt; x + y;\n\nconsole.log(add(1, 2));\n\n\n//# sourceURL=webpack:///./src/js/index.js?&quot;);

/***/ })

/******/ });
</code></pre>
<p>滑动到最底部，我们可以看到之前写的代码被转换成了字符串形式写入到了 <code>eavl</code> 方法中，并且以 <code>源码路径</code> 为key，同时将之作为value，以对象的形式作为入参，传入打包生成的方法中。</p>
<h2 id="buildprd">build:prd</h2>
<p>我们再来看下通过运行 <code>build:prd</code> 打包生成的文件是什么样的呢：</p>
<pre><code class="language-js">npm run build:prd
</code></pre>
<p>运行完成后生成如下代码：</p>
<pre><code class="language-js">!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.t=function(e,t){if(1&amp;t&amp;&amp;(e=n(e)),8&amp;t)return e;if(4&amp;t&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;t&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return n.d(t,&quot;a&quot;,t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=&quot;&quot;,n(n.s=0)}([function(e,t){console.log(1+2)}]);
</code></pre>
<p>我们发现代码精简了许多，没有了注释，没有了空格折行，显然代码被压缩过了。由此可以得出结论：</p>
<blockquote>
<p>相较于development模式，production模式会对打包后的代码进行压缩。主要是因为production模式下启用了webpack的 <code>UglifyJsPlugin</code> 插件，这个插件的作用就是对代码进行压缩。</p>
</blockquote>
<h1 id="控制台输出信息">控制台输出信息</h1>
<p>打包完成后，让我们回过头来，再来一起看下控制台中显示的信息，并对这些信息做一个简单的了解。我们先来看下刚才打包完成后的控制台输出:</p>
<figure data-type="image" tabindex="1"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f2ba8e9346040388a50d65a6c7b9d46~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></figure>
<p>我们依次看下这些参数的含义：</p>
<blockquote>
<p>Hash: 打包之后生成的唯一ID，后续可用作文件名中的唯一表示，防止访问缓存；<br><br>
Version: webpack的版本；<br><br>
Time:  打包所耗的时间；<br><br>
Built at: 打包开始的时间; <br><br>
Asset：打包的资源；<br><br>
Size：文件大小；<br><br>
Chunks: 所属的chunk名称；<br><br>
Chunk Names：chunk名称；<br><br>
EntryPoint main: 入口文件名称；<br><br>
[....]:  参与打包的模块，也就是上一节中提到的静态模块。</p>
</blockquote>
<p>行文至此，我们已经实现了简单的webpack打包功能，并且对webpack的一些基本配置、打包命令以及不同模式下打包的区别做了一个简单的了解。与此同时，我们对控制台中输出信息的含义也了然于胸。<br><br>
在后面的章节中，我会依次介绍webpack的其他功能，借此可以帮助大家逐步熟悉webpack的配置，让小伙伴们在之后的开发过程中不会再对webpack的配置感到晦涩陌生。篇幅也许不会太长，但是希望对小伙伴们有所助益~</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://luhaifeng666.github.io/tag/grwpKLl9t/" class="tag">
                    学习
                  </a>
                
              </div>
            
            <div id="vcomments"></div>
            <span id="comment-count"></span>
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://luhaifeng666.github.io/post/webpack-xue-xi-bi-ji-san-js-de-jian-rong-xing-chu-li/">
                  <h3 class="post-title">
                    Webpack学习笔记三：js的兼容性处理
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script type="text/javascript">
      // 设置valine
      new Valine({
        av: AV,
        el: '#vcomments',
        count_el: '#comment-count',
        appId: 'zYWibXSnGWE9VHeQWDPXrJIF-gzGzoHsz',
        appKey: 'qsFJvfKHzCIlBAzfJRaJEJRF',
        placeholder: '你说，我在听',
        visitor: true
      })
    </script>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
