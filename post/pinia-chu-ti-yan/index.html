<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Pinia初体验 | 酱豆腐精的小站</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://luhaifeng666.github.io/favicon.ico?v=1643341491308">
<link rel="stylesheet" href="https://luhaifeng666.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="写在开始
1月20日，尤大在知乎平台发布 Vue3 将自2月7日起成为默认版本的消息


Vue3 相关的技术栈也可以学习起来啦~本文就同大家一起初步体验下 “下一代的Vuex” -- Pinia。
什么是Pinia
Pinia 介绍
大概..." />
    <meta name="keywords" content="JS,学习" />
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://luhaifeng666.github.io">
        <img src="https://luhaifeng666.github.io/images/avatar.png?v=1643341491308" class="site-logo">
        <h1 class="site-title">酱豆腐精的小站</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      我吹，你听
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/luhaifeng666" target="_blank">酱豆腐精</a> | <a class="rss" href="https://luhaifeng666.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Pinia初体验</h2>
            <div class="post-date">2022-01-28</div>
            
              <div class="feature-container" style="background-image: url('https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97d9bf02b114c1bb6445b10b190f2be~tplv-k3u1fbpfcp-zoom-crop-mark:1304:1304:1304:734.awebp?')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="写在开始">写在开始</h1>
<p>1月20日，尤大在知乎平台发布 <a href="https://zhuanlan.zhihu.com/p/460055155"><code>Vue3</code> 将自2月7日起成为默认版本</a>的消息</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/690b04d56e8d4672bc59056611c95967~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p><code>Vue3</code> 相关的技术栈也可以学习起来啦~本文就同大家一起初步体验下 “下一代的Vuex” -- <a href="https://pinia.vuejs.org/">Pinia</a>。</p>
<h1 id="什么是pinia">什么是Pinia</h1>
<h2 id="pinia-介绍">Pinia 介绍</h2>
<p>大概在2019年11月份左右，Pinia 的作者开始尝试重新设计 Store 状态管理以适用于 Composition API，其设计原则跟思想与 Vuex 保持一致。</p>
<p>在不同版本的 Vue 中，所使用的 Vuex 版本是不一样的。Vue2 中需要使用 Vuex 3.x的版本，而在 Vue3 中需要使用 Vuex 4.x。但是 Pinia 没有这个限制，无论是在 Vue2 中，还是在 Vue3 中均可以使用 Pinia，<strong>且不一定要与 Composition API 一起使用</strong>，API 的使用方式在两者中也是保持一致的。</p>
<p>现在，Pinia 也已经正式被纳入 Vue 官方体系中。笔者写这篇文章时，其版本已更新至 <strong>v2.0.9</strong> 。</p>
<h2 id="为啥要用-pinia">为啥要用 Pinia</h2>
<p>Pinia 是用于 Vue 中的状态管理器，允许你跨组件/页面共享状态。</p>
<p>如果小伙伴们已经对 Composition API 比较熟悉了的话，可能会考虑使用类似下面这种写法去共享全局状态：</p>
<pre><code class="language-vue">export const state = reactive({})
</code></pre>
<p>在 SPA 应用中，这样去做是可以的，但是如果是在 SSR 中去使用的话会存在安全隐患。所以还是建议使用 Pinia。</p>
<p>使用 Pinia 有以下好处：</p>
<ol>
<li>
<p><strong>调试工具支持</strong></p>
<p>笔者目前安装的是 beta 版本的 Vue devtool，小伙伴们可以去 <a href="chrome://extensions">谷歌应用商店</a> 中搜索 <code>Vue devtool</code> 下载对应的 beta 版本。</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acca1566bfe4502bc35cee45a4f0589~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<blockquote>
<ol>
<li>调试工具中支持追踪 actions，mutations 的timeline(时间线)；</li>
<li>可以显示当前组件中使用的 store 信息，也可以显示所有 store 容器的信息，支持直接修改数据进行调试；</li>
<li>支持 Time travel(时间旅行) 以方便调试。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>热模块替换</strong>：改变状态时无需手动刷新页面。</li>
<li><strong>插件支持</strong>：可以通过插件扩展 Pinia 的能力。</li>
<li><strong>良好的 Typescript 支持</strong>：可以提供较为完善的代码提示以及代码自动补充。</li>
<li><strong>支持 SSR</strong>。</li>
</ol>
<h2 id="pinia-与-vuex-的对比">Pinia 与 Vuex 的对比</h2>
<p>Pinia 与 Vuex4.x 以下版本相比，有如下区别：</p>
<blockquote>
<ol>
<li><strong>移除了 mutations</strong>： 在 Vuex 中，想要改变状态，需要通过提交 mutations 来实现，而 mutations 不能执行异步操作，因此诞生了 actions ，在异步获取数据后，通过 actions 调用 mutations 修改数据。现在在 Pinia 中，actions 同时支持同步与异步操作，所以 mutations 显得有些冗余了，因此不再需要；</li>
<li><strong>对于 Typescript 的支持更加友好</strong>：使用 Pinia 时,不再需要定义复杂的 wrappers（包装器）去支持Typescript;</li>
<li><strong>不会注入魔法字符串</strong>：在组件中使用 Vuex 时，经常会出现类似 <code>this.$store.commit(&quot;xxxxx&quot;)</code> 这样的魔法字符串，虽然会将这些字符串抽为常量暴露出来，但是维护起来还是不太方便。在 Pinia 中不再需要使用这种方式，而是直接调用 <code>defineStore</code> 后暴露出来的方法，而后通过 <code>$patch</code>, <code>action</code> 的方式，或者直接修改 store 中的值即可；</li>
<li><strong>不需要动态添加 stores</strong>：只要你愿意，你可以随时定义 stores，它们默认是动态的；</li>
<li><strong>不再需要嵌套结构的 modules</strong>;</li>
<li><strong>没有带命名空间的模块</strong>。</li>
</ol>
</blockquote>
<h1 id="pina的使用">Pina的使用</h1>
<h2 id="安装">安装</h2>
<p>我们先在本地搭建一个Vue3的项目，用于演示 <code>Pinia</code> 的使用，这里我们使用 <a href="https://cn.vitejs.dev/">Vite</a> 来搭建：</p>
<blockquote>
<p>Vite 需要 <a href="https://nodejs.org/en/">Node.js</a> 版本 &gt;= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>
</blockquote>
<p>Vite官方提供了使用模板的方式构建本地项目，这里我们通过 <a href="https://www.pnpm.cn/">pnpm</a> 来构建一个 <code>Vite + Vue</code> 的本地项目。现在 Vue3 以及 Pinia 对于 Typescript 的支持已经非常良好了,建议大家在使用模板构建项目的时候直接选择 Typescript 对应的模板：</p>
<pre><code>pnpm create vite pinia-useage-examples -- --template vue-ts
</code></pre>
<p>之后，我们在项目中安装 <code>Pinia</code>:</p>
<pre><code> pnpm add pinia
</code></pre>
<p>准备工作完成，接下来就来一起体验一下 <code>Pinia</code> 吧~</p>
<h2 id="使用">使用</h2>
<p>首先，我们需要通过 <code>createPinia</code> 初始化 Pinia，并将其挂载到 Vue 的实例上：</p>
<pre><code class="language-ts">// src/main.ts

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

// 创建 pinia
const pinia = createPinia()

const app = createApp(App)
// 挂载到 Vue 实例上
app.use(pinia)
app.mount('#app')
</code></pre>
<p>之后按照惯例，我们先创建 <code>src/store/index.ts</code> 文件，用于存放 store:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  
})
</code></pre>
<p><strong>这里需要注意的是，<code>defineStore</code> 的第一个参数用于设置 store 的容器名称，该名称必须唯一，不可重复！</strong></p>
<p>上文中提到，相比于 Vuex，Pinia 中移除了 mutations，剩余需要了解的内容主要包含三个部分：</p>
<blockquote>
<ol>
<li><strong>State</strong>: 用于存放数据，有点儿类似 <code>data</code> 的概念；</li>
<li><strong>Getters</strong>: 用于获取数据，有点儿类似 <code>computed</code> 的概念；</li>
<li><strong>Actions</strong>: 用于修改数据，有点儿类似 <code>methods</code> 的概念；</li>
<li><strong>Plugins</strong>: Pinia 插件。</li>
</ol>
</blockquote>
<p>现在我们依次来看一看它们的用法。</p>
<h2 id="state">State</h2>
<h3 id="定义-state">定义 State</h3>
<p>在 Vuex 中，通过对象的形式来定义 state ，而在 Pinia 中则需要通过函数的方式定义 state，这种方式有点儿类似组件中 <code>data</code> 的概念:</p>
<pre><code class="language-ts">// src/store/index.ts

import { defineStore } from 'pinia'

// 定义store, myFirstStore是store的名称，该名称必须唯一，不可重复
export const useStore = defineStore('myFirstStore', {
  state: () =&gt; {
    return {
      count: 0,
      name: 'foo',
      list: [1, 2, 3]
    }
  }
})
</code></pre>
<h3 id="读取-state">读取 State</h3>
<p>state 定义完成后，我们在页面中可以通过引入暴露出去的 <code>useStore</code> 来读取 state 中的数据：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;p&gt;count: {{ myStore.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ myStore.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ myStore.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const myStore = useStore()
&lt;/script&gt;
</code></pre>
<p>看到这里，有的小伙伴不禁会问，在使用过程中，一直要写 <code>myStore.xxx</code> 不是很麻烦么？能否通过解构的方式来使用呢？</p>
<p>那我们就一起来试一试，看看是否可以通过解构的方式来获取 store 中的值:</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const { count, name, list } = useStore()
&lt;/script&gt;
</code></pre>
<p>通过这次尝试我们发现，确实可以通过解构的方式来获取到 store 的值。但是这种方式存在一个问题：<strong>直接通过解构的方式获取state中的值是非响应式的！</strong> 这就意味着后面在对 store 中的值进行修改之后，页面不会发生变化。</p>
<p>那我们改如何解决这个问题呢？答案是通过 Pinia 中提供的 <code>storeToRefs</code> 方法，将结构出来的值转换为响应式的值即可：</p>
<pre><code class="language-ts">// src/App.vue

&lt;script setup lang=&quot;ts&quot;&gt;
import { storeToRefs } from 'pinia'
import { useStore } from './store'

const { count, name, list } = storeToRefs(useStore())
&lt;/script&gt;
</code></pre>
<p>除了使用这两种方式以外，Pinia 也提供了 <code>mapState</code> 与 <code>computed</code> 相结合的方式去获取 store 中的值，这种方式与 Vuex 中的 <code>mapState</code> 类似：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ res.count }}&lt;/p&gt;
  &lt;p&gt;name: {{ res.name }}&lt;/p&gt;
  &lt;p&gt;list: {{ res.list }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, ['count', 'name', 'list'])
  }
  return {
    count: data.count(),
    name: data.name(),
    list: data.list()
  }
})
&lt;/script&gt;
</code></pre>
<p>由于是通过 <code>computed</code> 获取到的值，所以结构之后的值就是响应式的，不需要使用 <code>stateToRefs</code> 方法进行转换。</p>
<p>在 <code>computed</code> 内部也可以对属性进行重命名，或者重新定义新的返回值返回值：</p>
<pre><code class="language-js">&lt;script setup lang=&quot;ts&quot;&gt;
import { mapState } from 'pinia'
import { useStore } from './store'
import { computed } from 'vue'

const res = computed(() =&gt; {
  const data = {
    ...mapState(useStore, {
      // 重命名count为myCount, 并返回count + 1的结果
      myCount: state =&gt; state.count += 1,
      // 重命名name为没有Name，并返回name的值
      myName: 'name',
      // 重命名list为myList，并返回插入4之后的list
      myList: state =&gt; {
        state.list.push(4)
        return state.list
      }
    })
  }
  return {
    count: data.myCount(),
    name: data.myName(),
    list: data.myList()
  }
})
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>本文的示例中使用的是 <code>setup</code> 语法糖，如果不使用 <code>setup</code> 语法糖的话，<code>mapState</code> 的使用方式与本文中所举的🌰有些差别(关于这个问题，网上有使用 <code>bind</code> 的方式的栗子，具体可以参考<a href="https://blog.csdn.net/WaiTinglw/article/details/122091494">这篇文章</a>)。详情可以查阅<a href="https://pinia.vuejs.org/core-concepts/state.html#usage-with-the-options-api">官方文档</a>。如果本文中有使用不当之处，还请诸位大佬指正~ Orz；</li>
<li>通过 <code>computed</code> 返回的 state 无法使用结构的方式获取其中的值，因为返回的不是单纯的对象，而是一个 <code>ComputedRefImpl</code> 类型的值。</li>
<li>通过 <code>mapState</code> 获取到的值是<strong>只读</strong>的，如果想要其可写，可以使用 <code>mapWritableState</code> 的方式。</li>
</ol>
</blockquote>
<h3 id="修改-state">修改 State</h3>
<p>现在我们已经可以获取到 State 中存储的值了，那么我们该如何去修改 State 中的值呢？其实很简单，主要分为以下几种方式：</p>
<h4 id="第一种直接修改">第一种：直接修改</h4>
<p>直接修改 State 中的值即可：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()
// 修改store中的值
const handleChangeStore = () =&gt; {
  // 直接修改
  store.count += 1
}
&lt;/script&gt;
</code></pre>
<p>甚至可以通过暴力覆盖 <code>$state</code> 的方式将所有值进行替换修改：</p>
<pre><code class="language-ts">// src/App.vue

// 省略好多好多代码。。。

// 直接清空store
store.$state = {}
</code></pre>
<h4 id="第二种-通过-patch-的方式修改">第二种: 通过 <code>$patch</code> 的方式修改</h4>
<p>当我们需要一次性修改多个值的时候，我们可以使用 <code>$patch</code> 方法来批量修改多个值：</p>
<pre><code class="language-js">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;name: {{ name }}&lt;/p&gt;
  &lt;p&gt;list: {{ list }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot; setup&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过 $patch 的方式修改
  store.$patch({
    name: 'test',
    list: [...store.list, 4]
  })
}
&lt;/script&gt;
</code></pre>
<p><code>$patch</code> 会将传入的对象与 Store 中的 state 进行 merge 覆盖。</p>
<p>除了直接传入对象外，如果存在较为复杂的操作，<code>$patch</code> 方法也接受传入一个回调函数，在回调函数中对需要修改的数据进行操作：</p>
<pre><code>// src/App.vue

// 省略好多好多代码。。。
store.$patch(state =&gt; {
  state.name = `我的名字是：${state.name}`
})

</code></pre>
<h4 id="第三种通过-reset-方法恢复原值">第三种：通过 <code>$reset</code> 方法恢复原值</h4>
<p>当我们修改了 state 中的值以后，倘若我们想让它们恢复到初始值，可以使用 <code>$reset</code> 方法。</p>
<h4 id="第四种通过调用-actions-中的方法去修改值">第四种：通过调用 <code>actions</code> 中的方法去修改值</h4>
<p>首先，我们需要在 Store 容器中定义 <code>actions</code>:</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  actions: {
    changeCount () {
      this.count ++
    }
  }
})
</code></pre>
<p>在 <code>actions</code> 中定义的方法，可以直接通过 <code>this</code> 来访问 state 中的属性，而无需像 Vuex 那样传入上下文才可以，使用方式有点儿类似 <code>methods</code>。</p>
<p>定义完成后，我们就可以在引用处直接使用它了：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot; /&gt;
  &lt;p&gt;count: {{ count }}&lt;/p&gt;
  &lt;button @click=&quot;handleChangeStore&quot;&gt;change store&lt;/button&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()

// 修改store中的值
const handleChangeStore = () =&gt; {
  // 通过actions的方式修改
  store.changeCount()
}
&lt;/script&gt;
</code></pre>
<p>当然，<code>actions</code> 中的方法也可以接收入参，使用方式与 <code>methods</code> 并无区别，这里不做过多赘述。</p>
<h3 id="调试-state">调试 State</h3>
<p>打开控制台，切换到 Vue devtool 中，选择 <code>Pinia</code> 选项，就可以看到 store 容器的信息：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e6e06b6634e4ec8bfdcac7aeaf3c55d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>并且点击数据后面的编辑按钮，也可以修改 store 中的值进行调试，非常方便：</p>
<figure data-type="image" tabindex="4"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99a0e1af8e74eefa41784219996ad81~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="getters">Getters</h2>
<p><code>getters</code> 的使用方式有点儿类似于 <code>computed</code>, 返回一个值(<strong>没有返回值也可以</strong>)且在页面中可以直接使用。如果 <code>getters</code> 中使用了 <code>state</code> 里的数据，当对应的数据发生变化时，<code>getters</code> 的值也会相应发生变化：</p>
<pre><code class="language-ts">// src/store/index.ts

// 定义store
export const useStore = defineStore('myFirstStore', {
  // 省略一些代码
  getters: {
    countPlusOne (state) {
      console.log('------countPlusOne------')
      return state.count + 1
    }
  }
})
</code></pre>
<p>直接在页面中使用，并且 <code>getters</code> 也有缓存，在页面中多次使用时，只会计算一次：</p>
<pre><code class="language-ts">// src/App.vue

&lt;template&gt;
  &lt;p&gt;countPlusOne: {{ store.countPlusOne }}&lt;/p&gt;
&lt;/template&gt;

&lt;script setup lang=&quot;ts&quot;&gt;
import { useStore } from './store'

const store = useStore()
&lt;/script&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf3831592af4344a1cfe7483c520ec6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>我们可以看到日志只打印了一次，说明后面两次是取的缓存中的数据。</p>
<blockquote>
<p>注意：</p>
<ol>
<li><code>getters</code> 中定义的方法，入参 <code>state</code> 是可选参数，如果不传入 <code>state</code>, 可以直接使用 <code>this</code> 访问 <code>state</code> 中的数据；</li>
<li>如果不传入 <code>state</code> 的话，Typescript 会有报错提示，因为无法推导出 <code>getters</code> 中方法的返回值类型，需要手动声明返回值类型。</li>
</ol>
</blockquote>
<h2 id="actions">Actions</h2>
<p>上文中提到可以通过 <code>Actions</code> 的方式修改 <code>State</code> 中的值，只不过所使用的是同步的方式。在一开始对 Pinia 的介绍中也提到，<code>Actions</code> 同时支持同步与异步两种修改数据的方式。接下来我们看看如何通过 <code>Actions</code> 异步修改数据。</p>
<pre><code class="language-ts">// src/store/index.ts

// 省略好多好多代码。。。
actions: {
  async changeName () {
    const newName: string = await new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve('newName')
      }, 1000)
    }).catch(err =&gt; {
    })
    this.name = newName
  }
}
</code></pre>
<p>通过上述代码我们不难发现，其实 <code>Actions</code> 通过异步修改数据的方式与寻常使用 <code>methods</code> 异步修改 <code>data</code> 中的数据类似，相较于 Vuex 简便许多。</p>
<h2 id="plugins">Plugins</h2>
<h3 id="插件介绍">插件介绍</h3>
<p>通过自定义 <code>Plugins</code> 可以扩展 <code>Stores</code>，它可以完成以下这些事情：</p>
<blockquote>
<ol>
<li>新增 <code>store</code> 中的属性;</li>
<li>定义 <code>store</code> 时传入新的配置项;</li>
<li>新增 <code>store</code> 中的方法;</li>
<li>包装 <code>store</code> 中的既有方法;</li>
<li>修改甚至取消 <code>actions</code>;</li>
<li>实现一些副作用操作，例如设置 local storage 缓存等等;</li>
<li>只会应用于特定的 <code>store</code>: 在 Pinia 挂载到 app 上后，插件会挂载到之后创建的 Stores 上，在此之前 Plugins 不会被挂载。</li>
</ol>
</blockquote>
<h3 id="插件定义-使用">插件定义 &amp; 使用</h3>
<p>插件本质上是一个函数，插件接受一个可选入参： <code>context</code>, 改入参是个对象，其中包含四项内容：</p>
<ol>
<li><strong>context.pinia:</strong> 通过 <code>createPinia()</code> 方式创建的 Pinia 实例</li>
<li><strong>context.app:</strong> 通过 <code>createApp()</code> 方式创建的 app 实例(仅支持Vue 3)</li>
<li><strong>context.store:</strong> store 对象</li>
<li><strong>context.options:</strong> 获取定义 store 时传入的配置项</li>
</ol>
<p>函数可以通过返回对象的方式，将对象中的值绑定到<strong>所有的</strong> store 上去：</p>
<pre><code class="language-ts">// src/main.ts

function SecretPiniaPlugin() {
  return { secret: 'the cake is a lie' }
}
</code></pre>
<p>定义完成后，通过 <code>pinia.use()</code> 的方式使用这个插件：</p>
<pre><code class="language-ts">// src/main.ts
import { createPinia } from 'pinia'

const pinia = createPinia()

pinia.use(SecretPiniaPlugin)
</code></pre>
<p>之后，在页面中打印 Store 中的 <code>secret</code> 属性时，即可看到我们设定的值。并且通过这种方式新增到 store 中的属性可以被 Vue devtool 捕获到：</p>
<figure data-type="image" tabindex="6"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5de1b7353e4de3b4a5deca838997c2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>当然你也可以选择直接将值绑定到 store 对象上，但是这样<strong>无法被 Vue devtool捕获</strong>：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
}
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7178d567ae64a8d9a61e9c40bb0a93a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>此时我们不难发现，上述步骤中的 <code>customProperties</code> 属性不见了。如果在调试过程中需要在 Vue devtool 中看到插件中定义的 store 内容，需要手动添加：</p>
<pre><code class="language-ts">// src/main.ts

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = 'the cake is a lie'
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}
</code></pre>
<p>添加完属性后，当我们直接在页面中使用时，发现页面上并不能显示出插件插入到 store 中的属性，这是因为插入的属性是<strong>非响应式的</strong>，此时，我们只需将插入的属性值变为<strong>响应式数据</strong>即可：</p>
<pre><code class="language-ts">import { createApp, ref } from 'vue'
import { createPinia } from 'pinia'

// 创建 pinia
const pinia = createPinia()

// 定义插件
function SecretPiniaPlugin({ store }) {
  // 直接将属性绑定到store上去
  store.secret = ref('the cake is a lie')
  // 在开发环境中手动添加该属性，以便 Vue devtool 可以捕获到
  if (process.env.NODE_ENV === 'development') {
    // add any keys you set on the store
    store._customProperties.add('secret')
  }
}

// 使用插件
pinia.use(SecretPiniaPlugin)
</code></pre>
<p>设置完成后，再在页面中使用时，就可以在页面上看到数据啦~</p>
<p>此外，在插件中可以通过 <code>store.$subscribe</code> 以及 <code>store.$onActions</code> 方法监听 actions 的触发。</p>
<p>关于插件的更多玩法可以参考<a href="https://pinia.vuejs.org/core-concepts/plugins.html">官方文档</a>。</p>
<h1 id="写在最后">写在最后</h1>
<p>行文至此，相信大家对于 <code>Pinia</code> 已经有了一个初步的印象。文章中若有描述不当之处还请诸位大佬指正。</p>
<p>好记性不如烂笔头，关于 Pinia 的其他更多玩法等待着小伙伴们去挖掘。赶快动手 <s>卷起来</s> 尝个鲜吧~</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://luhaifeng666.github.io/tag/h8BL6mwKM/" class="tag">
                    JS
                  </a>
                
                  <a href="https://luhaifeng666.github.io/tag/grwpKLl9t/" class="tag">
                    学习
                  </a>
                
              </div>
            
            <div id="vcomments"></div>
            <span id="comment-count"></span>
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://luhaifeng666.github.io/post/shou-xie-lian-xi-fang-dou-jie-liu/">
                  <h3 class="post-title">
                    手写练习：防抖节流
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
  <script type="text/javascript">
    // 设置valine
    new Valine({
      av: AV,
      el: '#vcomments',
      count_el: '#comment-count',
      appId: 'HlwrEhBsDstpVpKVMUMqyfBV-9Nh9j0Va',
      appKey: 'Cs2jEIpcC6nXJFH8LsEak9Kh',
      placeholder: '你说，我在听',
      visitor: true,
      // 设置Bilibili表情包地址
      emojiCDN: '//i0.hdslb.com/bfs/emote/',
      // 表情title和图片映射
      emojiMaps: {
        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png"
      }
    })
  </script>
</html>
