<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>从零开始创建属于自己的脚手架工具 | 酱豆腐精的小站</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://luhaifeng666.github.io/favicon.ico?v=1640359067064">
<link rel="stylesheet" href="https://luhaifeng666.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="背景
前段时间接到个需求，需要开发一个业务组件的包提供给业务组的小伙伴们去用。在此之前也开发过类似的包，除却包的作用不同之外，有些内容基本是大差不差的。比如git commit的规范，一些必备的诸如 src/index.js 的文件等等。
..." />
    <meta name="keywords" content="" />
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://luhaifeng666.github.io">
        <img src="https://luhaifeng666.github.io/images/avatar.png?v=1640359067064" class="site-logo">
        <h1 class="site-title">酱豆腐精的小站</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      我吹，你听
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/luhaifeng666" target="_blank">酱豆腐精</a> | <a class="rss" href="https://luhaifeng666.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">从零开始创建属于自己的脚手架工具</h2>
            <div class="post-date">2021-12-24</div>
            
              <div class="feature-container" style="background-image: url('https://luhaifeng666.github.io/post-images/cong-ling-kai-shi-chuang-jian-shu-yu-zi-ji-de-jiao-shou-jia-gong-ju.webp')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="背景">背景</h1>
<p>前段时间接到个需求，需要开发一个业务组件的包提供给业务组的小伙伴们去用。在此之前也开发过类似的包，除却包的作用不同之外，有些内容基本是大差不差的。比如git commit的规范，一些必备的诸如 <code>src/index.js</code> 的文件等等。</p>
<p>如果要新建一个包的工程，诸如上述所说的文件大多会去既有的工程中拷贝一份过来修修改改，继而再次基础上完成接下来的开发。等到下一次有新的类似需求来的时候，周而复始。。。Orz</p>
<p>那既然如此，我为啥不去搞一个脚手架工具去把这些人工操作的事情自动化掉呢~</p>
<pre><code class="language-js">常言道：临渊羡鱼，不如...退回去自己织个网，干！
</code></pre>
<h1 id="准备工作">准备工作</h1>
<p>简单三步做好准备工作~</p>
<pre><code>第一步：注册一个npm的账号，用于后面发包

第二步：mkdir cli-tool &amp;&amp; cd cli-tool &amp;&amp; npm init -y

第三步：之后在 `package.json` 文件中填入一些基本的信息即可
</code></pre>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;cli-tool&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A tool for cli creation&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;pub:beta&quot;: &quot;npm publish --tag=beta&quot;,
    &quot;pub&quot;: &quot;npm publish&quot;
  },
  &quot;publishConfig&quot;: {
    &quot;registry&quot;: &quot;https://registry.npmjs.org/&quot;
  },
  &quot;keywords&quot;: [
    &quot;create&quot;,
    &quot;cli&quot;
  ],
  &quot;author&quot;: &quot;your name&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<h1 id="开始造轮子">开始造轮子</h1>
<h2 id="第一步定义命令">第一步：定义命令</h2>
<p>相信大家都用过脚手架，脚手架工具一般都会提供相应的脚本命令以完成一些操作。比如查看版本号的 <code>--version</code>, 查看帮助信息的 <code>--help</code> 等等。在这一步骤中，我们也先来定义下属于我们自己脚手架的命令。</p>
<h3 id="创建脚本文件">创建脚本文件</h3>
<p>首先，我们在项目的根目录下创建 <code>bin</code> 目录，然后在该文件夹下创建定义脚本的文件 <code>ct.js</code>。创建完成后，在 <code>package.json</code> 文件中定义命令对应的文件：</p>
<pre><code class="language-json">{
  // ...
  &quot;bin&quot;: {
    &quot;ct&quot;: &quot;bin/ct.js&quot;
  }
}
</code></pre>
<p>其中，<code>ct</code> 指定了我们日后在使用脚手架时所需要输入的命令，<code>bin/ct.js</code> 指定输入命令后所执行的脚本文件路径。</p>
<h3 id="编写脚本">编写脚本</h3>
<p>我们在脚本中定义以下两个基本的命令：</p>
<pre><code>1. 用于查看版本信息的命令：--version/-v
2. 用于创建项目的命令：--create/-c
</code></pre>
<pre><code class="language-js">#! /usr/bin/env node

const process = require('process')
const packageJson = require('../package.json')

/*
* 接收命令行传过来的指令参数
* 由于第一第二个为path信息，我们用不到，所以从第三个开始取
*/
const argvs = process.argv.slice(2)

switch (argvs[0] || '-c') {
    /** 查看当前插件版本 */
    case '-v':
    case '--version':
      console.log(`v${packageJson.version}`)
      break
    /** 创建项目 */
    case '-c':
    case '--create':
      console.log('Create project')
      break
}
</code></pre>
<p>编写完成后，如果想要在命令行中进行验证，此时我们可以在命令行中输入以下命令：</p>
<pre><code>npm link
</code></pre>
<p>然后在命令行中输入</p>
<pre><code>ct -v
</code></pre>
<p>之后我们便可以在命令行工具中看到打印出的版本信息了：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64ceba3fbadc4f4abe059babe25415a2~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>到这里，我们基本的命令定义环节就完成了。</p>
<h2 id="第二步实现项目创建逻辑">第二步：实现项目创建逻辑</h2>
<p>接下来我们就要开始创建项目了。在开始实现具体逻辑之前，我们可以先捋一下可能会经历哪些步骤：</p>
<pre><code>第一步：创建项目
第二步：创建项目所需基本文件以及文件夹。比如 package.json 文件，src 目录等
第三步：创建完成后，跳转到对应的目录下执行安装步骤
</code></pre>
<p>基于以上的几个步骤，我们来实现具体的逻辑。</p>
<h3 id="创建项目">创建项目</h3>
<p>首先，我们在 <code>src/create</code> 路径下，创建 <code>index.js</code> 文件，用于编写具体的创建逻辑。</p>
<pre><code class="language-js">module.exports.run = () =&gt; {}
</code></pre>
<p>之后，我们在 <code>bin/ct.js</code> 文件中引入，并在执行 <code>-c/--create</code> 时调用这个方法：</p>
<pre><code class="language-js">const { run } = require('../src/create/index')

// ....省略好多好多代码

/** 创建包项目 */
case '-c':
case '--create':
  run()
  break

// ....省略好多好多代码
</code></pre>
<p>参照 <code>vue-cli</code> 的模式，在创建项目的时候，我们可以通过 <code>交互式命令</code> 的方式让创建的过程更加友好。这里我们会使用到一个包：<a href="https://www.npmjs.com/package/inquirer">inquirer</a>。通过它我们可以定义交互式命令。</p>
<p>首先，我们在本地对其进行安装</p>
<pre><code>yarn add -D inquirer
</code></pre>
<p>之后，我们在 <code>src/constants</code> 目录下，创建 <code>questions.js</code>，用于定义具体的步骤：</p>
<pre><code class="language-js">/**
 * 定义交互式命令行的问题
 */
const DEFAULT_QUESTIONS = [{
  type: 'input',
  name: 'PROJECT_NAME',
  message: 'Project name:',
  validate: function (name) {
    const done = this.async()
    // 如果目录已经存在，提示修改目录名称
    if (['', null, undefined].includes(name)) {
      done('Please enter the project name!', true)
      return
    }
    if (fs.existsSync(name)) {
      done(`The directory &quot;${name}&quot; is exist!!Please reset the dirname.`, true)
      return
    }
    done(null, true)
  }
}, {
  type: 'input',
  name: 'PROJECT_DESCRIPTION',
  message: 'Project description:'
}, {
  type: 'input',
  name: 'PROJECT_AUTHOR',
  message: 'Project author:'
}]

module.exports = { DEFAULT_QUESTIONS }
</code></pre>
<p>这里对用到的配置项做下简单的解释，关于更多其他的配置项，有兴趣的小伙伴可以<a href="https://www.npmjs.com/package/inquirer#examples">戳</a>：</p>
<pre><code> type ${string} 交互类型
 name ${string} 用来接收用户输入内容的key
 message ${string} 交互信息
 validate ${function} 校验方法
</code></pre>
<p>创建完成后，在 <code>src/create/index.js</code> 中引入 <code>inquirer</code> 以及上述定义的交互步骤：</p>
<pre><code class="language-js">const inquirer = require('inquirer')
const { DEFAULT_QUESTIONS } = require('../constants/questions')

module.exports.run = async () =&gt; {
  try {
    // 获取输入的信息
    const answers = await inquirer.prompt(DEFAULT_QUESTIONS)
  } catch (error) {
    console.log(chalk.red(`Create objet defeat! The error message is: ${error}`))
  }
}
</code></pre>
<p>此时，我们在控制台中执行 <code>ct -c</code> 命令时，便可以看到交互式的输入界面：</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be16805e94dd4db7a1460e67f9a709cb~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>输入完成后，我们将 <code>answers</code> 输出到控制台：</p>
<figure data-type="image" tabindex="3"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f876a4cdd8454452b748190157a7fb17~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>结果是我们输入的内容，对应的key是我们在自定义问题时设置的name属性。我们可以针对输入的 <code>PROJECT_NAME</code> 属性，创建对应的项目文件夹。</p>
<p>我们可以通过nodejs中提供的 <code>fs.mkdir</code> 的方式来创建文件夹，这里我推荐给大家一个谷歌开源的库：<a href="https://www.npmjs.com/package/zx">zx</a>。这个库封装了一系列的shell命令，以便让我们可以像在控制台中一样使用命令：</p>
<pre><code>yarn add -D zx
</code></pre>
<p>回到 <code>src/create/index.js</code> 文件，我们在其中引入 <code>zx</code>，并通过它创建我们的项目文件夹。<strong>注意：在使用zx时，需要在文件顶部指明 <code>#!/usr/bin/env zx</code></strong>：</p>
<pre><code class="language-js">#!/usr/bin/env zx
// ....省略好多好多代码

const answers = await inquirer.prompt(questions)
// 创建新的目录
await $`mkdir ${answers.PROJECT_NAME}`

// ....省略好多好多代码
</code></pre>
<h3 id="创建常用的文件">创建常用的文件</h3>
<p>在开始这个步骤前，我们可以先思考下，在新建一个项目的时候，比较常用的文件可能会有哪些？相信小伙伴们的心里都有自己的答案。</p>
<p>在这里，我将创建包括 <code>package.json</code>、<code>.gitignore</code>、<code>src/index.js</code> 等文件，并事先将文件内容模板定义在 <code>src/create/constants/defaultInit.js</code>中：</p>
<pre><code class="language-js">// 定义index.js内容
const INDEX_CONTENT = {
    filename: 'src/index.js',
    content: ''
}
// 定义package.json内容
const PACKAGE_CONTENT = {
    filename: 'package.json',
    content: JSON.stringify({
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: {
            &quot;ca&quot;: &quot;git add -A &amp;&amp; git-cz -av&quot;,
            &quot;commit&quot;: &quot;git-cz&quot;
        },
        &quot;keywords&quot;: [],
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;devDependencies&quot;: {
            &quot;husky&quot;: &quot;^5.0.9&quot;,
            &quot;commitizen&quot;: &quot;^4.2.3&quot;,
            &quot;cz-conventional-changelog&quot;: &quot;^3.3.0&quot;,
            &quot;lint-staged&quot;: &quot;^10.5.4&quot;
        }
    })
}

// 定义.czrc内容
const CZRC_CONTENT = {
    filename: '.czrc',
    content: '{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }'
}
// 定义.huskyrc内容
const HUSKYRC_CONTENT = {
    filename: '.huskyrc.yml',
    content: `hooks:
      pre-commit: lint-staged
      commit-msg: 'commitlint -E HUSKY_GIT_PARAMS'
    `
}
// 定义.commitlintrc内容
const COMMITLINTRC_CONTENT = {
    filename: '.commitlintrc.yml',
    content: `extends:
      - '@commitlint/config-conventional'
    `
}
// 定义.lintstagedrc内容
const LINTSTAGEDRC_CONTENT = {
    filename: '.lintstagedrc.yml',
    content: `'**/*.{js, jsx, vue}':
      - 'eslint --fix'
      - 'git add'
    '**/*.{less, md}':
      - 'prettier --write'
      - 'git add'
    `
}

// 定义.gitignore
const GIT_IGNORE_CONTENT = {
    filename: '.gitignore',
    content: '/node_modules'
}

module.exports = {
    INDEX_CONTENT,
    PACKAGE_CONTENT,
    CZRC_CONTENT,
    HUSKYRC_CONTENT,
    COMMITLINTRC_CONTENT,
    LINTSTAGEDRC_CONTENT,
    GIT_IGNORE_CONTENT
}
</code></pre>
<p>而后，在 <code>src/create</code> 目录下创建 <code>default.js</code>，并将文件模板引入，编写创建文件的逻辑。该文件抛出一个方法，接受上一步骤中的问题答案，并依此将文件填入对应的路径中。话不多说，上代码：</p>
<pre><code class="language-js">#!/usr/bin/env zx

require('zx/globals')
const {
  INDEX_CONTENT,
  PACKAGE_CONTENT,
  CZRC_CONTENT,
  HUSKYRC_CONTENT,
  COMMITLINTRC_CONTENT,
  LINTSTAGEDRC_CONTENT,
  GIT_IGNORE_CONTENT
} = require('../../constants/defaultInit')

/**
 * 复制template目录下的所有文件到指定目录
 * @param {Object} answers 输入的信息
 */
module.exports = (answers) =&gt; {
    const { PROJECT_NAME } = answers
    const baseDir = `${process.cwd()}/${PROJECT_NAME}`
    // 创建src目录，并创建index.js文件
    fs.mkdir(`${baseDir}/src`, { recursive: true }, err =&gt; {
      if (err) {
        console.log({err})
        return
      }
      // 创建文件
      const files = [
        INDEX_CONTENT,
        PACKAGE_CONTENT,
        CZRC_CONTENT,
        HUSKYRC_CONTENT,
        COMMITLINTRC_CONTENT,
        LINTSTAGEDRC_CONTENT,
        GIT_IGNORE_CONTENT
      ]
      files.forEach(file =&gt; {
        const { filename, content } = file
        let fileContent = content
        // 如果是package.json，则填入相应的信息
        if (filename === 'package.json') {
          const { PROJECT_NAME, PROJECT_DESCRIPTION, PROJECT_AUTHOR } = answers
          const packageContent = {
            name: PROJECT_NAME,
            author: PROJECT_AUTHOR,
            description: PROJECT_DESCRIPTION,
            ...JSON.parse(content)
          }
          fileContent = JSON.stringify(packageContent, null, '\t')
        }
        fs.writeFile(`${baseDir}/${file.filename}`, fileContent, {
          encoding: 'utf-8'
        }, err =&gt; {
          err &amp;&amp; console.log({ type: 'Create index.js failed: ', err })
        })
      })
    })
}
</code></pre>
<p>再次回到 <code>scr/create/index.js</code> 文件中，将该方法引入并执行：</p>
<pre><code class="language-js">const initObject = require('../utils/default')

// ....省略好多好多代码

// 获取输入的信息
const answers = await inquirer.prompt(questions)
// 创建新的目录
await $`mkdir ${answers.PROJECT_NAME}`
// 创建文件
await initObject(answers)

// ....省略好多好多代码
</code></pre>
<h3 id="跳转到对应的目录执行安装操作">跳转到对应的目录，执行安装操作</h3>
<p>这一步就很简单了，只需要跳转到我们创建好的目录下，并安装所需的包即可：</p>
<pre><code class="language-js">// src/create/index.js

// ....省略好多好多代码

// 获取输入的信息
const answers = await inquirer.prompt(questions)
// 创建新的目录
await $`mkdir ${answers.PROJECT_NAME}`
// 创建文件
await initObject(answers)
// 跳转至目录
cd(dirName)
// 执行安装命令
await $`yarn`

// ....省略好多好多代码
</code></pre>
<p>至此，所有的基本逻辑就都完成啦~</p>
<h2 id="第三步发布这个工具到npm">第三步：发布这个工具到npm</h2>
<p>完成编写后，我们直接执行事先设置好的 <code>pub</code> 命令发布即可。</p>
<h1 id="扩展阅读">扩展阅读</h1>
<h2 id="关于命令解析">关于命令解析</h2>
<p>本文中我们通过 <code>process.argv</code> 来解析输入的命令，如果是简单的项目还好，要是后续脚手架功能日益复杂，诸多命令若仍需要通过这种方式去解析未免有些繁琐了，这里推荐大家一个第三方包：<a href="https://www.npmjs.com/package/commander">commander</a>，它可以让这个过程更加简便一些，并且可以通过它配置 help 信息，有兴趣的小伙伴快去试试看吧~</p>
<h2 id="关于打印信息的颜色">关于打印信息的颜色</h2>
<p>针对不同类别的控制台打印信息，其实可以设置相应的颜色，这样看起来更加直观，也更加美观。在上文中提到的 <code>zx</code>中，也封装了 <code>chalk</code>，只要引入了 <code>zx</code> 便可直接使用。通过它可以为控制台输出信息“上色”。举个🌰：</p>
<pre><code class="language-js">console.log(chalk.red(`Create objet defeat! The error message is: ${error}`))
</code></pre>
<p>更多的颜色跟使用方式，小伙伴们也可以去研究一下，让控制台输出也多姿多彩起来~</p>
<h1 id="结束语">结束语</h1>
<p>行文至此，我们已经完成了一个属于自己的简单脚手架工具。大家后期可以根据自己的需求对其持续优化，也可以思考下别的小伙伴在使用你的脚手架的时候会需要些什么，怎么做才可以帮助更多的小伙伴提升人效。</p>
<p>关于cli工具，崔大在B站也有一期详细的讲解视频，大家也可以去参考：<a href="https://www.bilibili.com/video/BV1jK4y197Ne?spm_id_from=333.999.0.0">传送门</a></p>
<p>本文中的脚手架工具已经上传到<a href="https://github.com/luhaifeng666/cli-create-tool">git</a>, 欢迎⭐️交流~</p>
<p>同时也已上传至 <a href="https://www.npmjs.com/package/cli-create-tool">npm</a>, 有兴趣的小伙伴们可以全局安装尝试下~</p>
<p>看到这里，快动手织个网吧~</p>

            </div>
            
            <div id="vcomments"></div>
            <span id="comment-count"></span>
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://luhaifeng666.github.io/post/liu-lan-qi-zhong-hao-de-chu-li/">
                  <h3 class="post-title">
                    浏览器中+号的处理
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script type="text/javascript">
      // 设置valine
      new Valine({
        av: AV,
        el: '#vcomments',
        count_el: '#comment-count',
        appId: 'zYWibXSnGWE9VHeQWDPXrJIF-gzGzoHsz',
        appKey: 'qsFJvfKHzCIlBAzfJRaJEJRF',
        placeholder: '你说，我在听',
        visitor: true
      })
    </script>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
